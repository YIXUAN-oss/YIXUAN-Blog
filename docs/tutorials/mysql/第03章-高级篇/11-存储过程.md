# 存储过程与函数

> 存储过程是预编译的SQL语句集合，提高性能和代码复用性。本章学习存储过程的创建和使用。

## 📋 本章目录

- [一、存储过程概述](#一存储过程概述)
- [二、变量](#二变量)
- [三、流程控制](#三流程控制)
- [四、游标和异常处理](#四游标和异常处理)
- [五、存储函数](#五存储函数)

---

## 一、存储过程概述

### 1.1 什么是存储过程？

**存储过程（Stored Procedure）** 是一组预编译的SQL语句集合，类似于编程语言中的函数。

**特点：**
- 📦 **封装复用**：封装复杂逻辑，可重复调用
- 📈 **提高性能**：预编译，减少网络传输
- 🔒 **安全性高**：隐藏SQL细节，控制权限
- 🔄 **事务支持**：可包含完整的事务逻辑

### 1.2 存储过程 vs 普通SQL

| 特性 | 存储过程 | 普通SQL |
|------|---------|---------|
| 编译 | 预编译，只编译一次 | 每次执行都编译 |
| 网络传输 | 只传输调用命令 | 传输完整SQL |
| 复用性 | 高，可重复调用 | 需要重复编写 |
| 逻辑复杂度 | 支持复杂逻辑 | 有限 |
| 性能 | 较好 | 一般 |

### 1.3 💼 实际工作中什么时候用存储过程？

**适合使用存储过程的场景：**

**场景1：复杂的业务逻辑（推荐）**
```sql
-- 例如：订单结算流程
-- 涉及：检查库存、创建订单、扣减库存、计算优惠、扣减余额、增加积分等
CALL p_create_order(user_id, product_id, quantity, @order_id, @result);
```
**为什么用**：封装复杂逻辑，减少应用层代码，减少网络往返次数。

**场景2：批量数据处理**
```sql
-- 例如：每日账单结算
CALL p_daily_settlement('2024-01-01');
-- 内部处理：统计当日订单、计算佣金、生成报表、发送通知
```
**为什么用**：一次性处理大量数据，减少网络传输，提高效率。

**场景3：定时任务（配合Event）**
```sql
-- 例如：自动关闭超时未支付订单
CALL p_close_timeout_orders();
-- 每隔5分钟执行一次
```
**为什么用**：适合放在数据库层定期执行，无需额外的调度服务。

**场景4：数据迁移和清洗**
```sql
-- 例如：历史数据归档
CALL p_archive_old_orders('2023-01-01');
-- 将旧订单迁移到历史表
```

**不适合使用存储过程的场景：**
- ❌ 简单的CRUD操作（增删改查）
- ❌ 需要频繁修改的业务逻辑（维护成本高）
- ❌ 跨数据库平台的应用（移植性差）
- ❌ 复杂的业务逻辑（应该放在应用层）

**现代开发趋势：**
- ⚠️ 微服务架构下，更推荐将逻辑放在应用层
- ✅ 但对于数据密集型操作，存储过程仍有优势
- ✅ 金融、电商等对性能要求高的场景，存储过程很常用

### 1.4 基本语法

```sql
CREATE PROCEDURE 存储过程名称([参数列表])
BEGIN
    -- SQL语句
END;
```

**示例1：简单存储过程**
```sql
-- 创建：统计学生总数
DELIMITER $$

CREATE PROCEDURE p_count_students()
BEGIN
    SELECT COUNT(*) AS total FROM students;
END$$

DELIMITER ;

-- 调用
CALL p_count_students();
```

**DELIMITER说明：**
- MySQL默认使用`;`作为语句结束符
- 存储过程内部也需要`;`，会产生冲突
- 使用`DELIMITER`临时改变结束符为`$$`
- 创建完成后再改回`;`

### 1.4 查看和删除

```sql
-- 查看所有存储过程
SELECT * FROM information_schema.ROUTINES 
WHERE ROUTINE_SCHEMA = 'database_name';

-- 查看存储过程定义
SHOW CREATE PROCEDURE p_count_students;

-- 删除存储过程
DROP PROCEDURE IF EXISTS p_count_students;
```

---

## 二、变量

### 2.1 系统变量

系统变量是MySQL服务器提供的变量，分为全局变量（GLOBAL）和会话变量（SESSION）。

```sql
-- 查看系统变量
SHOW SESSION VARIABLES;
SHOW GLOBAL VARIABLES;

-- 模糊查询
SHOW SESSION VARIABLES LIKE 'auto%';

-- 查看指定变量
SELECT @@session.autocommit;
SELECT @@global.autocommit;

-- 设置系统变量
SET SESSION autocommit = 0;
SET @@session.autocommit = 1;

SET GLOBAL max_connections = 200;
SET @@global.max_connections = 200;
```

**注意事项：**
- 不指定SESSION/GLOBAL时，默认为SESSION
- 全局变量在MySQL重启后会失效
- 永久生效需要修改配置文件 `/etc/my.cnf`

### 2.2 用户自定义变量

用户变量不需要提前声明，使用 `@变量名` 即可，作用域为当前连接。

```sql
-- 赋值方式1：SET
SET @name = '张三';
SET @age := 20;
SET @gender := '男', @hobby := '编程';

-- 赋值方式2：SELECT
SELECT @color := '蓝色';
SELECT COUNT(*) INTO @total FROM students;

-- 使用变量
SELECT @name, @age, @gender, @hobby, @color, @total;
```

**注意：**
- 未初始化的变量值为 NULL
- `=` 和 `:=` 都可以用于赋值，但 `SELECT` 语句中建议用 `:=`

### 2.3 局部变量

局部变量在存储过程内部使用，需要用 `DECLARE` 声明，作用域为 BEGIN...END 块。

```sql
DELIMITER $$

CREATE PROCEDURE p_local_var()
BEGIN
    -- 声明局部变量
    DECLARE stu_count INT DEFAULT 0;
    DECLARE avg_age DECIMAL(5,2);
    
    -- 赋值方式1：SET
    SET stu_count = 100;
    
    -- 赋值方式2：SELECT INTO
    SELECT COUNT(*) INTO stu_count FROM students;
    SELECT AVG(age) INTO avg_age FROM students;
    
    -- 使用变量
    SELECT stu_count, avg_age;
END$$

DELIMITER ;

CALL p_local_var();
```

**三种变量对比：**

| 类型 | 作用域 | 声明方式 | 前缀 |
|------|--------|---------|------|
| 系统变量 | 全局/会话 | 系统定义 | @@ |
| 用户变量 | 当前连接 | 无需声明 | @ |
| 局部变量 | BEGIN...END | DECLARE | 无 |

---

## 三、流程控制

### 3.1 IF 条件判断

```sql
DELIMITER $$

CREATE PROCEDURE p_grade(IN score INT, OUT result VARCHAR(10))
BEGIN
    IF score >= 90 THEN
        SET result = '优秀';
    ELSEIF score >= 80 THEN
        SET result = '良好';
    ELSEIF score >= 60 THEN
        SET result = '及格';
    ELSE
        SET result = '不及格';
    END IF;
END$$

DELIMITER ;

-- 调用
CALL p_grade(85, @result);
SELECT @result;
```

### 3.2 参数类型

存储过程支持三种参数类型：

| 类型 | 说明 | 示例 |
|------|------|------|
| **IN** | 输入参数（默认） | 传入数据 |
| **OUT** | 输出参数 | 返回结果 |
| **INOUT** | 输入输出参数 | 既传入又返回 |

**示例：IN 和 OUT**
```sql
DELIMITER $$

CREATE PROCEDURE p_calc(
    IN num1 INT,
    IN num2 INT,
    OUT sum_result INT,
    OUT mul_result INT
)
BEGIN
    SET sum_result = num1 + num2;
    SET mul_result = num1 * num2;
END$$

DELIMITER ;

-- 调用
CALL p_calc(10, 20, @sum, @mul);
SELECT @sum, @mul;  -- 输出：30, 200
```

**示例：INOUT**
```sql
DELIMITER $$

-- 将200分制转换为百分制
CREATE PROCEDURE p_convert_score(INOUT score DOUBLE)
BEGIN
    SET score = score * 0.5;
END$$

DELIMITER ;

-- 调用
SET @score = 180;
CALL p_convert_score(@score);
SELECT @score;  -- 输出：90
```

### 3.3 CASE 语句

```sql
DELIMITER $$

CREATE PROCEDURE p_quarter(IN month INT, OUT result VARCHAR(20))
BEGIN
    CASE
        WHEN month >= 1 AND month <= 3 THEN
            SET result = '第一季度';
        WHEN month >= 4 AND month <= 6 THEN
            SET result = '第二季度';
        WHEN month >= 7 AND month <= 9 THEN
            SET result = '第三季度';
        WHEN month >= 10 AND month <= 12 THEN
            SET result = '第四季度';
        ELSE
            SET result = '非法月份';
    END CASE;
END$$

DELIMITER ;

-- 调用
CALL p_quarter(5, @quarter);
SELECT @quarter;  -- 输出：第二季度
```

### 3.4 WHILE 循环

```sql
DELIMITER $$

-- 计算1到n的累加和
CREATE PROCEDURE p_sum_while(IN n INT, OUT total INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    SET total = 0;
    
    WHILE i <= n DO
        SET total = total + i;
        SET i = i + 1;
    END WHILE;
END$$

DELIMITER ;

-- 调用
CALL p_sum_while(100, @total);
SELECT @total;  -- 输出：5050
```

### 3.5 REPEAT 循环

REPEAT 循环类似于 do...while，至少执行一次。

```sql
DELIMITER $$

CREATE PROCEDURE p_sum_repeat(IN n INT, OUT total INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    SET total = 0;
    
    REPEAT
        SET total = total + i;
        SET i = i + 1;
    UNTIL i > n  -- 注意：这里不需要分号
    END REPEAT;
END$$

DELIMITER ;

-- 调用
CALL p_sum_repeat(100, @total);
SELECT @total;  -- 输出：5050
```

### 3.6 LOOP 循环

LOOP 循环需要手动控制退出，配合 LEAVE 和 ITERATE 使用。

**LEAVE**：退出循环（类似 break）
**ITERATE**：跳过当前循环（类似 continue）

```sql
DELIMITER $$

-- 累加和（使用LEAVE退出）
CREATE PROCEDURE p_sum_loop(IN n INT, OUT total INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    SET total = 0;
    
    sum_loop: LOOP
        IF i > n THEN
            LEAVE sum_loop;  -- 退出循环
        END IF;
        
        SET total = total + i;
        SET i = i + 1;
    END LOOP sum_loop;
END$$

DELIMITER ;

-- 累加偶数（使用ITERATE跳过奇数）
CREATE PROCEDURE p_sum_even(IN n INT, OUT total INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    SET total = 0;
    
    sum_loop: LOOP
        IF i > n THEN
            LEAVE sum_loop;
        END IF;
        
        -- 跳过奇数
        IF i % 2 = 1 THEN
            SET i = i + 1;
            ITERATE sum_loop;  -- 跳过本次循环
        END IF;
        
        SET total = total + i;
        SET i = i + 1;
    END LOOP sum_loop;
END$$

DELIMITER ;

-- 调用
CALL p_sum_even(100, @total);
SELECT @total;  -- 输出：2550（2+4+6+...+100）
```

---

## 四、游标和异常处理

### 4.1 游标（Cursor）

**游标** 用于存储查询结果集，可以逐行处理数据。

**使用步骤：**
1. 声明游标：`DECLARE cursor_name CURSOR FOR select_statement`
2. 打开游标：`OPEN cursor_name`
3. 获取数据：`FETCH cursor_name INTO variables`
4. 关闭游标：`CLOSE cursor_name`

**示例：**
```sql
DELIMITER $$

CREATE PROCEDURE p_cursor_demo(IN max_age INT)
BEGIN
    -- 声明变量
    DECLARE u_name VARCHAR(100);
    DECLARE u_age INT;
    DECLARE done INT DEFAULT 0;
    
    -- 声明游标
    DECLARE user_cursor CURSOR FOR 
        SELECT name, age FROM students WHERE age <= max_age;
    
    -- 声明异常处理（后面会讲）
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    
    -- 创建结果表
    CREATE TEMPORARY TABLE IF NOT EXISTS temp_result(
        name VARCHAR(100),
        age INT
    );
    
    -- 打开游标
    OPEN user_cursor;
    
    -- 循环读取
    read_loop: LOOP
        FETCH user_cursor INTO u_name, u_age;
        
        IF done = 1 THEN
            LEAVE read_loop;
        END IF;
        
        INSERT INTO temp_result VALUES(u_name, u_age);
    END LOOP read_loop;
    
    -- 关闭游标
    CLOSE user_cursor;
    
    -- 显示结果
    SELECT * FROM temp_result;
    DROP TEMPORARY TABLE temp_result;
END$$

DELIMITER ;

-- 调用
CALL p_cursor_demo(20);
```

### 4.2 条件处理程序（Handler）

条件处理程序用于处理异常情况，类似于try-catch。

**语法：**
```sql
DECLARE handler_action HANDLER 
FOR condition_value [, condition_value] ...
statement;
```

**handler_action：**
- `CONTINUE`：继续执行
- `EXIT`：退出当前BEGIN...END块

**condition_value：**
- `SQLSTATE sqlstate_value`：状态码，如 '02000'
- `SQLWARNING`：所有01开头的状态码
- `NOT FOUND`：所有02开头的状态码
- `SQLEXCEPTION`：其他未捕获的异常

**示例：处理游标结束**
```sql
DELIMITER $$

CREATE PROCEDURE p_handler_demo()
BEGIN
    DECLARE u_name VARCHAR(100);
    DECLARE done INT DEFAULT 0;
    
    DECLARE user_cursor CURSOR FOR SELECT name FROM students;
    
    -- 方式1：使用状态码
    -- DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    -- 方式2：使用NOT FOUND（推荐）
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    
    OPEN user_cursor;
    
    read_loop: LOOP
        FETCH user_cursor INTO u_name;
        IF done = 1 THEN
            LEAVE read_loop;
        END IF;
        SELECT u_name;
    END LOOP;
    
    CLOSE user_cursor;
END$$

DELIMITER ;
```

**示例：异常处理**
```sql
DELIMITER $$

CREATE PROCEDURE p_exception_demo()
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        -- 发生异常时回滚
        ROLLBACK;
        SELECT '操作失败，已回滚' AS message;
    END;
    
    START TRANSACTION;
    
    -- 可能出错的操作
    INSERT INTO users VALUES (1, '张三');
    INSERT INTO users VALUES (1, '李四');  -- 主键冲突
    
    COMMIT;
    SELECT '操作成功' AS message;
END$$

DELIMITER ;
```

---

## 五、存储函数

### 5.1 存储函数 vs 存储过程

| 特性 | 存储函数 | 存储过程 |
|------|---------|---------|
| 返回值 | 必须有返回值 | 可以无返回值 |
| 参数 | 只能是IN类型 | IN/OUT/INOUT |
| 调用方式 | SELECT function() | CALL procedure() |
| 使用场景 | 计算并返回单个值 | 复杂业务逻辑 |

### 5.2 创建存储函数

**语法：**
```sql
CREATE FUNCTION 函数名(参数列表)
RETURNS 返回类型 [characteristic ...]
BEGIN
    -- 函数体
    RETURN 值;
END;
```

**characteristic 说明：**
- `DETERMINISTIC`：相同输入产生相同输出
- `NO SQL`：不包含SQL语句
- `READS SQL DATA`：包含读取数据的语句

**示例1：简单函数**
```sql
DELIMITER $$

CREATE FUNCTION fn_sum(n INT)
RETURNS INT DETERMINISTIC
BEGIN
    DECLARE total INT DEFAULT 0;
    DECLARE i INT DEFAULT 1;
    
    WHILE i <= n DO
        SET total = total + i;
        SET i = i + 1;
    END WHILE;
    
    RETURN total;
END$$

DELIMITER ;

-- 调用
SELECT fn_sum(100);  -- 输出：5050
```

**示例2：复杂函数**
```sql
DELIMITER $$

-- 计算学生平均分
CREATE FUNCTION fn_avg_score(stu_id INT)
RETURNS DECIMAL(5,2) READS SQL DATA
BEGIN
    DECLARE avg_score DECIMAL(5,2);
    
    SELECT AVG(score) INTO avg_score
    FROM scores
    WHERE student_id = stu_id;
    
    RETURN IFNULL(avg_score, 0);
END$$

DELIMITER ;

-- 调用
SELECT fn_avg_score(1);
SELECT name, fn_avg_score(id) AS avg_score FROM students;
```

### 5.3 删除存储函数

```sql
DROP FUNCTION IF EXISTS fn_sum;
```

---

## 六、综合案例

### 案例：银行转账存储过程

```sql
DELIMITER $$

CREATE PROCEDURE p_transfer(
    IN from_account INT,
    IN to_account INT,
    IN amount DECIMAL(10,2),
    OUT result VARCHAR(100)
)
BEGIN
    DECLARE from_balance DECIMAL(10,2);
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET result = '转账失败：发生异常';
    END;
    
    -- 开启事务
    START TRANSACTION;
    
    -- 检查余额
    SELECT balance INTO from_balance 
    FROM accounts 
    WHERE account_id = from_account FOR UPDATE;
    
    IF from_balance < amount THEN
        ROLLBACK;
        SET result = '转账失败：余额不足';
    ELSE
        -- 扣款
        UPDATE accounts 
        SET balance = balance - amount 
        WHERE account_id = from_account;
        
        -- 入账
        UPDATE accounts 
        SET balance = balance + amount 
        WHERE account_id = to_account;
        
        COMMIT;
        SET result = '转账成功';
    END IF;
END$$

DELIMITER ;

-- 调用
CALL p_transfer(1, 2, 100, @result);
SELECT @result;
```

---

## 七、本章总结

### 核心要点

1. **存储过程**：预编译的SQL集合，提高性能和复用性
2. **变量类型**：系统变量、用户变量、局部变量
3. **参数类型**：IN（输入）、OUT（输出）、INOUT（输入输出）
4. **流程控制**：IF、CASE、WHILE、REPEAT、LOOP
5. **游标**：处理查询结果集
6. **异常处理**：HANDLER捕获异常
7. **存储函数**：有返回值，用于计算

### 最佳实践

1. ✅ 使用有意义的命名：`p_` 开头表示过程，`fn_` 表示函数
2. ✅ 添加注释说明参数和逻辑
3. ✅ 使用异常处理保证数据一致性
4. ✅ 复杂逻辑使用事务
5. ✅ 避免过度使用存储过程（维护成本高）

---

## 练习题

```sql
-- 1. 创建存储过程：根据部门ID统计员工数和平均工资
DELIMITER $$
CREATE PROCEDURE p_dept_stats(IN dept_id INT)
BEGIN
    SELECT 
        COUNT(*) AS emp_count,
        AVG(salary) AS avg_salary
    FROM employees
    WHERE department_id = dept_id;
END$$
DELIMITER ;

-- 2. 创建存储函数：计算员工工龄
DELIMITER $$
CREATE FUNCTION fn_work_years(hire_date DATE)
RETURNS INT DETERMINISTIC
BEGIN
    RETURN TIMESTAMPDIFF(YEAR, hire_date, CURDATE());
END$$
DELIMITER ;

SELECT name, fn_work_years(hire_date) AS work_years FROM employees;
```

---

**下一章：[第12章 - 触发器](12-触发器.md)** →
