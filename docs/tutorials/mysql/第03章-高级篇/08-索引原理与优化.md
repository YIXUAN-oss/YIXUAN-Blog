# 索引原理与优化

> 索引是提升数据库查询性能的关键技术。本章将深入学习索引的原理、类型和优化策略。

## 📋 本章目录

- [一、索引概述](#一索引概述)
- [二、索引数据结构](#二索引数据结构)
- [三、索引分类](#三索引分类)
- [四、索引操作](#四索引操作)
- [五、索引设计原则](#五索引设计原则)
- [六、索引优化实战](#六索引优化实战)

---

## 一、索引概述

### 1.1 什么是索引？

**索引**是帮助MySQL高效获取数据的**数据结构**，类似于书籍的目录。

**没有索引：**
```sql
-- 全表扫描，逐行查找
SELECT * FROM users WHERE age = 25;  -- 扫描100万行
```

**有索引：**
```sql
-- 通过索引快速定位
SELECT * FROM users WHERE age = 25;  -- 只需几次查找
```

### 1.2 索引的优缺点

**优点：**
- ✅ 提高查询效率（降低IO成本）
- ✅ 降低排序成本（索引已排序）
- ✅ 加速表连接

**缺点：**
- ❌ 占用存储空间
- ❌ 降低写入效率（INSERT、UPDATE、DELETE）
- ❌ 维护成本

---

## 二、索引数据结构

### 2.1 B+Tree索引（最常用）

**特点：**
- 多路平衡查找树
- 所有数据存储在叶子节点
- 叶子节点通过链表连接
- 适合范围查询

**B+Tree结构：**
```
          [50]
         /    \
    [20,30]   [70,90]
     /  |  \   /  |  \
[10][25][40][60][80][100]  ← 叶子节点（存储数据）
 ←→  ←→  ←→  ←→  ←→  ←→     ← 双向链表
```

**优势：**
- 查询效率稳定（O(log n)）
- 范围查询效率高
- 磁盘IO次数少

### 2.2 Hash索引

**特点：**
- 基于哈希表实现
- 只支持等值查询（=、IN）
- 不支持范围查询
- Memory引擎默认

**示例：**
```sql
CREATE TABLE hash_table (
    id INT,
    name VARCHAR(50),
    INDEX USING HASH (id)
) ENGINE=Memory;
```

### 2.3 Full-Text全文索引

用于全文搜索，支持MATCH...AGAINST语法。

```sql
CREATE TABLE articles (
    id INT PRIMARY KEY,
    title VARCHAR(200),
    content TEXT,
    FULLTEXT (title, content)
);

-- 全文搜索
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST('MySQL');
```

---

## 三、索引分类

### 3.1 按功能分类

| 类型 | 说明 | 关键字 |
|------|------|--------|
| **主键索引** | 唯一标识，非空唯一 | PRIMARY KEY |
| **唯一索引** | 值唯一，可为NULL | UNIQUE |
| **普通索引** | 最基本的索引 | INDEX / KEY |
| **全文索引** | 全文搜索 | FULLTEXT |

### 3.2 按列数分类

**单列索引：**
```sql
CREATE INDEX idx_name ON users(name);
```

**联合索引（复合索引）：**
```sql
CREATE INDEX idx_name_age ON users(name, age);
```

### 3.3 按存储方式分类

**聚集索引（Clustered Index）：**
- 数据按照主键顺序存储
- 一张表只能有一个聚集索引
- InnoDB中主键就是聚集索引

**非聚集索引（Secondary Index）：**
- 索引和数据分开存储
- 叶子节点存储主键值
- 需要回表查询

**示例：**
```sql
-- 主键索引（聚集索引）
SELECT * FROM users WHERE id = 1;  -- 直接找到数据

-- 普通索引（非聚集索引）
SELECT * FROM users WHERE name = '张三';
-- 1. 通过name索引找到id
-- 2. 再通过id（主键）找到完整数据（回表）
```

---

## 四、索引操作

### 4.1 创建索引

```sql
-- 方式1：创建表时定义
CREATE TABLE users (
    id INT PRIMARY KEY,                    -- 主键索引
    username VARCHAR(50) UNIQUE,          -- 唯一索引
    email VARCHAR(100),
    age INT,
    INDEX idx_age (age),                  -- 普通索引
    INDEX idx_email_age (email, age)      -- 联合索引
);

-- 方式2：单独创建
CREATE INDEX idx_name ON users(name);
CREATE UNIQUE INDEX idx_email ON users(email);

-- 方式3：ALTER TABLE
ALTER TABLE users ADD INDEX idx_age (age);
ALTER TABLE users ADD UNIQUE (email);

-- 联合索引
CREATE INDEX idx_name_age_salary ON employees(name, age, salary);
```

### 4.2 查看索引

```sql
-- 查看表的索引
SHOW INDEX FROM users;

-- 查看索引使用情况
EXPLAIN SELECT * FROM users WHERE age = 25;
```

### 4.3 删除索引

```sql
-- 删除索引
DROP INDEX idx_age ON users;

-- ALTER TABLE方式
ALTER TABLE users DROP INDEX idx_age;

-- 删除主键索引
ALTER TABLE users DROP PRIMARY KEY;
```

---

## 五、索引设计原则

### 5.1 💼 实际工作中什么时候创建索引？

**真实场景分析：**

**场景1：用户登录查询（高频查询）**
```sql
-- 业务场景：用户登录，每秒数千次查询
SELECT * FROM users WHERE username = 'zhangsan' AND password = '***';

-- 索引方案
CREATE INDEX idx_username_password ON users(username, password);

-- 为什么：
-- 1. 登录是高频操作，必须快
-- 2. username和password组合查询，用联合索引
-- 3. username放前面（选择性更高）
```

**场景2：订单列表查询（分页查询）**
```sql
-- 业务场景：查看我的订单列表
SELECT * FROM orders 
WHERE user_id = 1001 AND status = 2 
ORDER BY create_time DESC 
LIMIT 10 OFFSET 0;

-- 索引方案
CREATE INDEX idx_user_status_time ON orders(user_id, status, create_time);

-- 为什么：
-- 1. WHERE条件：user_id、status
-- 2. ORDER BY：create_time
-- 3. 联合索引覆盖所有条件，避免filesort
```

**场景3：商品搜索（模糊查询）**
```sql
-- 业务场景：搜索商品
SELECT * FROM products WHERE title LIKE 'iPhone%';  -- ✅ 前缀匹配
SELECT * FROM products WHERE title LIKE '%Phone%';  -- ❌ 中间匹配

-- 索引方案
CREATE INDEX idx_title ON products(title);
-- 或使用全文索引
CREATE FULLTEXT INDEX idx_title_full ON products(title);

-- 为什么：
-- 1. LIKE 'iPhone%' 可以用索引（前缀匹配）
-- 2. LIKE '%Phone%' 不能用普通索引，需要全文索引
-- 3. 电商搜索推荐用ElasticSearch等专业搜索引擎
```

**场景4：订单统计查询（聚合查询）**
```sql
-- 业务场景：统计每个用户的订单数和总金额
SELECT user_id, COUNT(*), SUM(amount) 
FROM orders 
GROUP BY user_id;

-- 索引方案
CREATE INDEX idx_user_amount ON orders(user_id, amount);

-- 为什么：
-- 1. GROUP BY user_id 需要索引
-- 2. SUM(amount) 如果amount也在索引中，可以直接从索引读取（覆盖索引）
```

**场景5：关联查询（JOIN）**
```sql
-- 业务场景：查询订单及用户信息
SELECT o.*, u.name, u.phone 
FROM orders o 
INNER JOIN users u ON o.user_id = u.id 
WHERE o.status = 1;

-- 索引方案
CREATE INDEX idx_status ON orders(status);  -- orders表
CREATE INDEX idx_id ON users(id);          -- users表（主键自动有索引）

-- 为什么：
-- 1. JOIN的关联字段必须有索引
-- 2. WHERE条件的字段也要有索引
-- 3. 小表驱动大表，优化器会选择合适的执行顺序
```

### 5.2 何时创建索引

**✅ 应该创建索引：**
1. **WHERE条件字段**
```sql
SELECT * FROM users WHERE age = 25;  -- age应该加索引
```

2. **ORDER BY字段**
```sql
SELECT * FROM products ORDER BY price;  -- price加索引
```

3. **GROUP BY字段**
```sql
SELECT dept_id, COUNT(*) FROM employees GROUP BY dept_id;
-- dept_id加索引
```

4. **JOIN关联字段**
```sql
SELECT * FROM orders o JOIN users u ON o.user_id = u.id;
-- user_id和id都应加索引
```

5. **数据量大且查询频繁的表**

**实际工作经验：**
- 📊 **数据量参考**：表数据 > 10万行，应该考虑索引
- ⏱️ **查询频率**：每秒 > 100次查询，必须优化索引
- 🔍 **慢查询**：查询时间 > 1秒，检查是否缺少索引
- 💡 **监控工具**：使用慢查询日志找出需要优化的SQL

### 5.2 何时不创建索引

**❌ 不应该创建索引：**
1. 数据量小的表（< 1000行）
2. 频繁更新的字段
3. 重复数据多的字段（如性别）
4. WHERE条件中用不到的字段

### 5.3 索引设计原则

**1. 选择性高的字段优先**
```sql
-- 好：唯一性高
CREATE INDEX idx_id_card ON users(id_card);  -- 身份证号

-- 差：重复值多
CREATE INDEX idx_gender ON users(gender);    -- 性别只有2个值
```

**2. 使用前缀索引（长字符串）**
```sql
-- 对长字符串只索引前几个字符
CREATE INDEX idx_email ON users(email(10));  -- 只索引前10个字符
```

**3. 联合索引遵循最左前缀原则**
```sql
CREATE INDEX idx_abc ON table(a, b, c);

-- ✅ 能用到索引
WHERE a = 1
WHERE a = 1 AND b = 2
WHERE a = 1 AND b = 2 AND c = 3

-- ❌ 不能用到索引
WHERE b = 2
WHERE c = 3
WHERE b = 2 AND c = 3
```

**4. 控制索引数量**
- 建议单表索引不超过5个
- 单个索引字段不超过5个

**5. 避免冗余索引**
```sql
-- 已有 INDEX(a, b)
CREATE INDEX idx_a ON table(a);  -- ❌ 冗余，可以删除
```

---

## 六、索引优化实战

### 6.1 使用EXPLAIN分析

```sql
EXPLAIN SELECT * FROM users WHERE age = 25;
```

**关键字段：**
- `type`：访问类型（ALL < index < range < ref < eq_ref < const）
- `key`：实际使用的索引
- `rows`：扫描的行数
- `Extra`：额外信息

### 6.2 索引失效场景

**1. 违反最左前缀原则**
```sql
-- 索引：INDEX(name, age, salary)
SELECT * FROM emp WHERE age = 30;  -- ❌ 失效（跳过name）
```

**2. 在索引列上使用函数**
```sql
SELECT * FROM users WHERE YEAR(birth_date) = 1990;  -- ❌ 失效
-- 改进
SELECT * FROM users WHERE birth_date BETWEEN '1990-01-01' AND '1990-12-31';
```

**3. 字符串不加引号**
```sql
SELECT * FROM users WHERE phone = 13800138000;  -- ❌ 失效（类型转换）
-- 改进
SELECT * FROM users WHERE phone = '13800138000';  -- ✅ 正常
```

**4. 使用OR连接**
```sql
SELECT * FROM users WHERE id = 1 OR name = '张三';  -- 可能失效
-- 改进：使用UNION
SELECT * FROM users WHERE id = 1
UNION
SELECT * FROM users WHERE name = '张三';
```

**5. 使用!=、<>、NOT IN**
```sql
SELECT * FROM users WHERE age != 25;  -- 可能失效
```

### 6.3 覆盖索引优化

**覆盖索引**：查询的字段都在索引中，不需要回表。

```sql
-- 创建联合索引
CREATE INDEX idx_name_age_salary ON employees(name, age, salary);

-- ✅ 覆盖索引（不需要回表）
SELECT name, age, salary FROM employees WHERE name = '张三';

-- ❌ 非覆盖索引（需要回表）
SELECT * FROM employees WHERE name = '张三';
```

### 6.4 索引下推（ICP）

MySQL 5.6+支持索引下推优化。

```sql
-- 索引：INDEX(name, age)
SELECT * FROM users WHERE name LIKE '张%' AND age = 25;

-- 没有ICP：先根据name筛选，回表后再判断age
-- 有ICP：在索引中就判断age条件，减少回表次数
```

### 6.5 实战案例

**案例1：慢查询优化**
```sql
-- 原SQL（慢）
SELECT * FROM orders WHERE DATE(create_time) = '2024-01-01';
-- 问题：在索引列上使用函数

-- 优化后（快）
SELECT * FROM orders 
WHERE create_time >= '2024-01-01' 
  AND create_time < '2024-01-02';
```

**案例2：联合索引优化**
```sql
-- 查询条件：name、age、city
SELECT * FROM users WHERE name = '张三' AND age = 25 AND city = '北京';

-- 方案1：三个单列索引（不推荐）
CREATE INDEX idx_name ON users(name);
CREATE INDEX idx_age ON users(age);
CREATE INDEX idx_city ON users(city);

-- 方案2：一个联合索引（推荐）
CREATE INDEX idx_name_age_city ON users(name, age, city);
```

---

## 七、本章总结

### 核心要点

1. **索引是数据结构**：B+Tree最常用
2. **索引分类**：主键、唯一、普通、全文；聚集、非聚集
3. **创建原则**：WHERE、ORDER BY、GROUP BY字段
4. **最左前缀**：联合索引的关键规则
5. **避免失效**：不在索引列上使用函数、注意类型匹配

### 优化策略

| 场景 | 优化方案 |
|------|---------|
| 长字符串 | 前缀索引 |
| 多条件查询 | 联合索引 |
| 只查索引字段 | 覆盖索引 |
| 范围+等值 | 等值放前面 |
| 慢查询 | EXPLAIN分析 |

### 最佳实践

1. ✅ 为WHERE、ORDER BY、GROUP BY字段建索引
2. ✅ 优先使用联合索引
3. ✅ 遵循最左前缀原则
4. ✅ 避免在索引列上使用函数
5. ✅ 定期分析和优化索引

---

## 练习题

```sql
-- 1. 创建合适的索引
CREATE TABLE orders (
    id INT PRIMARY KEY,
    user_id INT,
    product_id INT,
    amount DECIMAL(10,2),
    status TINYINT,
    create_time DATETIME
);

-- 思考：应该创建哪些索引？
-- 答案：
CREATE INDEX idx_user_id ON orders(user_id);
CREATE INDEX idx_status_create_time ON orders(status, create_time);

-- 2. 分析SQL执行计划
EXPLAIN SELECT * FROM orders 
WHERE user_id = 100 AND status = 1 
ORDER BY create_time;

-- 3. 优化慢查询
-- 原SQL
SELECT * FROM users WHERE SUBSTRING(phone, 1, 3) = '138';
-- 优化后
SELECT * FROM users WHERE phone LIKE '138%';
```

---

**下一章：[第09章 - SQL性能优化](09-SQL性能优化.md)** →
