# 多表查询与连接

> 实际项目中，数据通常分布在多个表中。本章将学习如何通过连接和子查询获取多表关联数据。

## 📋 本章目录

- [一、多表查询概述](#一多表查询概述)
- [二、内连接](#二内连接)
- [三、外连接](#三外连接)
- [四、自连接](#四自连接)
- [五、联合查询](#五联合查询)
- [六、子查询](#六子查询)
- [七、综合案例](#七综合案例)

---

## 一、多表查询概述

### 1.1 为什么需要多表查询？

在数据库设计中，为避免数据冗余，我们将数据分散存储在多个表中。查询时需要关联这些表。

**示例表结构：**

```sql
-- 部门表
CREATE TABLE dept (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL
);

-- 员工表
CREATE TABLE emp (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    age INT,
    salary DECIMAL(10,2),
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES dept(id)
);

-- 插入测试数据
INSERT INTO dept VALUES (1,'技术部'),(2,'销售部'),(3,'财务部');
INSERT INTO emp VALUES 
(1,'张三',28,8000,1),
(2,'李四',32,12000,2),
(3,'王五',25,7000,1),
(4,'赵六',30,NULL,NULL);
```

### 1.2 笛卡尔积

直接查询多个表会产生笛卡尔积（交叉连接）。

```sql
-- 产生笛卡尔积（3×4=12条记录）
SELECT * FROM emp, dept;

-- 正确的做法：添加连接条件
SELECT * FROM emp, dept WHERE emp.dept_id = dept.id;
```

---

## 二、内连接

### 2.1 什么是内连接？

内连接（INNER JOIN）返回两个表中**匹配的记录**，不匹配的记录被过滤掉。

### 2.2 内连接语法

**隐式内连接：**
```sql
SELECT 字段列表 FROM 表1, 表2 WHERE 连接条件;
```

**显式内连接：**
```sql
SELECT 字段列表 FROM 表1 INNER JOIN 表2 ON 连接条件;
-- INNER可以省略
SELECT 字段列表 FROM 表1 JOIN 表2 ON 连接条件;
```

### 2.3 示例演示

```sql
-- 隐式内连接：查询所有员工及其部门
SELECT emp.name, dept.name 
FROM emp, dept 
WHERE emp.dept_id = dept.id;

-- 使用表别名
SELECT e.name AS 员工姓名, d.name AS 部门名称
FROM emp e, dept d 
WHERE e.dept_id = d.id;

-- 显式内连接
SELECT e.name, e.salary, d.name
FROM emp e 
INNER JOIN dept d ON e.dept_id = d.id;

-- 多条件连接
SELECT e.name, d.name
FROM emp e 
JOIN dept d ON e.dept_id = d.id 
WHERE e.salary > 8000;
```

### 2.4 多表连接

```sql
-- 三表连接：员工、部门、项目
SELECT e.name, d.name, p.project_name
FROM emp e
JOIN dept d ON e.dept_id = d.id
JOIN projects p ON p.dept_id = d.id;
```

---

## 三、外连接

### 3.1 什么是外连接？

外连接不仅返回匹配的记录，还返回不匹配的记录。

- **左外连接（LEFT JOIN）**：返回左表所有记录 + 右表匹配的记录
- **右外连接（RIGHT JOIN）**：返回右表所有记录 + 左表匹配的记录

### 3.2 左外连接

```sql
-- 查询所有员工及其部门（包括没有部门的员工）
SELECT e.*, d.name AS dept_name
FROM emp e 
LEFT JOIN dept d ON e.dept_id = d.id;

-- 结果包含赵六（dept_id为NULL）
+----+------+-----+--------+---------+-----------+
| id | name | age | salary | dept_id | dept_name |
+----+------+-----+--------+---------+-----------+
|  1 | 张三 |  28 |   8000 |       1 | 技术部    |
|  2 | 李四 |  32 |  12000 |       2 | 销售部    |
|  3 | 王五 |  25 |   7000 |       1 | 技术部    |
|  4 | 赵六 |  30 |   NULL |    NULL | NULL      |
+----+------+-----+--------+---------+-----------+

-- 查询没有分配部门的员工
SELECT e.*
FROM emp e 
LEFT JOIN dept d ON e.dept_id = d.id
WHERE d.id IS NULL;
```

### 3.3 右外连接

```sql
-- 查询所有部门及其员工（包括没有员工的部门）
SELECT d.*, e.name
FROM emp e 
RIGHT JOIN dept d ON e.dept_id = d.id;

-- 等价于左外连接（调换位置）
SELECT d.*, e.name
FROM dept d 
LEFT JOIN emp e ON d.id = e.dept_id;
```

### 3.4 内连接 vs 外连接

| 类型 | 说明 | 不匹配记录 |
|------|------|-----------|
| **内连接** | 只返回匹配的记录 | 过滤掉 |
| **左外连接** | 返回左表所有记录 | 右表字段为NULL |
| **右外连接** | 返回右表所有记录 | 左表字段为NULL |

**选择建议：**
- ✅ 需要所有记录 → 外连接
- ✅ 只要匹配记录 → 内连接
- ✅ 左外连接最常用

---

## 四、自连接

### 4.1 什么是自连接？

表与自己进行连接，常用于处理**层级关系**。

### 4.2 应用场景

```sql
-- 员工表（包含上级领导ID）
CREATE TABLE employee (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    manager_id INT
);

INSERT INTO employee VALUES
(1, '张总', NULL),
(2, '李经理', 1),
(3, '王主管', 2),
(4, '小明', 3),
(5, '小红', 3);
```

### 4.3 自连接查询

```sql
-- 查询每个员工及其直属领导
SELECT 
    e.name AS 员工,
    m.name AS 领导
FROM employee e
LEFT JOIN employee m ON e.manager_id = m.id;

-- 结果
+--------+--------+
| 员工   | 领导   |
+--------+--------+
| 张总   | NULL   |
| 李经理 | 张总   |
| 王主管 | 李经理 |
| 小明   | 王主管 |
| 小红   | 王主管 |
+--------+--------+

-- 查询没有领导的员工（最高领导）
SELECT e.name
FROM employee e
WHERE e.manager_id IS NULL;
```

---

## 五、联合查询

### 5.1 UNION 联合查询

将多个查询结果合并为一个结果集。

**语法：**
```sql
SELECT 字段列表 FROM 表1
UNION [ALL]
SELECT 字段列表 FROM 表2;
```

### 5.2 UNION vs UNION ALL

| 类型 | 说明 |
|------|------|
| `UNION` | 合并结果并**去重** |
| `UNION ALL` | 合并结果**不去重**（性能更好） |

### 5.3 示例演示

```sql
-- 查询年龄小于30或工资大于10000的员工
SELECT * FROM emp WHERE age < 30
UNION
SELECT * FROM emp WHERE salary > 10000;

-- 不去重版本（效率更高）
SELECT * FROM emp WHERE age < 30
UNION ALL
SELECT * FROM emp WHERE salary > 10000;
```

### 5.4 注意事项

⚠️ **要求**：
- 多个查询的**列数必须相同**
- 字段类型应该兼容
- 只能有一个ORDER BY（放在最后）

```sql
-- 正确示例
SELECT id, name FROM emp
UNION
SELECT id, name FROM manager
ORDER BY id;

-- 错误示例（列数不同）
SELECT id, name FROM emp
UNION
SELECT id FROM manager;  -- ❌ 列数不匹配
```

---

## 六、子查询

### 6.1 什么是子查询？

子查询是嵌套在其他SQL语句中的SELECT语句。

### 6.2 子查询分类

根据返回结果分类：

| 类型 | 说明 | 示例 |
|------|------|------|
| **标量子查询** | 返回单个值 | `SELECT ... WHERE age > (子查询)` |
| **列子查询** | 返回一列多行 | `SELECT ... WHERE id IN (子查询)` |
| **行子查询** | 返回一行多列 | `SELECT ... WHERE (a,b) = (子查询)` |
| **表子查询** | 返回多行多列 | `SELECT ... FROM (子查询)` |

### 6.3 标量子查询

返回**单个值**（一行一列）。

```sql
-- 1. 查询工资高于平均工资的员工
SELECT * FROM emp 
WHERE salary > (SELECT AVG(salary) FROM emp);

-- 2. 查询"销售部"的所有员工
SELECT * FROM emp 
WHERE dept_id = (SELECT id FROM dept WHERE name = '销售部');

-- 3. 查询在"张三"入职之后的员工
SELECT * FROM emp 
WHERE hire_date > (SELECT hire_date FROM emp WHERE name = '张三');
```

### 6.4 列子查询

返回**一列多行**。

**常用操作符：**
- `IN`：在列表中
- `NOT IN`：不在列表中
- `ANY` / `SOME`：满足任意一个
- `ALL`：满足所有

```sql
-- 1. 查询"销售部"和"市场部"的所有员工
SELECT * FROM emp 
WHERE dept_id IN (
    SELECT id FROM dept 
    WHERE name IN ('销售部', '市场部')
);

-- 2. 查询工资比财务部所有人都高的员工
SELECT * FROM emp 
WHERE salary > ALL (
    SELECT salary FROM emp 
    WHERE dept_id = (SELECT id FROM dept WHERE name = '财务部')
);

-- 3. 查询工资比研发部任意一人高的员工
SELECT * FROM emp 
WHERE salary > ANY (
    SELECT salary FROM emp 
    WHERE dept_id = (SELECT id FROM dept WHERE name = '研发部')
);
```

### 6.5 行子查询

返回**一行多列**。

```sql
-- 查询与"张三"的工资和部门都相同的员工
SELECT * FROM emp 
WHERE (salary, dept_id) = (
    SELECT salary, dept_id FROM emp WHERE name = '张三'
);

-- 查询与"李四"的年龄和工资都相同的员工
SELECT * FROM emp 
WHERE (age, salary) = (
    SELECT age, salary FROM emp WHERE name = '李四'
);
```

### 6.6 表子查询

返回**多行多列**，可作为临时表使用。

```sql
-- 1. 查询入职日期在"2020-01-01"之后的员工及其部门
SELECT e.*, d.name
FROM (
    SELECT * FROM emp WHERE hire_date > '2020-01-01'
) e
LEFT JOIN dept d ON e.dept_id = d.id;

-- 2. 查询工资排名前5的员工
SELECT * FROM (
    SELECT * FROM emp ORDER BY salary DESC LIMIT 5
) top5;

-- 3. 部门统计后再查询
SELECT d.name, stat.emp_count, stat.avg_salary
FROM dept d
JOIN (
    SELECT 
        dept_id, 
        COUNT(*) AS emp_count,
        AVG(salary) AS avg_salary
    FROM emp
    GROUP BY dept_id
) stat ON d.id = stat.dept_id;
```

---

## 七、综合案例

### 案例1：员工工资分析

```sql
-- 查询每个部门的员工数、平均工资、最高工资
SELECT 
    d.name AS 部门,
    COUNT(e.id) AS 员工数,
    ROUND(AVG(e.salary), 2) AS 平均工资,
    MAX(e.salary) AS 最高工资
FROM dept d
LEFT JOIN emp e ON d.id = e.dept_id
GROUP BY d.id, d.name
ORDER BY 平均工资 DESC;
```

### 案例2：找出每个部门工资最高的员工

```sql
-- 方法一：子查询
SELECT e.*, d.name AS dept_name
FROM emp e
JOIN dept d ON e.dept_id = d.id
WHERE e.salary = (
    SELECT MAX(salary) 
    FROM emp 
    WHERE dept_id = e.dept_id
);

-- 方法二：窗口函数（MySQL 8.0+）
SELECT name, dept_name, salary
FROM (
    SELECT 
        e.name,
        d.name AS dept_name,
        e.salary,
        RANK() OVER (PARTITION BY e.dept_id ORDER BY e.salary DESC) AS rn
    FROM emp e
    JOIN dept d ON e.dept_id = d.id
) ranked
WHERE rn = 1;
```

### 案例3：员工层级查询

```sql
-- 查询完整的管理层级
WITH RECURSIVE emp_hierarchy AS (
    -- 起始：最高领导
    SELECT id, name, manager_id, 1 AS level, name AS path
    FROM employee
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- 递归：下级员工
    SELECT e.id, e.name, e.manager_id, h.level + 1, 
           CONCAT(h.path, ' -> ', e.name)
    FROM employee e
    JOIN emp_hierarchy h ON e.manager_id = h.id
)
SELECT * FROM emp_hierarchy ORDER BY level, id;
```

---

## 八、本章总结

### 核心要点

1. **内连接**：只返回匹配的记录（最常用）
2. **外连接**：返回所有记录（左外连接最常用）
3. **自连接**：处理层级关系
4. **联合查询**：合并多个查询结果
5. **子查询**：嵌套查询，分为标量、列、行、表子查询

### 连接类型选择

```
需要所有记录？
├─ 是 → 外连接（LEFT/RIGHT JOIN）
└─ 否 → 内连接（INNER JOIN）

同一张表关联？
└─ 是 → 自连接

合并多个查询结果？
└─ 是 → UNION / UNION ALL
```

### 性能优化建议

- ✅ 优先使用JOIN而不是子查询
- ✅ 注意添加索引到连接字段
- ✅ 避免SELECT *，明确指定字段
- ✅ 大数据量时注意笛卡尔积

---

## 练习题

```sql
-- 1. 查询所有员工及其部门（包括无部门员工）
SELECT e.*, d.name 
FROM emp e 
LEFT JOIN dept d ON e.dept_id = d.id;

-- 2. 查询工资高于本部门平均工资的员工
SELECT e.*
FROM emp e
WHERE e.salary > (
    SELECT AVG(salary) 
    FROM emp 
    WHERE dept_id = e.dept_id
);

-- 3. 查询没有员工的部门
SELECT d.*
FROM dept d
LEFT JOIN emp e ON d.id = e.dept_id
WHERE e.id IS NULL;

-- 4. 查询每个部门工资排名前3的员工
SELECT dept_name, name, salary, rn
FROM (
    SELECT 
        d.name AS dept_name,
        e.name,
        e.salary,
        ROW_NUMBER() OVER (PARTITION BY e.dept_id ORDER BY e.salary DESC) AS rn
    FROM emp e
    JOIN dept d ON e.dept_id = d.id
) ranked
WHERE rn <= 3;
```

---

**下一章：[第06章 - 事务管理](06-事务管理.md)** →
