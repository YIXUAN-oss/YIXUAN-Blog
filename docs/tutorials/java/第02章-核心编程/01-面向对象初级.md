# 面向对象编程 - 初级

> **本章重点：** 类与对象、方法、构造器、this关键字、方法重载与重写
> 
> **面试频率：** ⭐⭐⭐⭐⭐

---

## 目录
- [一、类与对象](#一类与对象)
- [二、成员方法](#二成员方法)
- [三、递归应用](#三递归应用)
- [四、方法重载](#四方法重载)
- [五、方法重写](#五方法重写)
- [六、可变参数](#六可变参数)
- [七、作用域](#七作用域)
- [八、构造器](#八构造器)
- [九、this关键字](#九this关键字)
- [十、面试常见问题](#十面试常见问题)

---

## 一、类与对象

### 1.1 基本概念

**类（Class）：** 对具有相同属性和行为的一类对象的抽象描述。
**对象（Object）：** 类的一个具体实例。

**理解：**
- 类是模板（设计图）
- 对象是根据模板创建的实体

**例子：**
- 类：人类、汽车类、手机类
- 对象：张三、特斯拉Model 3、iPhone 15

### 1.2 类的定义

**语法：**
```java
[访问修饰符] class 类名 {
    // 属性（成员变量）
    数据类型 属性名;
    
    // 方法（成员方法）
    返回类型 方法名(参数列表) {
        // 方法体
    }
}
```

**示例：**
```java
class Cat {
    // 属性
    String name;
    int age;
    String color;
    
    // 方法
    public void eat() {
        System.out.println(name + "在吃饭");
    }
    
    public void sleep() {
        System.out.println(name + "在睡觉");
    }
}
```

### 1.3 对象的创建和使用

**语法：**
```java
类名 对象名 = new 类名();
```

**示例：**
```java
public class Main {
    public static void main(String[] args) {
        // 1. 创建对象
        Cat cat1 = new Cat();
        
        // 2. 给属性赋值
        cat1.name = "小白";
        cat1.age = 2;
        cat1.color = "白色";
        
        // 3. 调用方法
        cat1.eat();
        cat1.sleep();
        
        // 创建第二只猫
        Cat cat2 = new Cat();
        cat2.name = "小黑";
        cat2.age = 3;
        cat2.color = "黑色";
        
        // 输出信息
        System.out.println(cat1.name + " " + cat1.age + "岁 " + cat1.color);
        System.out.println(cat2.name + " " + cat2.age + "岁 " + cat2.color);
    }
}

class Cat {
    String name;
    int age;
    String color;
    
    public void eat() {
        System.out.println(name + "在吃饭");
    }
    
    public void sleep() {
        System.out.println(name + "在睡觉");
    }
}
```

### 1.4 对象在内存中的存储

```
栈（Stack）               堆（Heap）
┌──────────┐           ┌─────────────────┐
│ cat1 ─────┼──────────>│ Cat对象          │
└──────────┘           │ name = "小白"    │
                       │ age = 2          │
┌──────────┐           │ color = "白色"   │
│ cat2 ─────┼──────┐   └─────────────────┘
└──────────┘      │   
                  │   ┌─────────────────┐
                  └──>│ Cat对象          │
                      │ name = "小黑"    │
                      │ age = 3          │
                      │ color = "黑色"   │
                      └─────────────────┘
```

---

## 二、成员方法

### 2.1 方法的定义

**语法：**
```java
[访问修饰符] 返回类型 方法名(参数列表) {
    // 方法体
    return 返回值;  // 如果返回类型不是void
}
```

**示例：**
```java
class Calculator {
    // 无参无返回值
    public void printInfo() {
        System.out.println("这是一个计算器");
    }
    
    // 有参无返回值
    public void printSum(int a, int b) {
        System.out.println("和为：" + (a + b));
    }
    
    // 有参有返回值
    public int add(int a, int b) {
        return a + b;
    }
    
    // 多个参数
    public int add(int a, int b, int c) {
        return a + b + c;
    }
}
```

### 2.2 方法的调用

```java
public class Main {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        
        // 调用无返回值方法
        calc.printInfo();
        calc.printSum(10, 20);
        
        // 调用有返回值方法
        int result = calc.add(10, 20);
        System.out.println("结果：" + result);
        
        // 直接使用返回值
        System.out.println("结果：" + calc.add(10, 20, 30));
    }
}
```

### 2.3 方法的注意事项

**1. 返回值类型**
- 一个方法最多有一个返回值
- 如果需要返回多个值，可以返回数组或对象
- void 表示无返回值

**2. 参数传递**
- 基本类型：值传递（传递的是副本）
- 引用类型：引用传递（传递的是地址）

**示例：**
```java
class Test {
    // 基本类型参数
    public void change1(int num) {
        num = 100;  // 不会改变外部变量
    }
    
    // 引用类型参数
    public void change2(int[] arr) {
        arr[0] = 100;  // 会改变外部数组
    }
}

// 测试
Test t = new Test();
int num = 10;
t.change1(num);
System.out.println(num);  // 10（未改变）

int[] arr = {1, 2, 3};
t.change2(arr);
System.out.println(arr[0]);  // 100（已改变）
```

---

## 三、递归应用

### 3.1 什么是递归

**递归：** 方法自己调用自己。

**递归的要素：**
1. **递归头**：什么时候不调用自身方法（终止条件）
2. **递归体**：什么时候需要调用自身方法

### 3.2 斐波那契数列

**问题：** 求第n个斐波那契数（1, 1, 2, 3, 5, 8, 13...）

**分析：**
- f(1) = 1
- f(2) = 1
- f(n) = f(n-1) + f(n-2)

**代码：**
```java
class Fibonacci {
    public int fib(int n) {
        // 递归头
        if (n == 1 || n == 2) {
            return 1;
        }
        // 递归体
        return fib(n - 1) + fib(n - 2);
    }
}

// 使用
Fibonacci f = new Fibonacci();
System.out.println(f.fib(7));  // 13
```

### 3.3 猴子吃桃问题

**问题：** 猴子第一天摘了若干桃子，当天吃了一半，还不过瘾，又多吃了一个。第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天都吃前一天剩下的一半零一个。到第10天早上想吃时，只剩下一个桃子了。求第一天共摘了多少桃子？

**分析：**
- day(10) = 1
- day(n) = (day(n+1) + 1) × 2

**代码：**
```java
class Monkey {
    public int peach(int day) {
        if (day == 10) {
            return 1;
        } else if (day >= 1 && day <= 9) {
            return (peach(day + 1) + 1) * 2;
        } else {
            return -1;  // 无效输入
        }
    }
}

// 使用
Monkey m = new Monkey();
System.out.println("第一天桃子数：" + m.peach(1));  // 1534
```

### 3.4 迷宫问题

**问题：** 小球从起点(1,1)出发，找到终点(6,5)的路径。

**策略：** 下 → 右 → 上 → 左

**代码：**
```java
class Maze {
    /**
     * 找路方法
     * @param map 地图数组
     * @param i 当前行
     * @param j 当前列
     * @return 是否找到路径
     * 
     * 地图说明：
     * 0 - 可以走的路
     * 1 - 障碍物
     * 2 - 走过的路（可以通）
     * 3 - 走过的路（走不通）
     */
    public boolean findWay(int[][] map, int i, int j) {
        // 已经到达终点
        if (map[6][5] == 2) {
            return true;
        }
        
        // 当前位置可以走
        if (map[i][j] == 0) {
            // 假定可以走通
            map[i][j] = 2;
            
            // 按照策略：下 → 右 → 上 → 左 尝试
            if (findWay(map, i + 1, j)) {  // 向下
                return true;
            } else if (findWay(map, i, j + 1)) {  // 向右
                return true;
            } else if (findWay(map, i - 1, j)) {  // 向上
                return true;
            } else if (findWay(map, i, j - 1)) {  // 向左
                return true;
            } else {
                // 四个方向都走不通
                map[i][j] = 3;
                return false;
            }
        } else {
            // 当前位置不可走（1障碍物/2已走/3死路）
            return false;
        }
    }
}

// 使用示例
public class Main {
    public static void main(String[] args) {
        // 创建地图（8行7列）
        int[][] map = new int[8][7];
        
        // 设置障碍物（地图边界）
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;  // 第一行
            map[7][i] = 1;  // 最后一行
        }
        for (int i = 0; i < 8; i++) {
            map[i][0] = 1;  // 第一列
            map[i][6] = 1;  // 最后一列
        }
        
        // 设置中间障碍物
        map[3][1] = 1;
        map[3][2] = 1;
        
        // 打印初始地图
        System.out.println("=== 初始地图 ===");
        printMap(map);
        
        // 找路
        Maze maze = new Maze();
        maze.findWay(map, 1, 1);
        
        // 打印结果
        System.out.println("=== 找到的路径 ===");
        printMap(map);
    }
    
    public static void printMap(int[][] map) {
        for (int i = 0; i < map.length; i++) {
            for (int j = 0; j < map[i].length; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

---

## 四、方法重载

### 4.1 什么是方法重载

**方法重载（Overload）：** 在同一个类中，方法名相同，但参数列表不同的多个方法。

**作用：** 提高代码的灵活性和可读性

### 4.2 重载的条件

**必须满足：**
1. ✅ 方法名必须相同
2. ✅ 参数列表必须不同（类型、个数、顺序）

**无要求：**
- ❌ 返回类型无要求
- ❌ 访问修饰符无要求

### 4.3 示例代码

```java
class Calculator {
    // 两个int相加
    public int add(int a, int b) {
        return a + b;
    }
    
    // 两个double相加
    public double add(double a, double b) {
        return a + b;
    }
    
    // 三个int相加
    public int add(int a, int b, int c) {
        return a + b + c;
    }
    
    // int和double相加（参数类型顺序不同）
    public double add(int a, double b) {
        return a + b;
    }
    
    public double add(double a, int b) {
        return a + b;
    }
}

// 使用
Calculator calc = new Calculator();
System.out.println(calc.add(10, 20));         // 30
System.out.println(calc.add(10.5, 20.5));     // 31.0
System.out.println(calc.add(10, 20, 30));     // 60
System.out.println(calc.add(10, 20.5));       // 30.5
```

---

## 五、方法重写

### 5.1 什么是方法重写

**方法重写（Override）：** 子类重新定义父类中已有的方法。

**作用：** 实现多态，让子类有自己特定的实现

### 5.2 重写的条件

**必须满足：**
1. ✅ 方法名必须相同
2. ✅ 参数列表必须相同
3. ✅ 返回类型相同或是其子类
4. ✅ 访问权限不能更严格（可以更宽松）

**权限顺序：** public > protected > 默认 > private

### 5.3 示例代码

```java
class Animal {
    public void eat() {
        System.out.println("动物在吃东西");
    }
    
    public void sleep() {
        System.out.println("动物在睡觉");
    }
}

class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("狗在吃骨头");
    }
    
    @Override
    public void sleep() {
        System.out.println("狗在睡觉");
    }
    
    // 狗特有的方法
    public void bark() {
        System.out.println("汪汪汪");
    }
}

class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("猫在吃鱼");
    }
    
    // 猫特有的方法
    public void catchMouse() {
        System.out.println("猫在抓老鼠");
    }
}

// 使用
Animal dog = new Dog();
dog.eat();    // 狗在吃骨头
dog.sleep();  // 狗在睡觉

Animal cat = new Cat();
cat.eat();    // 猫在吃鱼
cat.sleep();  // 动物在睡觉（未重写，调用父类方法）
```

### 5.4 @Override 注解

**作用：**
1. 提高代码可读性
2. 编译时检查（方法签名是否正确）
3. 防止拼写错误

**建议：** 重写方法时始终使用 @Override

```java
class Parent {
    public void show() {
        System.out.println("父类方法");
    }
}

class Child extends Parent {
    @Override
    public void show() {  // 正确重写
        System.out.println("子类方法");
    }
    
    // @Override
    // public void shwo() {  // 编译错误：方法名拼写错误
    //     System.out.println("错误");
    // }
}
```

---

## 六、可变参数

### 6.1 什么是可变参数

**可变参数：** 允许方法接收不定数量的参数。

**语法：**
```java
访问修饰符 返回类型 方法名(数据类型... 参数名) {
    // 方法体
}
```

### 6.2 示例代码

```java
class MathUtils {
    // 可变参数求和
    public int sum(int... nums) {
        int result = 0;
        for (int num : nums) {
            result += num;
        }
        return result;
    }
}

// 使用
MathUtils math = new MathUtils();
System.out.println(math.sum(1, 2));           // 3
System.out.println(math.sum(1, 2, 3));        // 6
System.out.println(math.sum(1, 2, 3, 4, 5));  // 15
```

### 6.3 注意事项

**1. 可变参数本质是数组**
```java
public void test(int... nums) {
    System.out.println(nums.length);  // 可以使用length
    for (int i = 0; i < nums.length; i++) {
        System.out.println(nums[i]);  // 可以用索引访问
    }
}
```

**2. 可变参数必须放在最后**
```java
// ✅ 正确
public void method1(String name, int... nums) { }

// ❌ 错误
// public void method2(int... nums, String name) { }
```

**3. 一个方法最多一个可变参数**
```java
// ❌ 错误
// public void method(int... nums1, int... nums2) { }
```

## 七、作用域

### 7.1 变量的分类

**按作用域分类：**
1. **成员变量（属性）**：定义在类中，方法外
2. **局部变量**：定义在方法中或代码块中

### 7.2 作用域对比

| 特性 | 成员变量（属性） | 局部变量 |
|------|-----------------|----------|
| 定义位置 | 类中，方法外 | 方法中或代码块中 |
| 作用范围 | 整个类 | 定义它的代码块 |
| 默认值 | 有默认值 | 无默认值，必须赋值 |
| 生命周期 | 随对象创建而创建 | 随代码块执行而创建 |
| 修饰符 | 可以使用修饰符 | 不能使用修饰符 |
| 访问方式 | 本类或其他类使用 | 只能在本方法中使用 |

### 7.3 示例代码

```java
class Person {
    // 成员变量（属性）
    String name = "张三";  // 有默认值null，这里赋值为"张三"
    int age;              // 有默认值0
    
    public void test() {
        // 局部变量
        int num;  // 无默认值
        // System.out.println(num);  // ❌ 错误：未初始化
        
        num = 10;  // 必须先赋值
        System.out.println(num);  // ✅ 正确
        
        // 局部变量可以和成员变量同名
        String name = "李四";
        System.out.println(name);       // 李四（就近原则）
        System.out.println(this.name);  // 张三（访问成员变量）
    }
}
```

### 7.4 注意事项

**1. 变量可以重名**
```java
class Test {
    int num = 10;  // 成员变量
    
    public void method() {
        int num = 20;  // 局部变量
        System.out.println(num);       // 20（就近原则）
        System.out.println(this.num);  // 10（访问成员变量）
    }
}
```

**2. 同一作用域中不能重名**
```java
public void method() {
    int num = 10;
    // int num = 20;  // ❌ 错误：重复定义
}
```

---

## 八、构造器

### 8.1 什么是构造器

**构造器（Constructor）：** 用于创建对象时初始化对象的特殊方法。

**特点：**
1. 方法名与类名相同
2. 没有返回值（连void都不写）
3. 创建对象时自动调用
4. 可以重载

### 8.2 构造器的语法

```java
[访问修饰符] 类名(参数列表) {
    // 初始化代码
}
```

### 8.3 示例代码

```java
class Person {
    String name;
    int age;
    
    // 无参构造器
    public Person() {
        System.out.println("无参构造器被调用");
    }
    
    // 有参构造器
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("有参构造器被调用");
    }
}

// 使用
Person p1 = new Person();              // 调用无参构造器
Person p2 = new Person("张三", 20);    // 调用有参构造器
```

### 8.4 默认构造器

**规则：**
- 如果没有定义任何构造器，系统自动提供一个无参构造器
- 一旦定义了构造器，默认构造器就失效

```java
class Dog {
    String name;
    
    // 如果不写任何构造器，系统提供：
    // public Dog() { }
}

class Cat {
    String name;
    
    // 定义了有参构造器
    public Cat(String name) {
        this.name = name;
    }
    
    // ❌ 此时无参构造器失效
    // Cat cat = new Cat();  // 错误
    
    // ✅ 如果需要无参构造器，必须显式定义
    public Cat() {
    }
}
```

### 8.5 构造器重载

```java
class Person {
    String name;
    int age;
    String gender;
    
    public Person() {
    }
    
    public Person(String name) {
        this.name = name;
    }
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public Person(String name, int age, String gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
    }
}

// 使用
Person p1 = new Person();
Person p2 = new Person("张三");
Person p3 = new Person("李四", 20);
Person p4 = new Person("王五", 25, "男");
```

---

## 九、this关键字

### 9.1 什么是this

**this：** 代表当前对象的引用。

**理解：** 哪个对象调用方法，this就代表哪个对象。

### 9.2 this的作用

**1. 区分成员变量和局部变量**
```java
class Person {
    String name;
    int age;
    
    public Person(String name, int age) {
        this.name = name;  // this.name是成员变量，name是参数
        this.age = age;
    }
}
```

**2. 调用本类的方法**
```java
class Person {
    public void eat() {
        System.out.println("吃饭");
    }
    
    public void work() {
        this.eat();  // 调用本类的eat方法
        System.out.println("工作");
    }
}
```

**3. 调用本类的构造器**
```java
class Person {
    String name;
    int age;
    
    public Person() {
        this("未知", 0);  // 调用有参构造器
    }
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

### 9.3 this的注意事项

**1. this()必须放在构造器第一行**
```java
public Person() {
    this("张三", 20);  // ✅ 正确：第一行
    // System.out.println("test");  // 必须在this()之后
}
```

**2. 访问属性遵循就近原则**
```java
class Person {
    String name = "成员变量";
    
    public void test() {
        String name = "局部变量";
        System.out.println(name);       // 局部变量（就近原则）
        System.out.println(this.name);  // 成员变量
    }
}
```

### 9.4 this链式调用

**场景：** 让代码更优雅

```java
class Person {
    private String name;
    private int age;
    
    public Person setName(String name) {
        this.name = name;
        return this;  // 返回当前对象
    }
    
    public Person setAge(int age) {
        this.age = age;
        return this;
    }
    
    public void print() {
        System.out.println(name + ", " + age);
    }
}

// 链式调用
Person p = new Person()
    .setName("张三")
    .setAge(20);
p.print();
```

---

## 十、面试常见问题

### Q1: 面向对象的三大特征是什么？

**答案：**

1. **封装**：隐藏对象的属性和实现细节，仅对外提供公共访问方式
2. **继承**：子类继承父类的属性和方法
3. **多态**：同一个引用类型，使用不同的实例执行不同的操作

---

### Q2: 方法重载和方法重写的区别？

**答案：**

| 特性 | 重载（Overload） | 重写（Override） |
|------|-----------------|-----------------|
| 发生范围 | 同一个类 | 父类和子类 |
| 方法名 | 相同 | 相同 |
| 参数列表 | 必须不同 | 必须相同 |
| 返回类型 | 无要求 | 相同或子类 |
| 访问修饰符 | 无要求 | 不能更严格 |
| 关键字 | 无 | @Override |

---

### Q3: 构造器的作用是什么？有哪些特点？

**答案：**

**作用：** 创建对象时初始化对象

**特点：**
1. 方法名与类名相同
2. 没有返回值
3. 创建对象时自动调用
4. 可以重载
5. 如果不定义，系统提供默认无参构造器

---

### Q4: this关键字的作用？

**答案：**

**作用：**
1. 区分成员变量和局部变量
2. 调用本类的其他方法
3. 调用本类的其他构造器

**注意：**
- this代表当前对象
- this()必须放在构造器第一行

---

### Q5: Java是值传递还是引用传递？

**答案：**

Java只有值传递！

- **基本类型**：传递的是值的副本
- **引用类型**：传递的是地址的副本（指向同一个对象）

```java
void change(int num) {
    num = 100;  // 不影响外部
}

void change(int[] arr) {
    arr[0] = 100;  // 影响外部（传递的是地址）
}
```

---

**上一章：** [数组](../1.JAVA基础入门/04-数组（优化版）.md)

**下一章：** [面向对象中级](02-面向对象中级（优化版）.md) →
