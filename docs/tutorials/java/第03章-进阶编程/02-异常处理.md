# Java 异常处理

> **本章重点：** 异常体系、try-catch-finally、throws、自定义异常
> 
> **面试频率：** ⭐⭐⭐⭐⭐

---

## 目录
- [一、异常处理机制](#一异常处理机制)
- [二、异常体系](#二异常体系)
- [三、常见的运行时异常](#三常见的运行时异常)
- [四、异常处理方式](#四异常处理方式)
- [五、自定义异常](#五自定义异常)
- [六、面试常见问题](#六面试常见问题)

---

## 一、异常处理机制

### 1.1 为什么需要异常处理

**没有异常处理：**
```java
int num1 = 10;
int num2 = 0;
int res = num1 / num2;  // 程序崩溃：ArithmeticException
System.out.println("程序继续运行");  // 不会执行
```

**使用异常处理：**
```java
int num1 = 10;
int num2 = 0;
try {
    int res = num1 / num2;
} catch (Exception e) {
    System.out.println("出现异常：" + e.getMessage());
}
System.out.println("程序继续运行");  // 会执行
```

### 1.2 异常处理的好处

1. **保证程序的健壮性**：即使出现异常，程序也能继续执行
2. **便于调试**：可以获取详细的异常信息
3. **提高用户体验**：给出友好的错误提示

### 1.3 快速生成 try-catch

**IDEA 快捷键：** 
- 选中代码块 → `Ctrl + Alt + T` → 选择 `try-catch`

---

## 二、异常体系

### 2.1 异常的定义

**异常（Exception）：** Java中，将程序执行中发生的不正常情况称为"异常"。

### 2.2 异常体系结构

```
Throwable (所有异常和错误的父类)
├── Error (错误)
│   ├── OutOfMemoryError (内存溢出)
│   ├── StackOverflowError (栈溢出)
│   └── ...
└── Exception (异常)
    ├── RuntimeException (运行时异常)
    │   ├── NullPointerException (空指针)
    │   ├── ArithmeticException (算术异常)
    │   ├── ArrayIndexOutOfBoundsException (数组越界)
    │   ├── ClassCastException (类型转换异常)
    │   └── NumberFormatException (数字格式异常)
    └── 编译时异常 (Checked Exception)
        ├── IOException (IO异常)
        ├── FileNotFoundException (文件未找到)
        ├── SQLException (SQL异常)
        └── ClassNotFoundException (类未找到)
```

### 2.3 Error vs Exception

| 特性 | Error | Exception |
|------|-------|-----------|
| **严重程度** | 严重错误 | 一般性问题 |
| **是否可处理** | 不可处理（JVM问题） | 可以处理 |
| **是否应该捕获** | 不应该捕获 | 应该捕获 |
| **示例** | OutOfMemoryError | NullPointerException |

**Error 示例：**
- `OutOfMemoryError`：内存溢出
- `StackOverflowError`：栈溢出（通常是递归调用太深）

**Exception 分类：**
1. **运行时异常（RuntimeException）**
   - 编译时不强制处理
   - 程序运行时发生
   - 可以通过代码避免

2. **编译时异常（Checked Exception）**
   - 编译时必须处理
   - 否则编译不通过
   - 通常是外部因素导致

---

## 三、常见的运行时异常

### 3.1 NullPointerException（空指针异常）

**发生原因：** 对 null 对象调用方法或访问属性。

**示例：**
```java
String name = null;
System.out.println(name.length());  // NullPointerException
```

**解决方案：**
```java
String name = null;
if (name != null) {
    System.out.println(name.length());
} else {
    System.out.println("name 为 null");
}
```

---

### 3.2 ArithmeticException（算术异常）

**发生原因：** 数学运算异常，如除数为0。

**示例：**
```java
int num1 = 10;
int num2 = 0;
int res = num1 / num2;  // ArithmeticException: / by zero
```

**解决方案：**
```java
int num1 = 10;
int num2 = 0;
if (num2 != 0) {
    int res = num1 / num2;
} else {
    System.out.println("除数不能为0");
}
```

---

### 3.3 ArrayIndexOutOfBoundsException（数组越界异常）

**发生原因：** 访问数组时索引超出范围。

**示例：**
```java
int[] arr = {1, 2, 3};
for (int i = 0; i <= arr.length; i++) {  // 注意：i <= arr.length
    System.out.println(arr[i]);  // 当i=3时，ArrayIndexOutOfBoundsException
}
```

**解决方案：**
```java
int[] arr = {1, 2, 3};
for (int i = 0; i < arr.length; i++) {  // 改为 i < arr.length
    System.out.println(arr[i]);
}
```

---

### 3.4 ClassCastException（类型转换异常）

**发生原因：** 强制类型转换时，对象类型不匹配。

**示例：**
```java
class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}

public class Test {
    public static void main(String[] args) {
        Animal a = new Dog();  // 向上转型
        Dog d = (Dog) a;       // 正确的向下转型
        
        Cat c = (Cat) a;       // ❌ ClassCastException
    }
}
```

**解决方案：**
```java
Animal a = new Dog();
if (a instanceof Cat) {
    Cat c = (Cat) a;
} else {
    System.out.println("类型不匹配，无法转换");
}
```

---

### 3.5 NumberFormatException（数字格式异常）

**发生原因：** 将不能转换为数字的字符串转换为数字。

**示例：**
```java
String str = "abc";
int num = Integer.parseInt(str);  // NumberFormatException
```

**解决方案：**
```java
String str = "abc";
try {
    int num = Integer.parseInt(str);
} catch (NumberFormatException e) {
    System.out.println("字符串格式不正确：" + str);
}
```

---

## 四、异常处理方式

### 4.1 try-catch-finally

**语法：**
```java
try {
    // 可能出现异常的代码
} catch (异常类型1 e) {
    // 处理异常类型1
} catch (异常类型2 e) {
    // 处理异常类型2
} finally {
    // 无论是否发生异常，都会执行
}
```

**执行流程：**
1. 执行 try 块中的代码
2. 如果没有异常，跳过 catch 块
3. 如果有异常，匹配对应的 catch 块
4. 无论是否有异常，都执行 finally 块

**示例：**
```java
public class TryCatchDemo {
    public static void main(String[] args) {
        try {
            int num1 = 10;
            int num2 = 0;
            int res = num1 / num2;  // 会抛出 ArithmeticException
            System.out.println("结果：" + res);
        } catch (ArithmeticException e) {
            System.out.println("出现算术异常：" + e.getMessage());
        } catch (Exception e) {
            System.out.println("出现其他异常：" + e.getMessage());
        } finally {
            System.out.println("无论如何都会执行");
        }
        
        System.out.println("程序继续运行");
    }
}
```

### 4.2 catch 块的注意事项

**1. 可以有多个 catch 块**
```java
try {
    // 代码
} catch (NullPointerException e) {
    // 处理空指针异常
} catch (ArithmeticException e) {
    // 处理算术异常
} catch (Exception e) {
    // 处理其他所有异常
}
```

**2. 子类异常要放在父类异常前面**
```java
// ✅ 正确：子类在前
try {
    // 代码
} catch (NullPointerException e) {
    // 具体异常
} catch (Exception e) {
    // 父类异常
}

// ❌ 错误：父类在前，子类永远捕获不到
try {
    // 代码
} catch (Exception e) {
    // 父类异常（会捕获所有异常）
} catch (NullPointerException e) {  // 编译错误
    // 子类异常
}
```

**3. JDK 7 可以一次捕获多个异常**
```java
try {
    // 代码
} catch (NullPointerException | ArithmeticException e) {
    System.out.println("捕获到异常：" + e);
}
```

### 4.3 finally 块的特点

**特点：**
1. 无论是否发生异常，finally 块都会执行
2. 通常用于释放资源（关闭文件、数据库连接等）
3. 即使 try 或 catch 中有 return，finally 也会执行

**示例：**
```java
public class FinallyDemo {
    public static int test() {
        try {
            int num = 10 / 0;
            return 1;  // 不会执行
        } catch (Exception e) {
            return 2;  // 会执行，但在 finally 之后
        } finally {
            System.out.println("finally 块执行");  // 先执行
            // 如果这里有 return，会覆盖 catch 中的 return
        }
    }
    
    public static void main(String[] args) {
        int result = test();
        // 输出：
        // finally 块执行
        // result = 2
        System.out.println("result = " + result);
    }
}
```

**注意：** 只有以下情况 finally 不会执行：
- JVM 退出：`System.exit(0);`
- 守护线程结束

### 4.4 throws（抛出异常）

**作用：** 将异常抛给调用者处理。

**语法：**
```java
访问修饰符 返回类型 方法名(参数) throws 异常类型1, 异常类型2 {
    // 方法体
}
```

**示例：**
```java
public class ThrowsDemo {
    // 方法声明抛出异常
    public static void method1() throws IOException {
        FileReader reader = new FileReader("test.txt");
        // 不在这里处理异常，而是抛给调用者
    }
    
    public static void method2() throws IOException {
        method1();  // 继续往上抛
    }
    
    public static void main(String[] args) {
        try {
            method2();  // 在这里处理异常
        } catch (IOException e) {
            System.out.println("文件读取失败：" + e.getMessage());
        }
    }
}
```

### 4.5 throw（手动抛出异常）

**作用：** 手动创建并抛出异常对象。

**语法：**
```java
throw new 异常类型("异常信息");
```

**示例：**
```java
public class ThrowDemo {
    public static void setAge(int age) {
        if (age < 0 || age > 150) {
            // 手动抛出异常
            throw new IllegalArgumentException("年龄必须在0-150之间");
        }
        System.out.println("年龄设置为：" + age);
    }
    
    public static void main(String[] args) {
        try {
            setAge(200);  // 会抛出异常
        } catch (IllegalArgumentException e) {
            System.out.println("参数错误：" + e.getMessage());
        }
    }
}
```

### 4.6 throw vs throws

| 特性 | throw | throws |
|------|-------|--------|
| **位置** | 方法体内 | 方法声明处 |
| **作用** | 手动抛出异常对象 | 声明方法可能抛出的异常 |
| **后面跟的** | 异常对象 | 异常类型 |
| **数量** | 一次只能抛一个 | 可以声明多个 |

**示例对比：**
```java
// throws：在方法声明处
public void method1() throws IOException, SQLException {
    // 方法体
}

// throw：在方法体内
public void method2() {
    throw new RuntimeException("出错了");
}
```

---

## 五、自定义异常

### 5.1 为什么需要自定义异常

**原因：** Java 提供的异常类不能满足所有需求，需要自定义异常来表示特定的业务错误。

### 5.2 自定义异常的步骤

**步骤：**
1. 创建一个类，继承 `Exception`（编译时异常）或 `RuntimeException`（运行时异常）
2. 提供构造器

**示例：**
```java
// 自定义运行时异常
class AgeException extends RuntimeException {
    public AgeException(String message) {
        super(message);
    }
}

// 自定义编译时异常
class BalanceException extends Exception {
    public BalanceException(String message) {
        super(message);
    }
}
```

### 5.3 使用自定义异常

**示例：完整的自定义异常应用**
```java
// 1. 自定义异常类
class AgeException extends RuntimeException {
    public AgeException(String message) {
        super(message);
    }
}

// 2. 使用自定义异常
class Person {
    private String name;
    private int age;
    
    public void setAge(int age) {
        if (age < 0 || age > 150) {
            // 抛出自定义异常
            throw new AgeException("年龄必须在0-150之间，当前输入：" + age);
        }
        this.age = age;
    }
    
    public int getAge() {
        return age;
    }
}

// 3. 测试
public class CustomExceptionDemo {
    public static void main(String[] args) {
        Person person = new Person();
        
        try {
            person.setAge(200);  // 会抛出 AgeException
        } catch (AgeException e) {
            System.out.println("捕获到自定义异常：" + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

---

## 六、面试常见问题

### Q1: Error 和 Exception 的区别？

**答案：**

| 特性 | Error | Exception |
|------|-------|-----------|
| 严重程度 | 严重错误 | 一般性问题 |
| 可处理性 | 不可处理 | 可以处理 |
| 是否捕获 | 不应该捕获 | 应该捕获 |
| 示例 | OutOfMemoryError | IOException |

---

### Q2: 运行时异常和编译时异常的区别？

**答案：**

| 特性 | 运行时异常 | 编译时异常 |
|------|------------|------------|
| 父类 | RuntimeException | Exception |
| 是否强制处理 | 不强制 | 必须处理 |
| 发生时机 | 运行时 | 编译时检查 |
| 示例 | NullPointerException | IOException |

---

### Q3: finally 块一定会执行吗？

**答案：**

几乎一定会执行，但以下情况不会执行：
1. JVM 退出（`System.exit(0);`）
2. 守护线程结束
3. 死循环或死锁

---

### Q4: try-catch-finally 的执行顺序？

**答案：**

1. 执行 try 块
2. 如果有异常，执行对应的 catch 块
3. 无论是否有异常，都执行 finally 块
4. 如果 try 或 catch 中有 return，finally 会在 return 之前执行

---

### Q5: throw 和 throws 的区别？

**答案：**

| 特性 | throw | throws |
|------|-------|--------|
| 位置 | 方法体内 | 方法声明处 |
| 作用 | 手动抛出异常对象 | 声明方法可能抛出的异常 |
| 后面跟 | 异常对象 | 异常类型 |

---

**上一章：** [枚举与注解](01-枚举与注解（优化版）.md)

**下一章：** [常用类](03-常用类.md) →
