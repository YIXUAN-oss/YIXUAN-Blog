---
title: Docker实战应用
---

# Docker实战应用

## 一、容器化部署 Spring Boot 应用

### 1.1 准备 Spring Boot 项目

**创建简单的 Spring Boot 项目：**

```java
// src/main/java/com/example/demo/DemoApplication.java
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class DemoApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
    
    @GetMapping("/")
    public String home() {
        return "Hello Docker!";
    }
    
    @GetMapping("/health")
    public String health() {
        return "OK";
    }
}
```

**pom.xml 配置：**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project>
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.0</version>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>demo</artifactId>
    <version>1.0.0</version>
    
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

**application.yml：**

```yaml
server:
  port: 8080

spring:
  application:
    name: demo-app

management:
  endpoints:
    web:
      exposure:
        include: health,info
  endpoint:
    health:
      show-details: always
```

### 1.2 方式一：简单 Dockerfile

**Dockerfile：**

```dockerfile
FROM openjdk:8-jdk-alpine

# 设置工作目录
WORKDIR /app

# 复制 jar 包
COPY target/demo-1.0.0.jar app.jar

# 暴露端口
EXPOSE 8080

# 启动应用
ENTRYPOINT ["java", "-jar", "app.jar"]
```

**构建和运行：**

```bash
# 1. 打包项目
mvn clean package

# 2. 构建镜像
docker build -t demo-app:v1 .

# 3. 运行容器
docker run -d -p 8080:8080 --name demo demo-app:v1

# 4. 测试
curl http://localhost:8080/
curl http://localhost:8080/health

# 5. 查看日志
docker logs -f demo
```

### 1.3 方式二：优化的 Dockerfile

**Dockerfile（多阶段构建）：**

```dockerfile
# 构建阶段
FROM maven:3.8-openjdk-8-slim AS builder
WORKDIR /build

# 复制 pom.xml 并下载依赖
COPY pom.xml .
RUN mvn dependency:go-offline -B

# 复制源码并构建
COPY src ./src
RUN mvn clean package -DskipTests

# 运行阶段
FROM openjdk:8-jre-alpine

# 安装 tzdata 设置时区
RUN apk add --no-cache tzdata && \
    cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && \
    echo "Asia/Shanghai" > /etc/timezone && \
    apk del tzdata

# 创建非 root 用户
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

# 设置工作目录
WORKDIR /app

# 从构建阶段复制 jar 文件
COPY --from=builder /build/target/*.jar app.jar

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --quiet --tries=1 --spider http://localhost:8080/actuator/health || exit 1

# 暴露端口
EXPOSE 8080

# JVM 参数优化
ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC"

# 启动应用
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar app.jar"]
```

**构建和运行：**

```bash
# 构建镜像（自动打包）
docker build -t demo-app:v2 .

# 运行容器
docker run -d \
  --name demo \
  -p 8080:8080 \
  -e JAVA_OPTS="-Xms512m -Xmx1g" \
  --restart unless-stopped \
  demo-app:v2

# 查看健康状态
docker ps
docker inspect demo | grep Health -A 10
```

### 1.4 方式三：分层优化

**Dockerfile（利用 Spring Boot 分层）：**

```dockerfile
FROM openjdk:8-jre-alpine AS builder
WORKDIR /app
ARG JAR_FILE=target/*.jar
COPY ${JAR_FILE} app.jar
RUN java -Djarmode=layertools -jar app.jar extract

FROM openjdk:8-jre-alpine
WORKDIR /app

# 复制各层（利用缓存）
COPY --from=builder /app/dependencies/ ./
COPY --from=builder /app/spring-boot-loader/ ./
COPY --from=builder /app/snapshot-dependencies/ ./
COPY --from=builder /app/application/ ./

EXPOSE 8080
ENTRYPOINT ["java", "org.springframework.boot.loader.JarLauncher"]
```

### 1.5 集成数据库和Redis

**application.yml：**

```yaml
server:
  port: 8080

spring:
  datasource:
    url: jdbc:mysql://${DB_HOST:localhost}:${DB_PORT:3306}/${DB_NAME:testdb}
    username: ${DB_USER:root}
    password: ${DB_PASSWORD:root}
    driver-class-name: com.mysql.cj.jdbc.Driver
  
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}
    
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
```

**运行容器（连接外部服务）：**

```bash
docker run -d \
  --name demo \
  -p 8080:8080 \
  -e DB_HOST=mysql-container \
  -e DB_PORT=3306 \
  -e DB_NAME=testdb \
  -e DB_USER=root \
  -e DB_PASSWORD=root123 \
  -e REDIS_HOST=redis-container \
  -e REDIS_PORT=6379 \
  --network my-network \
  demo-app:v2
```

---

## 二、容器化部署 MySQL 数据库

### 2.1 基本部署

```bash
# 运行 MySQL 容器
docker run -d \
  --name mysql \
  -p 3306:3306 \
  -e MYSQL_ROOT_PASSWORD=root123 \
  -e MYSQL_DATABASE=testdb \
  -e MYSQL_USER=appuser \
  -e MYSQL_PASSWORD=apppass \
  mysql:8.0

# 查看日志
docker logs mysql

# 进入容器
docker exec -it mysql bash

# 连接 MySQL
mysql -uroot -proot123
```

### 2.2 持久化数据

```bash
# 创建数据卷
docker volume create mysql-data

# 运行容器（使用数据卷）
docker run -d \
  --name mysql \
  -p 3306:3306 \
  -e MYSQL_ROOT_PASSWORD=root123 \
  -e MYSQL_DATABASE=testdb \
  -v mysql-data:/var/lib/mysql \
  mysql:8.0

# 查看数据卷位置
docker volume inspect mysql-data
```

### 2.3 自定义配置

**创建配置文件 my.cnf：**

```ini
[mysqld]
# 字符集配置
character-set-server=utf8mb4
collation-server=utf8mb4_unicode_ci

# 性能优化
max_connections=200
innodb_buffer_pool_size=256M
innodb_log_file_size=64M

# 慢查询日志
slow_query_log=1
slow_query_log_file=/var/log/mysql/slow.log
long_query_time=2

# 时区设置
default-time-zone='+08:00'

[client]
default-character-set=utf8mb4
```

**运行容器（使用自定义配置）：**

```bash
docker run -d \
  --name mysql \
  -p 3306:3306 \
  -e MYSQL_ROOT_PASSWORD=root123 \
  -e MYSQL_DATABASE=testdb \
  -v mysql-data:/var/lib/mysql \
  -v $(pwd)/my.cnf:/etc/mysql/conf.d/my.cnf \
  mysql:8.0
```

### 2.4 初始化数据库

**创建初始化脚本 init.sql：**

```sql
-- 创建数据库
CREATE DATABASE IF NOT EXISTS testdb DEFAULT CHARACTER SET utf8mb4;

USE testdb;

-- 创建表
CREATE TABLE IF NOT EXISTS users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入测试数据
INSERT INTO users (username, email) VALUES
('alice', 'alice@example.com'),
('bob', 'bob@example.com');

-- 创建用户并授权
CREATE USER IF NOT EXISTS 'appuser'@'%' IDENTIFIED BY 'apppass';
GRANT ALL PRIVILEGES ON testdb.* TO 'appuser'@'%';
FLUSH PRIVILEGES;
```

**运行容器（自动初始化）：**

```bash
docker run -d \
  --name mysql \
  -p 3306:3306 \
  -e MYSQL_ROOT_PASSWORD=root123 \
  -v mysql-data:/var/lib/mysql \
  -v $(pwd)/init.sql:/docker-entrypoint-initdb.d/init.sql \
  mysql:8.0
```

### 2.5 备份和恢复

**备份数据库：**

```bash
# 方式1：使用 mysqldump
docker exec mysql mysqldump -uroot -proot123 testdb > backup.sql

# 方式2：备份整个数据卷
docker run --rm \
  -v mysql-data:/data \
  -v $(pwd):/backup \
  ubuntu tar czf /backup/mysql-backup.tar.gz /data
```

**恢复数据库：**

```bash
# 方式1：导入 SQL 文件
docker exec -i mysql mysql -uroot -proot123 testdb < backup.sql

# 方式2：恢复数据卷
docker run --rm \
  -v mysql-data:/data \
  -v $(pwd):/backup \
  ubuntu tar xzf /backup/mysql-backup.tar.gz -C /
```

---

## 三、容器化部署 Redis 缓存

### 3.1 基本部署

```bash
# 运行 Redis 容器
docker run -d \
  --name redis \
  -p 6379:6379 \
  redis:6.2-alpine

# 测试连接
docker exec -it redis redis-cli
127.0.0.1:6379> ping
PONG
127.0.0.1:6379> set name "Docker"
OK
127.0.0.1:6379> get name
"Docker"
```

### 3.2 持久化配置

**创建 redis.conf：**

```conf
# 网络配置
bind 0.0.0.0
protected-mode yes
port 6379

# 密码配置
requirepass redis123

# 持久化配置 - AOF
appendonly yes
appendfilename "appendonly.aof"
appendfsync everysec

# 持久化配置 - RDB
save 900 1
save 300 10
save 60 10000
dbfilename dump.rdb
dir /data

# 内存配置
maxmemory 256mb
maxmemory-policy allkeys-lru

# 日志
loglevel notice
logfile /data/redis.log
```

**运行容器：**

```bash
# 创建数据卷
docker volume create redis-data

# 运行容器
docker run -d \
  --name redis \
  -p 6379:6379 \
  -v redis-data:/data \
  -v $(pwd)/redis.conf:/usr/local/etc/redis/redis.conf \
  redis:6.2-alpine redis-server /usr/local/etc/redis/redis.conf
```

### 3.3 带密码的 Redis

```bash
# 运行带密码的 Redis
docker run -d \
  --name redis \
  -p 6379:6379 \
  -e REDIS_PASSWORD=redis123 \
  redis:6.2-alpine redis-server --requirepass redis123

# 连接测试
docker exec -it redis redis-cli -a redis123
```

### 3.4 Redis 集群（简化版）

**创建 3 个 Redis 节点：**

```bash
# 创建网络
docker network create redis-cluster

# 启动 3 个 Redis 节点
for i in {1..3}; do
  docker run -d \
    --name redis-$i \
    --network redis-cluster \
    -p 637$i:6379 \
    redis:6.2-alpine redis-server --cluster-enabled yes
done

# 查看节点
docker ps | grep redis
```

---

## 四、容器化部署 Nginx 服务

### 4.1 基本部署

```bash
# 运行 Nginx 容器
docker run -d \
  --name nginx \
  -p 80:80 \
  nginx:alpine

# 访问测试
curl http://localhost
```

### 4.2 自定义网页

**创建网页文件 index.html：**

```html
<!DOCTYPE html>
<html>
<head>
    <title>Docker Nginx</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 50px;
        }
        h1 { color: #0066cc; }
    </style>
</head>
<body>
    <h1>Hello from Docker Nginx!</h1>
    <p>This is a custom HTML page served by Nginx in Docker.</p>
</body>
</html>
```

**运行容器：**

```bash
docker run -d \
  --name nginx \
  -p 80:80 \
  -v $(pwd)/html:/usr/share/nginx/html \
  nginx:alpine
```

### 4.3 自定义配置

**创建 nginx.conf：**

```nginx
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;

    sendfile on;
    keepalive_timeout 65;
    gzip on;

    # 上游服务器
    upstream backend {
        server app1:8080;
        server app2:8080;
    }

    server {
        listen 80;
        server_name localhost;

        location / {
            root /usr/share/nginx/html;
            index index.html;
        }

        location /api {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}
```

**运行容器：**

```bash
docker run -d \
  --name nginx \
  -p 80:80 \
  -v $(pwd)/nginx.conf:/etc/nginx/nginx.conf \
  -v $(pwd)/html:/usr/share/nginx/html \
  nginx:alpine
```

### 4.4 反向代理 Spring Boot

**创建 default.conf：**

```nginx
upstream springboot {
    server demo:8080;
}

server {
    listen 80;
    server_name localhost;

    # 静态资源
    location / {
        root /usr/share/nginx/html;
        index index.html;
        try_files $uri $uri/ /index.html;
    }

    # API 代理
    location /api/ {
        proxy_pass http://springboot/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # WebSocket 支持
    location /ws/ {
        proxy_pass http://springboot/ws/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
```

**运行容器：**

```bash
# 创建网络
docker network create app-network

# 运行 Spring Boot
docker run -d --name demo --network app-network demo-app:v2

# 运行 Nginx
docker run -d \
  --name nginx \
  --network app-network \
  -p 80:80 \
  -v $(pwd)/default.conf:/etc/nginx/conf.d/default.conf \
  nginx:alpine
```

---

## 五、多阶段构建优化镜像

### 5.1 Java 应用优化

**传统方式（单阶段）：**

```dockerfile
FROM maven:3.8-openjdk-8
WORKDIR /app
COPY . .
RUN mvn package
CMD ["java", "-jar", "target/app.jar"]

# 镜像大小：~800MB
```

**优化方式（多阶段）：**

```dockerfile
# 阶段1：构建
FROM maven:3.8-openjdk-8-slim AS builder
WORKDIR /build
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn package -DskipTests

# 阶段2：运行
FROM openjdk:8-jre-alpine
WORKDIR /app
COPY --from=builder /build/target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]

# 镜像大小：~120MB（减少85%）
```

### 5.2 Node.js 应用优化

**优化的 Dockerfile：**

```dockerfile
# 阶段1：依赖安装
FROM node:16-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

# 阶段2：构建
FROM node:16-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# 阶段3：运行
FROM node:16-alpine
WORKDIR /app
ENV NODE_ENV=production
COPY --from=deps /app/node_modules ./node_modules
COPY --from=builder /app/dist ./dist
COPY package.json ./
EXPOSE 3000
CMD ["node", "dist/main.js"]
```

### 5.3 Go 应用优化

**极致优化的 Dockerfile：**

```dockerfile
# 阶段1：构建
FROM golang:1.19-alpine AS builder
WORKDIR /build
COPY go.* ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

# 阶段2：运行（使用 scratch 最小镜像）
FROM scratch
COPY --from=builder /build/app /app
EXPOSE 8080
ENTRYPOINT ["/app"]

# 镜像大小：~10MB
```

---

## 六、常见问题与解决方案

### 6.1 容器无法启动

**问题：容器启动后立即退出**

```bash
# 查看容器状态
docker ps -a

# 查看日志
docker logs container-name

# 查看详细信息
docker inspect container-name
```

**常见原因：**
1. 应用启动失败
2. 端口已被占用
3. 配置文件错误
4. 权限问题

### 6.2 网络连接问题

**问题：容器间无法通信**

```bash
# 检查网络
docker network ls
docker network inspect bridge

# 确保容器在同一网络
docker run --network my-network nginx
docker run --network my-network mysql

# 测试连通性
docker exec container1 ping container2
```

### 6.3 数据丢失问题

**问题：容器删除后数据丢失**

**解决方案：使用数据卷**

```bash
# 创建数据卷
docker volume create app-data

# 使用数据卷
docker run -v app-data:/data myapp

# 备份数据卷
docker run --rm -v app-data:/data -v $(pwd):/backup ubuntu tar czf /backup/data.tar.gz /data
```

### 6.4 性能问题

**问题：容器性能差**

**解决方案：**

```bash
# 1. 限制资源使用
docker run --memory=512m --cpus=1.0 myapp

# 2. 查看资源使用
docker stats

# 3. 优化镜像大小
# - 使用 alpine 基础镜像
# - 多阶段构建
# - 清理缓存和临时文件

# 4. 使用宿主机网络（性能最佳）
docker run --network host myapp
```

### 6.5 镜像过大

**问题：镜像体积过大**

**解决方案：**

```dockerfile
# 1. 使用 alpine 镜像
FROM openjdk:8-jre-alpine

# 2. 合并 RUN 命令
RUN apt-get update && \
    apt-get install -y curl && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# 3. 多阶段构建
FROM maven:3.8 AS builder
RUN mvn package

FROM openjdk:8-jre-alpine
COPY --from=builder /app/target/*.jar app.jar

# 4. 使用 .dockerignore
echo "node_modules" >> .dockerignore
echo ".git" >> .dockerignore
```

---

## 七、完整示例：Spring Boot + MySQL + Redis + Nginx

### 7.1 项目结构

```
project/
├── app/
│   ├── src/
│   ├── pom.xml
│   └── Dockerfile
├── nginx/
│   ├── nginx.conf
│   └── Dockerfile
├── mysql/
│   └── init.sql
└── docker-compose.yml
```

### 7.2 Spring Boot Dockerfile

```dockerfile
FROM maven:3.8-openjdk-8-slim AS builder
WORKDIR /build
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn package -DskipTests

FROM openjdk:8-jre-alpine
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring
WORKDIR /app
COPY --from=builder /build/target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

### 7.3 运行命令

```bash
# 创建网络
docker network create app-net

# 运行 MySQL
docker run -d \
  --name mysql \
  --network app-net \
  -e MYSQL_ROOT_PASSWORD=root123 \
  -e MYSQL_DATABASE=testdb \
  -v mysql-data:/var/lib/mysql \
  mysql:8.0

# 运行 Redis
docker run -d \
  --name redis \
  --network app-net \
  -v redis-data:/data \
  redis:6.2-alpine

# 运行 Spring Boot
docker run -d \
  --name app \
  --network app-net \
  -e DB_HOST=mysql \
  -e REDIS_HOST=redis \
  demo-app:v2

# 运行 Nginx
docker run -d \
  --name nginx \
  --network app-net \
  -p 80:80 \
  -v $(pwd)/nginx.conf:/etc/nginx/nginx.conf \
  nginx:alpine
```

---

## 八、小结

通过本章学习，你应该掌握：

✅ **Spring Boot 容器化**
- 基本 Dockerfile
- 优化技巧
- 多阶段构建

✅ **MySQL 容器化**
- 数据持久化
- 自定义配置
- 备份恢复

✅ **Redis 容器化**
- 持久化配置
- 密码保护
- 性能优化

✅ **Nginx 容器化**
- 反向代理
- 负载均衡
- 静态资源服务

✅ **问题排查**
- 日志查看
- 网络调试
- 性能优化

**下一章预告：**
在下一章中，我们将学习 Docker Compose 多容器编排，以及微服务环境的搭建和 CI/CD 集成。

---

**继续学习** → [第四章：Docker 进阶技巧](4.Docker进阶技巧.md)
