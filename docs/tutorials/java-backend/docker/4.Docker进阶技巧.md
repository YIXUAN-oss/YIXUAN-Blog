---
title: Docker进阶技巧
---

# Docker进阶技巧

## 一、Docker Compose 多容器编排

### 1.1 Docker Compose 简介

Docker Compose 是用于定义和运行多容器 Docker 应用的工具。通过 YAML 文件配置应用的服务，然后使用一条命令创建并启动所有服务。

**核心优势：**
```
✅ 简化多容器管理
✅ 声明式配置
✅ 一键启动/停止
✅ 服务编排
✅ 环境隔离
```

### 1.2 安装 Docker Compose

**Linux：**
```bash
# 下载最新版本
sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose

# 添加执行权限
sudo chmod +x /usr/local/bin/docker-compose

# 验证安装
docker-compose --version
```

**Windows/macOS：**
```
Docker Desktop 已内置 Docker Compose
直接使用即可
```

### 1.3 docker-compose.yml 基础

**基本结构：**

```yaml
version: '3.8'

services:
  # 服务1
  web:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./html:/usr/share/nginx/html
    networks:
      - app-network

  # 服务2
  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: root123
    volumes:
      - db-data:/var/lib/mysql
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  db-data:
```

### 1.4 完整的 Spring Boot 项目

**项目结构：**
```
my-project/
├── app/
│   ├── src/
│   ├── pom.xml
│   └── Dockerfile
├── nginx/
│   ├── nginx.conf
│   └── html/
├── mysql/
│   └── init.sql
└── docker-compose.yml
```

**docker-compose.yml：**

```yaml
version: '3.8'

services:
  # MySQL 数据库
  mysql:
    image: mysql:8.0
    container_name: mysql
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: root123
      MYSQL_DATABASE: testdb
      MYSQL_USER: appuser
      MYSQL_PASSWORD: apppass
      TZ: Asia/Shanghai
    ports:
      - "3306:3306"
    volumes:
      - mysql-data:/var/lib/mysql
      - ./mysql/init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis 缓存
  redis:
    image: redis:6.2-alpine
    container_name: redis
    restart: unless-stopped
    command: redis-server --requirepass redis123
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5

  # Spring Boot 应用
  app:
    build:
      context: ./app
      dockerfile: Dockerfile
    container_name: spring-app
    restart: unless-stopped
    depends_on:
      mysql:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      SPRING_PROFILES_ACTIVE: prod
      DB_HOST: mysql
      DB_PORT: 3306
      DB_NAME: testdb
      DB_USER: appuser
      DB_PASSWORD: apppass
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: redis123
    ports:
      - "8080:8080"
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Nginx 反向代理
  nginx:
    image: nginx:alpine
    container_name: nginx
    restart: unless-stopped
    depends_on:
      - app
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/html:/usr/share/nginx/html
      - nginx-logs:/var/log/nginx
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  mysql-data:
  redis-data:
  nginx-logs:
```

### 1.5 Docker Compose 常用命令

```bash
# 启动所有服务（后台运行）
docker-compose up -d

# 查看服务状态
docker-compose ps

# 查看日志
docker-compose logs
docker-compose logs -f app  # 实时查看 app 日志

# 停止所有服务
docker-compose stop

# 停止并删除容器、网络
docker-compose down

# 停止并删除容器、网络、卷
docker-compose down -v

# 重启服务
docker-compose restart app

# 构建或重建服务
docker-compose build
docker-compose build --no-cache  # 不使用缓存

# 扩展服务（运行多个实例）
docker-compose up -d --scale app=3

# 进入容器
docker-compose exec app bash

# 查看配置
docker-compose config
```

### 1.6 环境变量配置

**.env 文件：**

```env
# 数据库配置
MYSQL_ROOT_PASSWORD=root123
MYSQL_DATABASE=testdb
MYSQL_USER=appuser
MYSQL_PASSWORD=apppass

# Redis 配置
REDIS_PASSWORD=redis123

# 应用配置
APP_PORT=8080
SPRING_PROFILES_ACTIVE=prod
```

**docker-compose.yml 使用环境变量：**

```yaml
version: '3.8'

services:
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    ports:
      - "${MYSQL_PORT:-3306}:3306"  # 默认值 3306

  app:
    build: ./app
    environment:
      SPRING_PROFILES_ACTIVE: ${SPRING_PROFILES_ACTIVE}
      DB_HOST: mysql
      DB_PASSWORD: ${MYSQL_PASSWORD}
    ports:
      - "${APP_PORT}:8080"
```

---

## 二、构建完整的微服务环境

### 2.1 微服务架构示例

**项目结构：**
```
microservices/
├── gateway/          # API 网关
├── user-service/     # 用户服务
├── order-service/    # 订单服务
├── product-service/  # 商品服务
├── eureka/          # 服务注册中心
├── config/          # 配置中心
└── docker-compose.yml
```

### 2.2 完整的 docker-compose.yml

```yaml
version: '3.8'

services:
  # Eureka 服务注册中心
  eureka:
    build: ./eureka
    container_name: eureka
    ports:
      - "8761:8761"
    environment:
      SPRING_PROFILES_ACTIVE: docker
    networks:
      - microservices

  # MySQL 数据库
  mysql:
    image: mysql:8.0
    container_name: mysql
    environment:
      MYSQL_ROOT_PASSWORD: root123
      MYSQL_DATABASE: microservices
    ports:
      - "3306:3306"
    volumes:
      - mysql-data:/var/lib/mysql
    networks:
      - microservices

  # Redis 缓存
  redis:
    image: redis:6.2-alpine
    container_name: redis
    command: redis-server --requirepass redis123
    ports:
      - "6379:6379"
    networks:
      - microservices

  # RabbitMQ 消息队列
  rabbitmq:
    image: rabbitmq:3.11-management-alpine
    container_name: rabbitmq
    environment:
      RABBITMQ_DEFAULT_USER: admin
      RABBITMQ_DEFAULT_PASS: admin123
    ports:
      - "5672:5672"
      - "15672:15672"  # 管理界面
    networks:
      - microservices

  # 用户服务
  user-service:
    build: ./user-service
    container_name: user-service
    depends_on:
      - eureka
      - mysql
      - redis
    environment:
      SPRING_PROFILES_ACTIVE: docker
      EUREKA_SERVER: http://eureka:8761/eureka
      DB_HOST: mysql
      REDIS_HOST: redis
    ports:
      - "8081:8080"
    networks:
      - microservices

  # 订单服务
  order-service:
    build: ./order-service
    container_name: order-service
    depends_on:
      - eureka
      - mysql
      - rabbitmq
    environment:
      SPRING_PROFILES_ACTIVE: docker
      EUREKA_SERVER: http://eureka:8761/eureka
      DB_HOST: mysql
      RABBITMQ_HOST: rabbitmq
    ports:
      - "8082:8080"
    networks:
      - microservices

  # 商品服务
  product-service:
    build: ./product-service
    container_name: product-service
    depends_on:
      - eureka
      - mysql
    environment:
      SPRING_PROFILES_ACTIVE: docker
      EUREKA_SERVER: http://eureka:8761/eureka
      DB_HOST: mysql
    ports:
      - "8083:8080"
    networks:
      - microservices

  # API 网关
  gateway:
    build: ./gateway
    container_name: gateway
    depends_on:
      - eureka
      - user-service
      - order-service
      - product-service
    environment:
      SPRING_PROFILES_ACTIVE: docker
      EUREKA_SERVER: http://eureka:8761/eureka
    ports:
      - "8080:8080"
    networks:
      - microservices

networks:
  microservices:
    driver: bridge

volumes:
  mysql-data:
```

### 2.3 服务配置文件示例

**application-docker.yml（Spring Boot 服务）：**

```yaml
spring:
  application:
    name: user-service
  
  datasource:
    url: jdbc:mysql://${DB_HOST:mysql}:3306/microservices?useSSL=false
    username: root
    password: root123
    driver-class-name: com.mysql.cj.jdbc.Driver
  
  redis:
    host: ${REDIS_HOST:redis}
    port: 6379
    password: redis123
  
  rabbitmq:
    host: ${RABBITMQ_HOST:rabbitmq}
    port: 5672
    username: admin
    password: admin123

eureka:
  client:
    service-url:
      defaultZone: ${EUREKA_SERVER:http://eureka:8761/eureka}
  instance:
    prefer-ip-address: true

server:
  port: 8080
```

---

## 三、Docker 网络高级配置

### 3.1 自定义网络

**创建自定义网络：**

```bash
# 创建 bridge 网络
docker network create \
  --driver bridge \
  --subnet 172.20.0.0/16 \
  --gateway 172.20.0.1 \
  my-network

# 创建 overlay 网络（Swarm 模式）
docker network create \
  --driver overlay \
  --attachable \
  my-overlay-network
```

**在 docker-compose.yml 中配置：**

```yaml
version: '3.8'

services:
  web:
    image: nginx
    networks:
      frontend:
        ipv4_address: 172.20.0.10
      backend:

  app:
    image: myapp
    networks:
      - backend
      - database

  db:
    image: mysql
    networks:
      - database

networks:
  frontend:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
          gateway: 172.20.0.1
  
  backend:
    driver: bridge
  
  database:
    driver: bridge
    internal: true  # 内部网络，不能访问外网
```

### 3.2 容器间通信

**通过容器名通信：**

```yaml
version: '3.8'

services:
  web:
    image: nginx
    depends_on:
      - api
    # nginx.conf 中可以使用 http://api:8080

  api:
    image: myapi
    depends_on:
      - db
    # 可以通过 db:3306 连接数据库

  db:
    image: mysql
```

**通过别名通信：**

```yaml
services:
  web:
    image: nginx
    networks:
      app-net:
        aliases:
          - web-server
          - frontend

  api:
    image: myapi
    networks:
      app-net:
        aliases:
          - api-server
          - backend

networks:
  app-net:
```

### 3.3 网络安全

**隔离敏感服务：**

```yaml
version: '3.8'

services:
  # 前端服务（公开）
  nginx:
    image: nginx
    ports:
      - "80:80"
    networks:
      - frontend

  # 应用服务（半公开）
  app:
    image: myapp
    networks:
      - frontend
      - backend

  # 数据库（隔离）
  db:
    image: mysql
    networks:
      - backend

  # 管理服务（完全隔离）
  admin:
    image: admin-panel
    networks:
      - admin

networks:
  frontend:
    driver: bridge
  
  backend:
    driver: bridge
    internal: true  # 不能访问外网
  
  admin:
    driver: bridge
    internal: true
```

---

## 四、容器资源限制与监控

### 4.1 资源限制

**CPU 限制：**

```yaml
version: '3.8'

services:
  app:
    image: myapp
    deploy:
      resources:
        limits:
          cpus: '1.5'      # 最多使用 1.5 个 CPU
          memory: 512M     # 最多使用 512MB 内存
        reservations:
          cpus: '0.5'      # 保留 0.5 个 CPU
          memory: 256M     # 保留 256MB 内存
```

**命令行方式：**

```bash
docker run -d \
  --name app \
  --cpus=1.5 \
  --memory=512m \
  --memory-reservation=256m \
  --memory-swap=1g \
  myapp
```

### 4.2 监控工具

**1. docker stats 命令：**

```bash
# 实时监控所有容器
docker stats

# 监控指定容器
docker stats app mysql redis

# 不持续刷新
docker stats --no-stream
```

**2. cAdvisor（容器监控）：**

```yaml
version: '3.8'

services:
  cadvisor:
    image: google/cadvisor:latest
    container_name: cadvisor
    ports:
      - "8080:8080"
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:ro
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
    privileged: true
```

**3. Prometheus + Grafana：**

```yaml
version: '3.8'

services:
  # Prometheus 监控
  prometheus:
    image: prom/prometheus
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus-data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
    networks:
      - monitoring

  # Grafana 可视化
  grafana:
    image: grafana/grafana
    container_name: grafana
    ports:
      - "3000:3000"
    environment:
      GF_SECURITY_ADMIN_PASSWORD: admin123
    volumes:
      - grafana-data:/var/lib/grafana
    depends_on:
      - prometheus
    networks:
      - monitoring

  # Node Exporter（节点监控）
  node-exporter:
    image: prom/node-exporter
    container_name: node-exporter
    ports:
      - "9100:9100"
    networks:
      - monitoring

  # cAdvisor（容器监控）
  cadvisor:
    image: google/cadvisor:latest
    container_name: cadvisor
    ports:
      - "8080:8080"
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:ro
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
    networks:
      - monitoring

networks:
  monitoring:

volumes:
  prometheus-data:
  grafana-data:
```

**prometheus.yml 配置：**

```yaml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  - job_name: 'node-exporter'
    static_configs:
      - targets: ['node-exporter:9100']

  - job_name: 'cadvisor'
    static_configs:
      - targets: ['cadvisor:8080']
```

---

## 五、Docker 镜像优化技巧

### 5.1 使用 .dockerignore

```
# .dockerignore
.git
.gitignore
.idea
.vscode
*.md
README.md
Dockerfile
docker-compose.yml
.env
.DS_Store

# Java
target/
*.jar
*.war
*.class

# Node.js
node_modules/
npm-debug.log

# Python
__pycache__/
*.py[cod]
.pytest_cache/
```

### 5.2 优化层缓存

**不好的做法：**

```dockerfile
FROM node:16
WORKDIR /app
COPY . .                    # 任何文件变化都会重新安装依赖
RUN npm install
RUN npm run build
```

**好的做法：**

```dockerfile
FROM node:16
WORKDIR /app

# 先复制依赖文件（变化少）
COPY package*.json ./
RUN npm ci --only=production

# 再复制源码（变化频繁）
COPY . .
RUN npm run build
```

### 5.3 清理临时文件

```dockerfile
# ❌ 不好 - 临时文件保留在镜像中
RUN apt-get update
RUN apt-get install -y curl
RUN curl -o /tmp/file.tar.gz http://example.com/file.tar.gz
RUN tar -xzf /tmp/file.tar.gz

# ✅ 好 - 单层清理
RUN apt-get update && \
    apt-get install -y curl && \
    curl -o /tmp/file.tar.gz http://example.com/file.tar.gz && \
    tar -xzf /tmp/file.tar.gz && \
    rm /tmp/file.tar.gz && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

### 5.4 使用构建参数

```dockerfile
ARG NODE_VERSION=16
FROM node:${NODE_VERSION}-alpine

ARG BUILD_DATE
ARG VERSION

LABEL build-date=${BUILD_DATE}
LABEL version=${VERSION}

# 构建时传参
# docker build --build-arg VERSION=1.0.0 .
```

---

## 六、CI/CD 集成

### 6.1 GitLab CI/CD

**.gitlab-ci.yml：**

```yaml
stages:
  - build
  - test
  - deploy

variables:
  DOCKER_IMAGE: registry.example.com/myapp
  DOCKER_TAG: $CI_COMMIT_REF_NAME

before_script:
  - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY

build:
  stage: build
  script:
    - docker build -t $DOCKER_IMAGE:$DOCKER_TAG .
    - docker push $DOCKER_IMAGE:$DOCKER_TAG
  only:
    - main
    - develop

test:
  stage: test
  script:
    - docker run --rm $DOCKER_IMAGE:$DOCKER_TAG npm test
  only:
    - main
    - develop

deploy_production:
  stage: deploy
  script:
    - docker-compose -f docker-compose.prod.yml pull
    - docker-compose -f docker-compose.prod.yml up -d
  only:
    - main
  when: manual
```

### 6.2 Jenkins Pipeline

**Jenkinsfile：**

```groovy
pipeline {
    agent any
    
    environment {
        DOCKER_IMAGE = 'myapp'
        DOCKER_TAG = "${env.BUILD_NUMBER}"
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Build') {
            steps {
                script {
                    docker.build("${DOCKER_IMAGE}:${DOCKER_TAG}")
                }
            }
        }
        
        stage('Test') {
            steps {
                script {
                    docker.image("${DOCKER_IMAGE}:${DOCKER_TAG}").inside {
                        sh 'npm test'
                    }
                }
            }
        }
        
        stage('Push') {
            steps {
                script {
                    docker.withRegistry('https://registry.example.com', 'docker-credentials') {
                        docker.image("${DOCKER_IMAGE}:${DOCKER_TAG}").push()
                        docker.image("${DOCKER_IMAGE}:${DOCKER_TAG}").push('latest')
                    }
                }
            }
        }
        
        stage('Deploy') {
            steps {
                sh '''
                    docker-compose pull
                    docker-compose up -d
                '''
            }
        }
    }
    
    post {
        always {
            sh 'docker system prune -f'
        }
    }
}
```

### 6.3 GitHub Actions

**.github/workflows/docker.yml：**

```yaml
name: Docker Build and Deploy

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Build and push
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: |
          myapp:latest
          myapp:${{ github.sha }}
        cache-from: type=registry,ref=myapp:buildcache
        cache-to: type=registry,ref=myapp:buildcache,mode=max
    
    - name: Deploy to server
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        script: |
          cd /opt/myapp
          docker-compose pull
          docker-compose up -d
          docker system prune -f
```

---

## 七、小结

通过本章学习，你应该掌握：

✅ **Docker Compose**
- 多容器编排
- 服务依赖管理
- 环境变量配置

✅ **微服务环境**
- 完整微服务架构
- 服务间通信
- 服务注册与发现

✅ **网络配置**
- 自定义网络
- 网络隔离
- 安全配置

✅ **监控与限制**
- 资源限制
- 容器监控
- Prometheus + Grafana

✅ **镜像优化**
- 缓存利用
- 体积优化
- 构建优化

✅ **CI/CD 集成**
- GitLab CI/CD
- Jenkins
- GitHub Actions

**下一章预告：**
在下一章中，我们将学习 Docker 相关的面试题，帮助你应对技术面试。

---

**继续学习** → [第五章：Docker 面试题集](5.Docker面试题集.md)
