---
title: Docker面试题集
---

# Docker面试题集

## 一、Docker基础概念面试题

### 1.1 什么是Docker？它解决了什么问题？

**答案：**

Docker 是一个开源的容器化平台，用于开发、部署和运行应用程序。

**解决的问题：**
1. **环境一致性** - "在我机器上能跑"的问题
2. **资源隔离** - 应用之间互不影响
3. **快速部署** - 秒级启动，提高效率
4. **版本管理** - 镜像版本化，方便回滚
5. **资源利用** - 相比虚拟机更轻量，资源占用少

### 1.2 Docker 与虚拟机有什么区别？

**答案：**

| 特性 | Docker 容器 | 虚拟机 |
|------|-----------|--------|
| 启动速度 | 秒级 | 分钟级 |
| 硬盘使用 | MB 级 | GB 级 |
| 性能 | 接近原生 | 弱于原生 |
| 系统支持量 | 单机可支持上千个 | 一般几十个 |
| 隔离性 | 进程级别 | 系统级别 |

**核心区别：**
- 虚拟机需要完整的 Guest OS，Docker 共享主机内核
- Docker 是进程级虚拟化，虚拟机是系统级虚拟化

### 1.3 Docker 的核心组件有哪些？

**答案：**

1. **Docker Client（客户端）**
   - 用户与 Docker 交互的主要方式
   - 发送命令到 Docker Daemon

2. **Docker Daemon（守护进程）**
   - 监听 Docker API 请求
   - 管理镜像、容器、网络、卷

3. **Docker Image（镜像）**
   - 只读模板，用于创建容器
   - 采用分层存储结构

4. **Docker Container（容器）**
   - 镜像的运行实例
   - 可创建、启动、停止、删除

5. **Docker Registry（仓库）**
   - 存储和分发镜像
   - 如 Docker Hub、私有仓库

### 1.4 什么是镜像分层？为什么要分层？

**答案：**

Docker 镜像采用联合文件系统（Union FS），每个镜像由多个只读层组成。

**分层结构示例：**
```
应用层      ← COPY app.jar
依赖层      ← RUN apt-get install
基础层      ← FROM ubuntu
```

**分层的优势：**
1. **节省存储空间** - 多个镜像共享相同的基础层
2. **加快传输速度** - 只传输变化的层
3. **提高构建效率** - 利用缓存机制
4. **便于版本管理** - 每层都有唯一 ID

### 1.5 Dockerfile 中 COPY 和 ADD 的区别？

**答案：**

| 特性 | COPY | ADD |
|------|------|-----|
| 基本复制 | ✅ | ✅ |
| 支持 URL | ❌ | ✅ |
| 自动解压 tar | ❌ | ✅ |
| 透明性 | 高 | 低 |
| 推荐使用 | ✅ | 特定场景 |

**建议：**
- 一般情况使用 COPY，语义更清晰
- 只在需要自动解压时使用 ADD

### 1.6 CMD 和 ENTRYPOINT 的区别？

**答案：**

**CMD：**
- 提供容器默认执行的命令
- 可被 `docker run` 命令行参数覆盖

**ENTRYPOINT：**
- 配置容器启动时运行的命令
- 不容易被覆盖（需要 --entrypoint 参数）

**组合使用：**
```dockerfile
ENTRYPOINT ["java", "-jar"]
CMD ["app.jar"]

# 运行: docker run myapp
# 执行: java -jar app.jar

# 运行: docker run myapp another.jar
# 执行: java -jar another.jar
```

---

## 二、镜像与容器相关面试题

### 2.1 如何优化 Docker 镜像大小？

**答案：**

**1. 使用轻量级基础镜像**
```dockerfile
FROM alpine:latest  # 5MB
# 而不是 FROM ubuntu:latest  # 80MB
```

**2. 多阶段构建**
```dockerfile
FROM maven:3.8 AS builder
RUN mvn package

FROM openjdk:8-jre-alpine  # 只包含运行时
COPY --from=builder /app/target/*.jar app.jar
```

**3. 合并 RUN 指令**
```dockerfile
RUN apt-get update && \
    apt-get install -y curl && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

**4. 使用 .dockerignore**
```
.git
node_modules/
*.md
```

**5. 清理缓存和临时文件**

### 2.2 Docker 容器的生命周期是怎样的？

**答案：**

```
created → running → paused → stopped → deleted
   ↑         ↓                    ↓
   └─────────┴────────────────────┘
```

**状态说明：**
1. **Created** - 容器已创建但未启动
2. **Running** - 容器正在运行
3. **Paused** - 容器被暂停
4. **Stopped** - 容器已停止
5. **Deleted** - 容器被删除

**常用命令：**
```bash
docker create   # 创建
docker start    # 启动
docker pause    # 暂停
docker unpause  # 恢复
docker stop     # 停止
docker rm       # 删除
```

### 2.3 如何进入运行中的容器？

**答案：**

**方法一：docker exec（推荐）**
```bash
docker exec -it container_name bash
```

**方法二：docker attach**
```bash
docker attach container_name
```

**区别：**
- `exec` 创建新进程，退出不影响容器
- `attach` 连接到主进程，退出会停止容器

### 2.4 容器数据如何持久化？

**答案：**

**1. Volume（数据卷）- 推荐**
```bash
docker volume create my-volume
docker run -v my-volume:/data myapp
```

**2. Bind Mount（绑定挂载）**
```bash
docker run -v /host/path:/container/path myapp
```

**3. tmpfs Mount（内存挂载）**
```bash
docker run --tmpfs /tmp myapp
```

**对比：**
- Volume：Docker 管理，生产环境推荐
- Bind Mount：依赖主机路径，开发环境使用
- tmpfs：数据在内存中，容器停止即丢失

---

## 三、网络与存储面试题

### 3.1 Docker 有哪些网络模式？

**答案：**

**1. bridge（桥接模式）- 默认**
- 容器连接到虚拟网桥
- 可通过端口映射访问

**2. host（主机模式）**
- 容器使用主机网络栈
- 性能最佳，但失去隔离性

**3. none（无网络）**
- 容器没有网络接口
- 完全隔离

**4. container**
- 与其他容器共享网络
- 适合紧密通信的容器

**5. 自定义网络**
- 用户定义的网络
- 支持容器名解析

**示例：**
```bash
docker network create my-network
docker run --network my-network nginx
```

### 3.2 容器间如何通信？

**答案：**

**1. 同一网络中通过容器名**
```bash
docker network create app-net
docker run --name db --network app-net mysql
docker run --name app --network app-net myapp

# app 中可以通过 db:3306 连接 MySQL
```

**2. 通过 link（已废弃）**
```bash
docker run --link db:database myapp
```

**3. 通过主机端口**
```bash
docker run -p 3306:3306 mysql
# 其他容器通过 host.docker.internal:3306 访问
```

### 3.3 如何限制容器资源使用？

**答案：**

**CPU 限制：**
```bash
docker run --cpus=1.5 myapp          # 限制 CPU
docker run --cpu-shares=512 myapp    # CPU 权重
```

**内存限制：**
```bash
docker run --memory=512m myapp       # 限制内存
docker run --memory-swap=1g myapp    # 限制 swap
```

**磁盘 IO 限制：**
```bash
docker run --device-read-bps /dev/sda:1mb myapp
docker run --device-write-bps /dev/sda:1mb myapp
```

**在 docker-compose.yml 中：**
```yaml
services:
  app:
    image: myapp
    deploy:
      resources:
        limits:
          cpus: '1.5'
          memory: 512M
```

---

## 四、实战场景面试题

### 4.1 如何排查容器无法启动的问题？

**答案：**

**步骤 1：查看容器状态**
```bash
docker ps -a
```

**步骤 2：查看日志**
```bash
docker logs container_name
docker logs --tail 100 container_name
```

**步骤 3：查看详细信息**
```bash
docker inspect container_name
```

**步骤 4：尝试手动运行**
```bash
docker run -it --entrypoint sh myapp
```

**常见问题：**
1. 端口已被占用
2. 配置文件错误
3. 依赖服务未就绪
4. 权限问题
5. 资源不足

### 4.2 如何备份和恢复 Docker 容器？

**答案：**

**备份容器：**
```bash
# 1. 提交容器为镜像
docker commit container_name backup_image:v1

# 2. 导出镜像
docker save -o backup.tar backup_image:v1

# 3. 备份数据卷
docker run --rm -v volume_name:/data -v $(pwd):/backup ubuntu tar czf /backup/data.tar.gz /data
```

**恢复容器：**
```bash
# 1. 导入镜像
docker load -i backup.tar

# 2. 恢复数据卷
docker run --rm -v volume_name:/data -v $(pwd):/backup ubuntu tar xzf /backup/data.tar.gz -C /

# 3. 运行容器
docker run -d -v volume_name:/data backup_image:v1
```

### 4.3 Spring Boot 应用容器化的最佳实践？

**答案：**

**Dockerfile 示例：**
```dockerfile
# 多阶段构建
FROM maven:3.8-openjdk-8-slim AS builder
WORKDIR /build
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn package -DskipTests

# 运行阶段
FROM openjdk:8-jre-alpine
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring
WORKDIR /app
COPY --from=builder /build/target/*.jar app.jar

HEALTHCHECK --interval=30s --timeout=3s \
  CMD wget -q --spider http://localhost:8080/actuator/health || exit 1

EXPOSE 8080
ENTRYPOINT ["java", "-Xmx512m", "-jar", "app.jar"]
```

**最佳实践：**
1. 使用多阶段构建减小镜像
2. 不以 root 用户运行
3. 添加健康检查
4. 设置 JVM 参数
5. 使用 Alpine 基础镜像

### 4.4 如何实现 Docker 的零停机部署？

**答案：**

**方式一：使用 Docker Compose 滚动更新**
```bash
# 1. 更新镜像
docker-compose pull

# 2. 滚动更新（逐个重启）
docker-compose up -d --no-deps --scale app=2 --no-recreate app
docker-compose up -d --no-deps --scale app=1 --force-recreate app
```

**方式二：蓝绿部署**
```bash
# 1. 启动新版本（绿）
docker run -d --name app-green myapp:v2

# 2. 测试新版本
curl http://app-green:8080/health

# 3. 切换流量（更新 Nginx 配置）
# 4. 停止旧版本（蓝）
docker stop app-blue
```

**方式三：使用 Kubernetes**
```yaml
kind: Deployment
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
```

---

## 五、高频面试题解析

### 5.1 Docker 镜像是如何构建的？

**答案：**

**构建过程：**
1. 从 Dockerfile 读取指令
2. 从基础镜像开始
3. 每条指令创建一个新层
4. 最终生成镜像 ID

**示例：**
```bash
docker build -t myapp:v1 .

# 构建过程
Step 1/5 : FROM openjdk:8
Step 2/5 : WORKDIR /app
Step 3/5 : COPY app.jar .
Step 4/5 : EXPOSE 8080
Step 5/5 : CMD ["java", "-jar", "app.jar"]
Successfully built abc123def456
```

**优化技巧：**
- 合理安排指令顺序（变化少的在前）
- 利用构建缓存
- 使用 .dockerignore

### 5.2 什么是 Docker Compose？它解决了什么问题？

**答案：**

Docker Compose 是用于定义和运行多容器 Docker 应用的工具。

**解决的问题：**
1. **简化多容器管理** - 一个文件定义所有服务
2. **服务编排** - 管理服务依赖关系
3. **一键部署** - 单条命令启动整个应用
4. **环境隔离** - 不同项目互不影响

**示例：**
```yaml
version: '3.8'
services:
  web:
    build: .
    ports:
      - "8080:8080"
    depends_on:
      - db
  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: root
```

### 5.3 容器退出后数据会丢失吗？如何保留？

**答案：**

**默认情况：**
- 容器文件系统的修改会丢失
- 容器删除后数据完全丢失

**保留数据的方法：**

**1. 使用 Volume（推荐）**
```bash
docker volume create app-data
docker run -v app-data:/data myapp
```

**2. 挂载主机目录**
```bash
docker run -v /host/data:/container/data myapp
```

**3. 导出容器**
```bash
docker export container_name > backup.tar
```

### 5.4 Docker 的安全性如何保障？

**答案：**

**1. 不以 root 用户运行**
```dockerfile
RUN adduser -S appuser
USER appuser
```

**2. 使用只读文件系统**
```bash
docker run --read-only myapp
```

**3. 限制容器权限**
```bash
docker run --cap-drop ALL --cap-add NET_BIND_SERVICE myapp
```

**4. 扫描镜像漏洞**
```bash
docker scan myapp:latest
```

**5. 使用私有镜像仓库**

**6. 网络隔离**
```yaml
networks:
  internal:
    internal: true  # 不能访问外网
```

### 5.5 如何监控 Docker 容器？

**答案：**

**1. docker stats 命令**
```bash
docker stats
docker stats --no-stream
```

**2. cAdvisor**
```bash
docker run -d \
  -p 8080:8080 \
  -v /:/rootfs:ro \
  -v /var/run:/var/run:ro \
  google/cadvisor
```

**3. Prometheus + Grafana**
```yaml
services:
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
  
  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
```

**4. ELK Stack（日志监控）**

**监控指标：**
- CPU 使用率
- 内存使用率
- 网络 I/O
- 磁盘 I/O
- 容器数量

---

## 六、综合应用题

### 6.1 设计一个微服务应用的 Docker 部署方案

**答案：**

**架构设计：**
```
Nginx → Gateway → 多个微服务 → MySQL/Redis/RabbitMQ
```

**docker-compose.yml：**
```yaml
version: '3.8'

services:
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    depends_on:
      - gateway

  gateway:
    build: ./gateway
    depends_on:
      - eureka
    environment:
      EUREKA_SERVER: http://eureka:8761/eureka

  eureka:
    build: ./eureka
    ports:
      - "8761:8761"

  user-service:
    build: ./user-service
    depends_on:
      - mysql
      - redis
    environment:
      DB_HOST: mysql
      REDIS_HOST: redis

  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: root
    volumes:
      - mysql-data:/var/lib/mysql

  redis:
    image: redis:alpine
    command: redis-server --requirepass redis123

volumes:
  mysql-data:
```

### 6.2 如何实现 Docker 的 CI/CD？

**答案：**

**GitLab CI/CD 示例：**
```yaml
stages:
  - build
  - test
  - deploy

build:
  stage: build
  script:
    - docker build -t myapp:$CI_COMMIT_SHA .
    - docker push myapp:$CI_COMMIT_SHA

test:
  stage: test
  script:
    - docker run myapp:$CI_COMMIT_SHA npm test

deploy:
  stage: deploy
  script:
    - docker-compose pull
    - docker-compose up -d
  only:
    - main
```

---

## 七、小结

**Docker 面试高频考点：**

✅ **基础概念**
- Docker 是什么
- 与虚拟机的区别
- 核心组件

✅ **镜像与容器**
- 分层存储原理
- Dockerfile 编写
- 容器生命周期

✅ **网络与存储**
- 网络模式
- 数据持久化
- 容器通信

✅ **实战应用**
- 应用容器化
- 问题排查
- 性能优化

✅ **进阶内容**
- Docker Compose
- 微服务部署
- CI/CD 集成

**面试准备建议：**
1. 理解 Docker 核心原理
2. 熟练掌握常用命令
3. 有实际项目经验
4. 了解容器编排（Kubernetes）
5. 关注安全性和性能优化

---

**恭喜你完成了 Docker 教程的学习！🎉**

**建议：**
- 多动手实践
- 参与开源项目
- 关注官方文档更新
- 学习 Kubernetes 等容器编排工具

**继续学习路径：**
- Kubernetes 容器编排
- Docker Swarm
- 服务网格（Service Mesh）
- 云原生技术栈
