---
title: Docker核心概念
---

# Docker核心概念

## 一、Docker镜像原理

### 1.1 镜像的本质

Docker 镜像是一个**只读的文件系统**，包含了运行应用所需的所有内容：
- 代码
- 运行时环境
- 系统工具
- 系统库
- 配置文件

**镜像 = 文件系统快照 + 启动命令**

### 1.2 分层存储（Union FS）

Docker 镜像采用**联合文件系统（Union File System）**技术，实现分层存储：

```
┌─────────────────────────────────┐
│  可写容器层 (Container Layer)    │  ← 容器运行时的修改
├─────────────────────────────────┤
│  应用层 (COPY app.jar)           │  ← 只读镜像层
├─────────────────────────────────┤
│  依赖层 (RUN apt-get install)   │  ← 只读镜像层
├─────────────────────────────────┤
│  JDK层 (FROM openjdk:8)         │  ← 只读镜像层
├─────────────────────────────────┤
│  基础层 (Base Image)             │  ← 只读镜像层
└─────────────────────────────────┘
```

**分层存储的优势：**
```
✅ 节省存储空间 - 多个镜像共享相同的基础层
✅ 加快传输速度 - 只传输变化的层
✅ 提高构建效率 - 利用缓存机制
✅ 版本控制方便 - 每层都有唯一ID
```

**示例：**
```bash
# 查看镜像的分层信息
docker history nginx:latest

# 输出示例：
# IMAGE          CREATED        CREATED BY                     SIZE
# 605c77e624dd   2 weeks ago    CMD ["nginx" "-g" "daemon...   0B
# <missing>      2 weeks ago    EXPOSE 80                      0B
# <missing>      2 weeks ago    COPY nginx.conf /etc/nginx/    1.2kB
# <missing>      3 weeks ago    RUN apt-get update && apt...   50MB
# <missing>      4 weeks ago    /bin/sh -c #(nop) ADD fil...   80MB
```

### 1.3 写时复制（Copy-on-Write）

容器修改文件时，采用写时复制策略：

```
1. 容器启动时，所有镜像层都是只读的
2. 容器需要修改文件时：
   - 从只读层复制文件到可写层
   - 在可写层进行修改
   - 只读层保持不变
3. 删除容器后，可写层的修改全部丢失
```

**示例：**
```bash
# 启动容器
docker run -it --name test ubuntu bash

# 在容器中创建文件
echo "Hello Docker" > /tmp/test.txt

# 退出容器
exit

# 查看容器的文件系统变化
docker diff test

# 输出：
# A /tmp/test.txt  (A = Added 新增)
# C /etc           (C = Changed 修改)
```

### 1.4 镜像ID与摘要

**镜像ID（Image ID）：**
- 镜像内容的 SHA256 哈希值
- 全局唯一标识
- 通常显示前12位

**镜像摘要（Digest）：**
- 镜像清单的 SHA256 哈希值
- 用于精确引用镜像版本

```bash
# 查看镜像详细信息
docker inspect nginx:latest | grep -A 5 "Id"

# 拉取指定摘要的镜像
docker pull nginx@sha256:abc123...
```

---

## 二、Dockerfile详解

### 2.1 Dockerfile 基础

Dockerfile 是用于构建 Docker 镜像的文本文件，包含一系列指令。

**基本结构：**
```dockerfile
# 基础镜像
FROM openjdk:8-jdk-alpine

# 维护者信息
LABEL maintainer="your-email@example.com"

# 设置工作目录
WORKDIR /app

# 复制文件
COPY target/app.jar app.jar

# 暴露端口
EXPOSE 8080

# 启动命令
ENTRYPOINT ["java", "-jar", "app.jar"]
```

### 2.2 Dockerfile 指令详解

#### FROM - 指定基础镜像

```dockerfile
# 使用官方镜像
FROM openjdk:8-jdk-alpine

# 使用特定版本
FROM mysql:8.0

# 使用多阶段构建
FROM maven:3.8-openjdk-8 AS builder
FROM openjdk:8-jre-alpine
```

#### LABEL - 添加元数据

```dockerfile
LABEL maintainer="developer@example.com"
LABEL version="1.0"
LABEL description="This is my application"
```

#### WORKDIR - 设置工作目录

```dockerfile
# 设置工作目录（自动创建）
WORKDIR /app

# 后续的 RUN、CMD、COPY 等命令都在此目录执行
COPY . .
```

#### COPY - 复制文件

```dockerfile
# 复制单个文件
COPY app.jar /app/

# 复制目录
COPY src/ /app/src/

# 复制多个文件
COPY file1.txt file2.txt /app/

# 使用通配符
COPY *.jar /app/
```

#### ADD - 高级复制

```dockerfile
# 基本复制（与 COPY 相同）
ADD app.jar /app/

# 自动解压 tar 文件
ADD app.tar.gz /app/

# 从 URL 下载（不推荐，建议用 RUN curl）
ADD https://example.com/file.tar.gz /app/
```

**COPY vs ADD：**
```
推荐使用 COPY：
- 语义更清晰
- 功能单一
- 更可预测

只在需要自动解压时使用 ADD
```

#### RUN - 执行命令

```dockerfile
# Shell 形式（会启动 shell）
RUN apt-get update && apt-get install -y nginx

# Exec 形式（不启动 shell）
RUN ["/bin/bash", "-c", "echo hello"]

# 多行命令（推荐）
RUN apt-get update && \
    apt-get install -y \
        nginx \
        curl \
        vim && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

**最佳实践：**
```dockerfile
# ❌ 不好 - 创建多个层
RUN apt-get update
RUN apt-get install -y nginx
RUN apt-get clean

# ✅ 好 - 合并为一层
RUN apt-get update && \
    apt-get install -y nginx && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

#### ENV - 设置环境变量

```dockerfile
# 设置单个变量
ENV JAVA_HOME /usr/lib/jvm/java-8-openjdk

# 设置多个变量
ENV APP_VERSION=1.0 \
    APP_NAME=myapp \
    APP_PORT=8080

# 使用环境变量
RUN echo $JAVA_HOME
WORKDIR $APP_HOME
```

#### ARG - 构建参数

```dockerfile
# 定义构建参数
ARG VERSION=1.0
ARG BUILD_DATE

# 使用构建参数
RUN echo "Building version: $VERSION"

# 构建时传入参数
# docker build --build-arg VERSION=2.0 .
```

**ARG vs ENV：**
```
ARG：
- 只在构建时有效
- 不会保留到镜像中
- 用于构建时配置

ENV：
- 在构建和运行时都有效
- 会保留到镜像中
- 用于运行时配置
```

#### EXPOSE - 声明端口

```dockerfile
# 声明单个端口
EXPOSE 8080

# 声明多个端口
EXPOSE 8080 8443

# 声明 UDP 端口
EXPOSE 53/udp
```

**注意：** EXPOSE 只是声明，不会自动映射端口，需要在运行时用 `-p` 参数。

#### VOLUME - 声明数据卷

```dockerfile
# 声明单个卷
VOLUME /data

# 声明多个卷
VOLUME ["/data", "/logs"]
```

#### CMD - 默认启动命令

```dockerfile
# Shell 形式
CMD java -jar app.jar

# Exec 形式（推荐）
CMD ["java", "-jar", "app.jar"]

# 与 ENTRYPOINT 配合使用
ENTRYPOINT ["java", "-jar"]
CMD ["app.jar"]
```

#### ENTRYPOINT - 入口点

```dockerfile
# Exec 形式（推荐）
ENTRYPOINT ["java", "-jar", "app.jar"]

# Shell 形式
ENTRYPOINT java -jar app.jar

# 与 CMD 组合
ENTRYPOINT ["java"]
CMD ["-jar", "app.jar"]
```

**CMD vs ENTRYPOINT：**
```
CMD：
- 容易被 docker run 命令覆盖
- 适合提供默认命令

ENTRYPOINT：
- 不容易被覆盖
- 适合固定的启动命令

组合使用：
ENTRYPOINT 定义主命令
CMD 定义默认参数
```

#### USER - 指定用户

```dockerfile
# 创建用户
RUN groupadd -r appuser && useradd -r -g appuser appuser

# 切换用户
USER appuser

# 后续命令以 appuser 身份执行
WORKDIR /app
```

#### HEALTHCHECK - 健康检查

```dockerfile
# 基本健康检查
HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost:8080/health || exit 1

# 详细配置
HEALTHCHECK --interval=5m --timeout=3s --retries=3 \
  CMD curl -f http://localhost/ || exit 1

# 禁用健康检查
HEALTHCHECK NONE
```

### 2.3 多阶段构建

多阶段构建可以显著减小最终镜像的大小。

**示例：Spring Boot 应用**

```dockerfile
# 第一阶段：构建
FROM maven:3.8-openjdk-8 AS builder
WORKDIR /build
COPY pom.xml .
COPY src ./src
RUN mvn clean package -DskipTests

# 第二阶段：运行
FROM openjdk:8-jre-alpine
WORKDIR /app
COPY --from=builder /build/target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

**对比：**
```
单阶段构建镜像：800MB（包含 Maven、源码等）
多阶段构建镜像：120MB（仅包含 JRE 和 JAR）

节省空间：85%
```

### 2.4 .dockerignore 文件

类似 `.gitignore`，用于排除不需要的文件。

**示例：**
```
# .dockerignore
.git
.gitignore
.idea
*.md
target/
*.log
node_modules/
.env
docker-compose.yml
Dockerfile
```

---

## 三、Docker网络

### 3.1 网络模式

Docker 提供多种网络模式：

| 网络模式 | 说明 | 使用场景 |
|---------|------|---------|
| bridge | 桥接网络（默认） | 容器间通信 |
| host | 主机网络 | 性能要求高 |
| none | 无网络 | 安全隔离 |
| container | 共享网络 | 容器间紧密通信 |
| 自定义网络 | 用户定义 | 复杂网络拓扑 |

### 3.2 Bridge 网络（默认）

```bash
# 查看默认网络
docker network ls

# 默认 bridge 网络信息
docker network inspect bridge

# 使用默认网络运行容器
docker run -d --name web nginx

# 容器间通信（通过IP）
docker exec web ping <另一个容器的IP>
```

**特点：**
```
✅ 自动分配 IP
✅ 容器间可通过 IP 通信
❌ 不支持容器名解析
❌ 不适合生产环境
```

### 3.3 自定义Bridge网络（推荐）

```bash
# 创建自定义网络
docker network create my-network

# 查看网络详情
docker network inspect my-network

# 在自定义网络中运行容器
docker run -d --name web --network my-network nginx
docker run -d --name db --network my-network mysql:8.0

# 容器间通信（通过容器名）
docker exec web ping db  # 成功！支持容器名解析
```

**优势：**
```
✅ 自动 DNS 解析
✅ 更好的隔离性
✅ 可以动态连接/断开
✅ 适合生产环境
```

### 3.4 Host 网络

```bash
# 使用主机网络
docker run -d --name web --network host nginx

# 容器直接使用主机网络栈
# 无需端口映射，性能最佳
```

**特点：**
```
✅ 性能最佳（无网络转换）
❌ 端口冲突风险
❌ 失去网络隔离
```

### 3.5 网络管理命令

```bash
# 创建网络
docker network create my-network

# 指定子网和网关
docker network create --subnet=172.20.0.0/16 --gateway=172.20.0.1 my-network

# 连接容器到网络
docker network connect my-network my-container

# 断开连接
docker network disconnect my-network my-container

# 删除网络
docker network rm my-network

# 清理未使用的网络
docker network prune
```

### 3.6 端口映射

```bash
# 映射单个端口
docker run -d -p 8080:80 nginx

# 映射多个端口
docker run -d -p 8080:80 -p 8443:443 nginx

# 映射到随机端口
docker run -d -P nginx

# 映射到指定 IP
docker run -d -p 127.0.0.1:8080:80 nginx

# 查看端口映射
docker port my-container
```

---

## 四、Docker数据卷（Volume）

### 4.1 为什么需要数据卷？

```
问题：容器删除后，数据会丢失

解决方案：
1. 数据卷（Volume）- 推荐
2. 绑定挂载（Bind Mount）
3. tmpfs 挂载（临时文件系统）
```

### 4.2 数据卷（Volume）

**创建和使用数据卷：**

```bash
# 创建数据卷
docker volume create my-volume

# 查看所有数据卷
docker volume ls

# 查看数据卷详情
docker volume inspect my-volume

# 使用数据卷
docker run -d \
  --name db \
  -v my-volume:/var/lib/mysql \
  mysql:8.0

# 删除数据卷
docker volume rm my-volume

# 清理未使用的数据卷
docker volume prune
```

**特点：**
```
✅ Docker 管理，位置透明
✅ 可以在容器间共享
✅ 支持驱动程序
✅ 备份和迁移方便
✅ 推荐用于持久化数据
```

### 4.3 绑定挂载（Bind Mount）

```bash
# 挂载主机目录
docker run -d \
  --name web \
  -v /my/html:/usr/share/nginx/html \
  nginx

# Windows 路径
docker run -d -v C:\data:/data nginx

# 只读挂载
docker run -d -v /my/html:/usr/share/nginx/html:ro nginx
```

**特点：**
```
✅ 可以指定主机路径
✅ 适合开发环境
❌ 依赖主机文件系统
❌ 不推荐用于生产环境
```

### 4.4 tmpfs 挂载

```bash
# 创建内存文件系统
docker run -d \
  --name web \
  --tmpfs /tmp:rw,size=100m \
  nginx
```

**特点：**
```
✅ 存储在内存中
✅ 性能极佳
❌ 容器停止数据丢失
❌ 不支持 Windows
```

### 4.5 数据卷容器

```bash
# 创建数据卷容器
docker create -v /data --name data-container busybox

# 其他容器使用数据卷容器
docker run -d --volumes-from data-container --name app1 nginx
docker run -d --volumes-from data-container --name app2 nginx

# app1 和 app2 共享 /data 目录
```

### 4.6 备份与恢复

**备份数据卷：**
```bash
# 备份数据卷到 tar 文件
docker run --rm \
  -v my-volume:/data \
  -v $(pwd):/backup \
  ubuntu tar czf /backup/backup.tar.gz /data
```

**恢复数据卷：**
```bash
# 从 tar 文件恢复数据卷
docker run --rm \
  -v my-volume:/data \
  -v $(pwd):/backup \
  ubuntu tar xzf /backup/backup.tar.gz -C /
```

---

## 五、容器生命周期管理

### 5.1 容器状态

```
┌─────────┐
│ Created │  docker create
└────┬────┘
     │ docker start
     ▼
┌─────────┐
│ Running │  ◄──┐
└────┬────┘     │
     │          │ docker unpause
     │ docker pause
     ▼          │
┌─────────┐    │
│ Paused  │────┘
└────┬────┘
     │
     │ docker stop
     ▼
┌─────────┐
│ Stopped │
└────┬────┘
     │ docker rm
     ▼
┌─────────┐
│ Deleted │
└─────────┘
```

### 5.2 容器操作

**创建容器：**
```bash
# 创建但不启动
docker create --name my-app nginx

# 查看容器（包括未启动的）
docker ps -a
```

**启动容器：**
```bash
# 启动已停止的容器
docker start my-app

# 启动并附加到容器
docker start -a my-app

# 启动所有已停止的容器
docker start $(docker ps -aq)
```

**停止容器：**
```bash
# 优雅停止（发送 SIGTERM，10秒后 SIGKILL）
docker stop my-app

# 强制停止（直接 SIGKILL）
docker kill my-app

# 停止所有运行中的容器
docker stop $(docker ps -q)
```

**重启容器：**
```bash
# 重启容器
docker restart my-app

# 重启策略
docker run -d --restart=always nginx
# always - 总是重启
# unless-stopped - 除非手动停止
# on-failure - 失败时重启
# no - 不自动重启（默认）
```

**暂停和恢复：**
```bash
# 暂停容器
docker pause my-app

# 恢复容器
docker unpause my-app
```

**删除容器：**
```bash
# 删除已停止的容器
docker rm my-app

# 强制删除运行中的容器
docker rm -f my-app

# 删除所有已停止的容器
docker container prune

# 删除所有容器
docker rm -f $(docker ps -aq)
```

### 5.3 容器资源限制

**CPU 限制：**
```bash
# 限制 CPU 使用率
docker run -d --cpus=1.5 nginx  # 最多使用 1.5 个 CPU

# CPU 份额（相对权重）
docker run -d --cpu-shares=512 nginx

# 指定 CPU 核心
docker run -d --cpuset-cpus=0,1 nginx  # 只使用 CPU 0 和 1
```

**内存限制：**
```bash
# 限制内存使用
docker run -d --memory=512m nginx

# 内存 + Swap 限制
docker run -d --memory=512m --memory-swap=1g nginx

# 内存预留
docker run -d --memory-reservation=256m nginx
```

**磁盘 I/O 限制：**
```bash
# 限制读写速度
docker run -d \
  --device-read-bps /dev/sda:1mb \
  --device-write-bps /dev/sda:1mb \
  nginx
```

**查看资源使用：**
```bash
# 实时查看资源使用
docker stats

# 查看指定容器
docker stats my-app

# 查看所有容器（包括已停止的）
docker stats --all
```

---

## 六、镜像构建最佳实践

### 6.1 减小镜像体积

**1. 使用轻量级基础镜像**
```dockerfile
# ❌ 不好 - 800MB
FROM ubuntu:latest

# ✅ 好 - 5MB
FROM alpine:latest

# ✅ Java 应用
FROM openjdk:8-jre-alpine  # 而不是 openjdk:8-jdk
```

**2. 多阶段构建**
```dockerfile
# 构建阶段
FROM maven:3.8-openjdk-8 AS builder
WORKDIR /build
COPY pom.xml .
COPY src ./src
RUN mvn package -DskipTests

# 运行阶段
FROM openjdk:8-jre-alpine
COPY --from=builder /build/target/*.jar app.jar
ENTRYPOINT ["java", "-jar", "app.jar"]
```

**3. 合并 RUN 指令**
```dockerfile
# ❌ 不好 - 创建多层
RUN apt-get update
RUN apt-get install -y curl
RUN apt-get clean

# ✅ 好 - 单层
RUN apt-get update && \
    apt-get install -y curl && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

**4. 清理缓存和临时文件**
```dockerfile
RUN apt-get update && \
    apt-get install -y nginx && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
```

### 6.2 利用构建缓存

**1. 合理安排指令顺序**
```dockerfile
# ✅ 好 - 先复制依赖文件
FROM maven:3.8-openjdk-8
WORKDIR /app
COPY pom.xml .          # 依赖变化少，缓存命中率高
RUN mvn dependency:go-offline
COPY src ./src          # 源码变化频繁，放在后面
RUN mvn package
```

**2. 使用 .dockerignore**
```
.git
.gitignore
*.md
target/
node_modules/
```

### 6.3 安全性

**1. 不要以 root 用户运行**
```dockerfile
# 创建普通用户
RUN groupadd -r appuser && useradd -r -g appuser appuser

# 切换用户
USER appuser

# 设置工作目录权限
WORKDIR /app
RUN chown -R appuser:appuser /app
```

**2. 不要在镜像中存储敏感信息**
```dockerfile
# ❌ 不好
ENV PASSWORD=secret123

# ✅ 好 - 运行时传入
docker run -e PASSWORD=secret123 myapp
```

**3. 使用具体的版本号**
```dockerfile
# ❌ 不好
FROM nginx:latest

# ✅ 好
FROM nginx:1.21-alpine
```

### 6.4 示例：优化的 Spring Boot Dockerfile

```dockerfile
# 多阶段构建
FROM maven:3.8-openjdk-8-slim AS builder
WORKDIR /build

# 复制 pom.xml 并下载依赖（利用缓存）
COPY pom.xml .
RUN mvn dependency:go-offline

# 复制源码并构建
COPY src ./src
RUN mvn clean package -DskipTests

# 运行阶段
FROM openjdk:8-jre-alpine

# 安装依赖
RUN apk add --no-cache tzdata && \
    cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && \
    echo "Asia/Shanghai" > /etc/timezone && \
    apk del tzdata

# 创建用户
RUN addgroup -S appgroup && adduser -S appuser -G appgroup

# 设置工作目录
WORKDIR /app

# 复制 jar 文件
COPY --from=builder /build/target/*.jar app.jar

# 修改权限
RUN chown -R appuser:appgroup /app

# 切换用户
USER appuser

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
  CMD wget --quiet --tries=1 --spider http://localhost:8080/actuator/health || exit 1

# 暴露端口
EXPOSE 8080

# 启动应用
ENTRYPOINT ["java", \
    "-Djava.security.egd=file:/dev/./urandom", \
    "-Xms256m", \
    "-Xmx512m", \
    "-jar", \
    "app.jar"]
```

---

## 七、小结

通过本章学习，你应该掌握：

✅ **镜像原理**
- 分层存储
- 写时复制
- 镜像ID和摘要

✅ **Dockerfile**
- 常用指令
- 多阶段构建
- .dockerignore

✅ **Docker 网络**
- 网络模式
- 自定义网络
- 端口映射

✅ **数据卷**
- Volume 管理
- 绑定挂载
- 备份恢复

✅ **容器管理**
- 生命周期
- 资源限制
- 最佳实践

**下一章预告：**
在下一章中，我们将进行实战演练，学习如何容器化 Spring Boot、MySQL、Redis 等常用应用。

---

**继续学习** → [第三章：Docker 实战应用](3.Docker实战应用.md)
