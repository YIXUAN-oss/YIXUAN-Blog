# Java 枚举与注解

> **本章重点：** 掌握枚举的使用方法、注解的基本概念和常用注解
> 
> **面试频率：** ⭐⭐⭐⭐

---

## 目录
- [一、枚举（Enum）](#一枚举enum)
  - [1.1 枚举的引入](#11-枚举的引入)
  - [1.2 枚举的实现方式](#12-枚举的实现方式)
  - [1.3 枚举的常用方法](#13-枚举的常用方法)
  - [1.4 枚举实现接口](#14-枚举实现接口)
- [二、注解（Annotation）](#二注解annotation)
  - [2.1 注解的理解](#21-注解的理解)
  - [2.2 基本注解](#22-基本注解)
- [三、面试常见问题](#三面试常见问题)

---

## 一、枚举（Enum）

### 1.1 枚举的引入

#### 需求场景
要求创建季节(Season) 对象，请设计并完成。

```java
class Season{
    private String name;
    private String desc; // 描述
    // 构造器
    // getXX
    // setXX
}
```

#### 问题分析
创建 Season 对象有如下特点：

1. 季节的值是有限的几个值(spring, summer, autumn, winter)
2. 只读，不需要修改
3. 需要避免创建无效的季节对象

#### 解决方案 - 枚举

1) 枚举对应英文(enumeration, 简写 enum)

2) 枚举是一组常量的集合。

3) 可以这里理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象

**枚举的优点：**
- 类型安全：编译时检查，避免传入无效值
- 代码清晰：见名知义，提高可读性
- 易于维护：统一管理常量

---

### 1.2 枚举的实现方式

Java中有两种实现枚举的方式：
1. 自定义类实现枚举（JDK 1.5之前）
2. 使用 `enum` 关键字实现枚举（JDK 1.5及之后，推荐）

#### 方式一：自定义类实现枚举

**实现步骤：**
1. 构造器私有化，防止外部创建对象
2. 类内部创建固定的对象实例
3. 对外暴露对象（使用 `public static final` 修饰）
4. 提供 `get` 方法，但不提供 `set` 方法

```java
public class Enumeration02 {  
    public static void main(String[] args) {  
        System.out.println(Season.AUTUMN);  
        System.out.println(Season.SPRING);  
    }  
}  

// 演示自定义枚举实现  
class Season {
    private String name;  
    private String desc; // 描述  
    
    // 定义了四个对象, 固定   
    public static final Season SPRING = new Season("春天", "温暖");  
    public static final Season WINTER = new Season("冬天", "寒冷");  
    public static final Season AUTUMN = new Season("秋天", "凉爽");  
    public static final Season SUMMER = new Season("夏天", "炎热");  
    
    // 1. 将构造器私有化,目的防止 直接 new
    // 2. 去掉 setXxx 方法, 防止属性被修改  
    // 3. 在 Season 内部，直接创建固定的对象  
    // 4. 优化，可以加入 final 修饰符  
    private Season(String name, String desc) {  
        this.name = name;  
        this.desc = desc;  
    }  
    
    public String getName() {  
        return name;  
    }  
    
    public String getDesc() {  
        return desc;  
    }  
    
    @Override  
    public String toString() {  
        return "Season{" +  
                "name='" + name + '\'' +  
                ", desc='" + desc + '\'' +  
                '}';  
    }  
}
```

**特点总结：**
- ✅ 构造器私有化
- ✅ 本类内部创建一组对象（四个：春夏秋冬）
- ✅ 对外暴露对象（通过 `public static final` 修饰符）
- ✅ 提供 `get` 方法，但不提供 `set` 方法

**缺点：** 代码冗长，需要手动控制

---

#### 方式二：`enum` 关键字实现枚举（推荐）

```java
public class Enumeration03 {  
    public static void main(String[] args) {  
        System.out.println(Season2.AUTUMN);  
        System.out.println(Season2.SUMMER);  
    }  
}  

// 演示使用 enum 关键字来实现枚举类  
enum Season2 {
    // 如果使用了 enum 来实现枚举类  
    // 1. 使用关键字 enum 替代 class
    // 2. public static final Season SPRING = new Season("春天", "温暖") 直接使用  
    //    SPRING("春天", "温暖") 解读 常量名(实参列表)  
    // 3. 如果有多个常量(对象)， 使用 ,号间隔即可  
    // 4. 如果使用 enum 来实现枚举，要求将定义常量对象，写在前面  
    // 5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 ()    
    SPRING("春天", "温暖"), 
    WINTER("冬天", "寒冷"), 
    AUTUMN("秋天", "凉爽"), 
    SUMMER("夏天", "炎热");
    
    private String name;  
    private String desc; // 描述  
    
    private Season2() { // 无参构造器  
    }  
    
    private Season2(String name, String desc) {  
        this.name = name;  
        this.desc = desc;  
    }  
    
    public String getName() {  
        return name;  
    }  
    
    public String getDesc() {  
        return desc;  
    }  
    
    @Override  
    public String toString() {  
        return "Season{" +  
                "name='" + name + '\'' +  
                ", desc='" + desc + '\'' +  
                '}';  
    }  
}
```

**enum 关键字实现枚举的注意事项：**

| 注意点 | 说明 |
|--------|------|
| ① 继承关系 | 使用 `enum` 关键字开发的枚举类，默认继承 `Enum` 类，而且是 `final` 类（可用 `javap` 工具验证） |
| ② 简化语法 | 传统的 `public static final Season2 SPRING = new Season2("春天", "温暖");` 简化为 `SPRING("春天", "温暖")` |
| ③ 无参构造 | 如果使用无参构造器创建枚举对象，实参列表和小括号都可以省略 |
| ④ 多个对象 | 当有多个枚举对象时，使用 `,` 间隔，最后有一个分号结尾 |
| ⑤ 对象位置 | 枚举对象必须放在枚举类的行首 |
| ⑥ 单继承限制 | 枚举类不能再继承其他类（已继承 `Enum`），但可以实现接口 |

---

### 1.3 枚举的常用方法

`enum` 关键字定义的枚举类继承自 `java.lang.Enum`，提供了以下常用方法：

| 方法 | 返回类型 | 说明 | 示例 |
|------|----------|------|------|
| `toString()` | String | 返回枚举常量的名称（可重写） | `Season.SPRING.toString()` → "SPRING" |
| `name()` | String | 返回枚举常量的名称（不可重写） | `Season.SPRING.name()` → "SPRING" |
| `ordinal()` | int | 返回枚举常量的序号（从0开始） | `Season.SPRING.ordinal()` → 0 |
| `values()` | 枚举数组 | 返回所有枚举常量 | `Season.values()` → [SPRING, SUMMER, AUTUMN, WINTER] |
| `valueOf(String)` | 枚举对象 | 将字符串转为枚举对象 | `Season.valueOf("SPRING")` → SPRING |
| `compareTo(E)` | int | 比较两个枚举常量的序号 | `Season.SPRING.compareTo(Season.SUMMER)` → -1 |

**代码示例：**
```java
public class EnumMethodTest {
    public static void main(String[] args) {
        // 1. toString()
        System.out.println(Season.SPRING); // 输出: Season{name='春天', desc='温暖'}
        
        // 2. name()
        System.out.println(Season.SPRING.name()); // 输出: SPRING
        
        // 3. ordinal()
        System.out.println(Season.SUMMER.ordinal()); // 输出: 1
        
        // 4. values()
        Season[] seasons = Season.values();
        for (Season season : seasons) {
            System.out.println(season);
        }
        
        // 5. valueOf()
        Season autumn = Season.valueOf("AUTUMN");
        System.out.println(autumn); // 输出: AUTUMN
        
        // 6. compareTo()
        System.out.println(Season.SPRING.compareTo(Season.WINTER)); // 输出: -3
    }
}
```

---

### 1.4 枚举实现接口

**重要说明：**
1. 使用 `enum` 关键字后，就不能再继承其它类了（因为已隐式继承 `Enum`，Java是单继承）
2. 枚举类和普通类一样，**可以实现接口**

**语法格式：**
```java
enum 类名 implements 接口1, 接口2 {
    // 枚举常量
}
```

**示例代码：**
```java
public class EnumDetail {  
    public static void main(String[] args) {  
        Music.CLASSICMUSIC.playing();  
    }  
}  

interface IPlaying {  
    public void playing();  
}  

enum Music implements IPlaying {  
    CLASSICMUSIC;  
  
    @Override  
    public void playing() {  
        System.out.println("播放好听的音乐...");  
    }  
}
```

---

## 二、注解（Annotation）

### 2.1 注解的理解

#### 什么是注解？

注解（Annotation）也被称为**元数据（Metadata）**，是JDK 5.0引入的一个特性。

**作用：** 用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。

**特点：**
- 和注释一样，注解不影响程序逻辑
- 但注解可以被编译器或运行时读取，相当于嵌入在代码中的补充信息
- 在 JavaSE 中：标记过时功能、忽略警告等
- 在 JavaEE 中：配置应用程序、代替繁冗的 XML 配置等

---

### 2.2 基本注解

使用注解时要在其前面增加 `@` 符号，并把该注解当成一个修饰符使用。

#### 三个基本的 Annotation：

##### ① @Override

**作用：** 限定某个方法是重写父类方法，该注解只能用于方法

**特点：**
- 编译器会检查该方法是否确实重写了父类方法
- 如果父类没有该方法，编译器会报错
- 提高代码可读性和安全性

**示例：**
```java
class Parent {
    public void show() {
        System.out.println("父类方法");
    }
}

class Child extends Parent {
    @Override
    public void show() {
        System.out.println("子类重写父类方法");
    }
    
    // 编译错误：父类中没有 show2() 方法
    // @Override
    // public void show2() { }
}
```

---

##### ② @Deprecated

**作用：** 表示某个程序元素（类、方法等）已过时，不推荐使用

**特点：**
- 标记为过时的元素仍可使用，但编译器会给出警告
- 用于向开发者传达"该功能已被替代"的信息

**示例：**
```java
class MyClass {
    @Deprecated
    public void oldMethod() {
        System.out.println("这是一个过时的方法");
    }
    
    public void newMethod() {
        System.out.println("请使用新方法");
    }
}

public class Test {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.oldMethod(); // 编译器会显示删除线警告
    }
}
```

---

##### ③ @SuppressWarnings

**作用：** 抑制编译器警告

**常用参数：**
- `"all"` - 抑制所有警告
- `"unchecked"` - 抑制未检查的警告（如泛型）
- `"deprecation"` - 抑制过时警告
- `"rawtypes"` - 抑制原始类型警告

**示例：**
```java
import java.util.ArrayList;
import java.util.List;

public class SuppressWarningsTest {
    @SuppressWarnings("all")
    public static void main(String[] args) {
        List list = new ArrayList(); // 没有泛型，但不会有警告
        list.add("hello");
        list.add(100);
    }
    
    @SuppressWarnings({"unchecked", "deprecation"})
    public void method() {
        // 抑制多个类型的警告
    }
}
```

---

## 三、面试常见问题

### 📝 枚举相关面试题

#### Q1: 什么是枚举？为什么要使用枚举？

**答案：**

枚举是一种特殊的类，用于定义一组固定的常量。

**使用枚举的优点：**
1. **类型安全**：编译时检查，避免传入无效值
2. **代码清晰**：见名知义，提高可读性
3. **易于维护**：集中管理常量，避免魔法数字
4. **可以添加方法和属性**：比普通常量更强大

---

#### Q2: enum 和 class 的区别是什么？

**答案：**

| 特性 | enum | class |
|------|------|-------|
| 继承 | 默认继承 `java.lang.Enum`，不能继承其他类 | 可以继承其他类 |
| 实例化 | 不能使用 `new` 创建实例 | 可以使用 `new` 创建实例 |
| 实例数量 | 实例数量固定（枚举常量） | 可以创建任意数量的实例 |
| 修饰符 | 默认是 `public static final` | 需要手动指定 |
| 序列化 | 自动支持序列化，且保证单例 | 需要实现 `Serializable` 接口 |
| 比较 | 可以用 `==` 比较 | 推荐用 `equals()` 比较 |

---

#### Q3: 枚举的底层实现原理是什么？

**答案：**

使用 `enum` 定义的枚举类，编译器会自动生成以下内容：

1. **继承 `Enum` 类**
2. **添加 `final` 修饰符**（枚举类不能被继承）
3. **将枚举常量转换为 `public static final` 的实例**
4. **自动生成 `values()` 和 `valueOf()` 方法**

**验证方式：**
```bash
# 编译枚举类
javac Season.java

# 反编译查看字节码
javap -c Season.class
```

---

#### Q4: 枚举能否实现接口？能否继承类？

**答案：**

- ✅ **能实现接口**：枚举可以实现多个接口
- ❌ **不能继承类**：枚举已经隐式继承 `java.lang.Enum`，Java是单继承

---

### 📝 注解相关面试题

#### Q5: @Override 注解有什么作用？不加会怎样？

**答案：**

**作用：**
1. 告诉编译器这是一个重写方法
2. 编译器会检查父类是否有该方法
3. 提高代码可读性

**不加 @Override 的影响：**
- 代码仍能正常运行
- 但如果方法名拼写错误，编译器不会报错，导致没有真正重写父类方法

---

#### Q6: @Deprecated 和直接删除过时代码的区别？

**答案：**

| 方式 | 优点 | 缺点 | 使用场景 |
|------|------|------|----------|
| 直接删除 | 代码简洁 | 可能导致旧代码编译失败 | 内部项目，确定无人使用 |
| @Deprecated | 保持兼容性 | 代码冗余 | 开源库、公共API |

---

#### Q7: 如何自定义注解？

**答案：**

使用 `@interface` 关键字定义注解。

**示例：**
```java
import java.lang.annotation.*;

// 自定义注解
@Target(ElementType.METHOD) // 作用于方法
@Retention(RetentionPolicy.RUNTIME) // 运行时有效
public @interface MyAnnotation {
    String value() default ""; // 注解参数
    int count() default 0;
}

// 使用自定义注解
class MyClass {
    @MyAnnotation(value = "测试方法", count = 3)
    public void testMethod() {
        System.out.println("测试");
    }
}
```

---

## 📚 本章总结

1. **枚举**是一种特殊的类，用于定义一组固定的常量
2. 推荐使用 `enum` 关键字实现枚举（JDK 1.5+）
3. 枚举可以添加属性、方法，可以实现接口，但不能继承类
4. **注解**是一种元数据，用于修饰代码元素
5. 常用注解：`@Override`（重写检查）、`@Deprecated`（过时标记）、`@SuppressWarnings`（抑制警告）
6. 注解不影响程序逻辑，但可以被编译器或运行时读取

---

**下一章预告：** 异常处理机制
