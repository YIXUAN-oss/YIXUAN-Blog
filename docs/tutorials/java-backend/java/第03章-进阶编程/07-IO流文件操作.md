# Java IO流与文件操作

> **本章重点：** 字节流、字符流、缓冲流、对象流、Properties配置文件
>
> **面试频率：** ⭐⭐⭐⭐⭐

---

## 目录

- [一、文件基础](#一文件基础)
- [二、常用文件操作](#二常用文件操作)
- [三、IO流原理](#三io流原理)
- [四、字节流与字符流](#四字节流与字符流)
- [五、缓冲流与对象流](#五缓冲流与对象流)
- [六、其他常用流](#六其他常用流)
- [七、面试常见问题](#七面试常见问题)

---

## 一、文件基础

### 1.1 文件的概念

**文件：** 保存数据的地方，可以是文本、图片、音频、视频等。

**文件流：** 文件在程序中是以流的形式来操作的。

```
数据源（文件） → 输入流 → 程序 → 输出流 → 目的地（文件）
```

**流的分类：**

| 分类维度   | 类型   | 说明                           |
| ---------- | ------ | ------------------------------ |
| **按方向** | 输入流 | 读取数据到程序                 |
|            | 输出流 | 从程序写出数据                 |
| **按单位** | 字节流 | 处理二进制文件（图片、音频等） |
|            | 字符流 | 处理文本文件                   |
| **按角色** | 节点流 | 直接操作文件                   |
|            | 处理流 | 包装节点流，提供更多功能       |

---

## 二、常用文件操作

### 2.1 File类简介

**File类：** 代表文件和目录路径名的抽象表示。

**三种构造方法：**

| 构造方法                            | 说明                  | 示例                               |
| ----------------------------------- | --------------------- | ---------------------------------- |
| `File(String pathname)`             | 根据路径构建          | `new File("e:\\news1.txt")`        |
| `File(File parent, String child)`   | 根据父目录文件+子路径 | `new File(file, "news2.txt")`      |
| `File(String parent, String child)` | 根据父目录+子路径     | `new File("e:\\dir", "news3.txt")` |

### 2.2 创建文件

```java
import org.junit.jupiter.api.Test;

import java.io.File;
import java.io.IOException;

public class Main{
    public static void main(String[] args) {

    }

    //方式一：new File(String pathname)
    //这是一个新工程需要引入一下，@Test，红色灯点第二个，稍等
    @Test
    public void create01(){
        String filePath = "E:\\IDEA code JAVA\\wenjian\\news1.txt";
        File file = new File(filePath);

        try {
            file.createNewFile();
            System.out.println("文件创建成功");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    //方式二：new File(File parent,String child)
    //E:\IDEA code JAVA\wenjian\news2.txt
    @Test
    public void create02(){
        //构建父目录文件
        File parentfile = new File("E:\\IDEA code JAVA\\wenjian");
        //构建子路径
        String filePath = "news2.txt";
        File file = new File(parentfile, filePath);

        //这里是创建文件
        try {
            file.createNewFile();
            System.out.println("文件创建成功");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    //方式三：new File(String parent,String child)
    @Test
    public void create03(){
        String parentPath = "E:\\IDEA code JAVA\\wenjian";
        String filePath = "news2.txt";
        File file = new File(parentPath, filePath);

        //这里是创建文件
        try {
            file.createNewFile();
            System.out.println("文件创建成功");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```



### 2.3 获取文件信息

**常用方法：**

| 方法                | 说明                 | 返回类型 |
| ------------------- | -------------------- | -------- |
| `getName()`         | 获取文件名           | String   |
| `getAbsolutePath()` | 获取绝对路径         | String   |
| `getParent()`       | 获取父目录           | String   |
| `length()`          | 获取文件大小（字节） | long     |
| `exists()`          | 判断文件是否存在     | boolean  |
| `isFile()`          | 判断是否是文件       | boolean  |
| `isDirectory()`     | 判断是否是目录       | boolean  |

```java
//获取文件的信息
@Test
public void info(){
//先创建文件对象
File file = new File("e:\\news1.txt");

    //调用相应的方法，得到对应信息
    //getName、getAbsolutePath、getParent、length、exists、isFile、isDirectory
    System.out.println("文件绝对路径="+ file.getAbsolutePath());
    System.out.println("文件名字="+ file.getName());
    System.out.println("文件父级目录="+ file.getParent());
    System.out.println("文件大小(字节)="+ file.length());
    System.out.println("文件是否存在="+ file.exists());
    System.out.println("是不是一个文件="+ file.isFile());
    System.out.println("是不是一个目录="+ file.isDirectory());
}
```



### 2.4 目录操作和文件删除

**常用方法：**

| 方法       | 说明                 | 注意事项       |
| ---------- | -------------------- | -------------- |
| `mkdir()`  | 创建一级目录         | 父目录必须存在 |
| `mkdirs()` | 创建多级目录（推荐） | 自动创建父目录 |
| `delete()` | 删除文件或空目录     | 目录必须为空   |

**重要提示：**

- ⚠️ 在Java中，目录也被当做文件
- ⚠️ `delete()`只能删除空目录或文件
- ⚠️ 删除前建议先判断`exists()`

```java
//在java编程中，目录也被当成文件 delete 删除空目录或文件
import org.junit.jupiter.api.Test;

import java.io.File;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {

    }

    //查看E:\IDEA code JAVA\wenjian\news1.txt是否存在，存在就删除
    @Test
    public void m01() {
        String filePath = "E:\\IDEA code JAVA\\wenjian\\news1.txt";
        File file = new File(filePath);

        if (file.exists()) {
            if (file.delete()) {
                System.out.println(filePath + "删除成功");
            } else {
                System.out.println(filePath + "删除失败");
            }
        } else {
            System.out.println("该文件不存在");
        }
    }
}
```

```java
import org.junit.jupiter.api.Test;

import java.io.File;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        
    }
    
    //创建目录 mkdir 创建一级目录、mkdirs 创建多级目录
    @Test
    public void m01() {
       String directoryPath = "E:\\demo";
       File file = new File(directoryPath);

       if(file.exists()){
           System.out.println(directoryPath + "目录存在");
       }else{
           if(file.mkdir()){
               System.out.println(directoryPath + "目录创建成功");
           }else{
               System.out.println(directoryPath + "目录创建失败");
           }
       }
    }
}
```

```java
String directoryPath = "E:\\demo\\a\\b\\c";
用file.mkdirs()
```

---

## 三、IO流原理

### 3.1 IO流原理

**IO流（Input/Output Stream）：** 用于处理数据传输。

**原理：**

```
输入：数据源（文件） → InputStream/Reader → 程序（内存）
输出：程序（内存） → OutputStream/Writer → 目的地（文件）
```

**特点：**

- 📖 IO流以流的方式进行数据传输
- 📖 单向传输：输入流只读，输出流只写
- 📖 先进先出原则

### 3.2 流的体系结构

**Java IO流四大抽象基类：**

| 类型       | 字节流       | 字符流 |
| ---------- | ------------ | ------ |
| **输入流** | InputStream  | Reader |
| **输出流** | OutputStream | Writer |

**IO流体系图：**

```
字节流：
├─ InputStream (抽象类)
│  ├─ FileInputStream        (文件)
│  ├─ BufferedInputStream    (缓冲)
│  └─ ObjectInputStream      (对象)
└─ OutputStream (抽象类)
   ├─ FileOutputStream       (文件)
   ├─ BufferedOutputStream   (缓冲)
   └─ ObjectOutputStream     (对象)

字符流：
├─ Reader (抽象类)
│  ├─ FileReader            (文件)
│  ├─ BufferedReader        (缓冲)
│  └─ InputStreamReader     (转换)
└─ Writer (抽象类)
   ├─ FileWriter            (文件)
   ├─ BufferedWriter        (缓冲)
   └─ OutputStreamWriter    (转换)
```

### 3.3 字节流 vs 字符流

**对比：**

| 特性         | 字节流                   | 字符流               |
| ------------ | ------------------------ | -------------------- |
| **基本单位** | 字节（byte）             | 字符（char）         |
| **适用场景** | 二进制文件               | 文本文件             |
| **典型文件** | 图片、音频、视频、exe    | txt、java、html、xml |
| **基类**     | InputStream/OutputStream | Reader/Writer        |
| **编码问题** | 无需考虑                 | 需要考虑字符编码     |
| **效率**     | 一般                     | 文本处理效率更高     |

**选择建议：**

- ✅ **字节流**：处理非文本文件（图片、音频、视频等）
- ✅ **字符流**：处理文本文件（txt、java、xml等）

### 3.4 节点流 vs 处理流

**节点流（Node Stream）：** 直接操作数据源

| 类型     | 字节流                                     | 字符流                          |
| -------- | ------------------------------------------ | ------------------------------- |
| **文件** | FileInputStream/FileOutputStream           | FileReader/FileWriter           |
| **数组** | ByteArrayInputStream/ByteArrayOutputStream | CharArrayReader/CharArrayWriter |
| **管道** | PipedInputStream/PipedOutputStream         | PipedReader/PipedWriter         |

**处理流（Wrapper Stream）：** 包装节点流，提供更多功能

| 功能     | 字节流                                   | 字符流                               |
| -------- | ---------------------------------------- | ------------------------------------ |
| **缓冲** | BufferedInputStream/BufferedOutputStream | BufferedReader/BufferedWriter        |
| **对象** | ObjectInputStream/ObjectOutputStream     | -                                    |
| **转换** | -                                        | InputStreamReader/OutputStreamWriter |
| **打印** | PrintStream                              | PrintWriter                          |

**处理流的优点：**

1. ✅ 提高性能（缓冲）
2. ✅ 增强功能（按行读取、序列化等）
3. ✅ 简化操作（装饰者模式）





---

## 四、字节流与字符流

### 4.1 文件字节流

#### FileInputStream（字节输入流）

**常用方法：**

| 方法                 | 说明               |
| -------------------- | ------------------ |
| `int read()`         | 读取一个字节       |
| `int read(byte[] b)` | 读取多个字节到数组 |
| `void close()`       | 关闭流             |

**使用步骤：**

1. 创建FileInputStream对象
2. 读取数据
3. 关闭流（释放资源）

```java
import org.junit.jupiter.api.Test;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {

    }

    //读取文件
    @Test
    public void readFile01() {
       String filePath = "E:\\IDEA code JAVA\\wenjian\\news3.txt";

       int read = 0;
        FileInputStream fileInputStream = null;
        try{
           //创建 FileInputStream 对象，用于读取文件
            fileInputStream = new FileInputStream(filePath);

           //从该方法中读取一个字节的数据。如果没有输入可用，此方法将阻止
           //如何返回-1，表示读取完毕
           while((read = fileInputStream.read()) != -1){
               System.out.print((char)read);
           }
       }catch(IOException e){
           e.printStackTrace();
        }finally {
           //关闭文件流，释放资源
            try {
                fileInputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
import org.junit.jupiter.api.Test;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {
    }

    @Test
    //使用 read (byte[] b) 读取文件，提高效率
    public void readFile02() {
        String filePath = "D:\\Java IDea Code\\wenjian\\news3.txt";
        byte[] buffer = new byte[8];//一次读取8个字节
        int readlen = 0;
        FileInputStream fileInputStream = null;

        try{
            //创建 FileInputStream 对象 用于读取文件
            fileInputStream = new FileInputStream(filePath);

            //从该方法读取最多b.length 字节的数据到字节数组。
            //如果返回-1，表示读取完毕。
            //如果读取正常，返回实际读取的字节数。
            while((readlen = fileInputStream.read(buffer)) != -1){
                System.out.print(new String (buffer, 0, readlen));//显示
            }
        }catch(IOException e){
            e.printStackTrace();
        }finally{
            //关闭文件流，释放资源
            try{
                fileInputStream.close();
            }catch(IOException e){
                e.printStackTrace();
            }
        }
    }
}
```



#### FileOutputStream（字节输出流）

**常用方法：**

| 方法                                | 说明                 |
| ----------------------------------- | -------------------- |
| `write(int b)`                      | 写入一个字节         |
| `write(byte[] b)`                   | 写入字节数组         |
| `write(byte[] b, int off, int len)` | 写入字节数组的一部分 |
| `close()`                           | 关闭流               |

**两种模式：**

- `new FileOutputStream(path)` - 覆盖模式
- `new FileOutputStream(path, true)` - 追加模式

```java
import org.junit.jupiter.api.Test;

import java.io.*;

public class Main {
    public static void main(String[] args) {

    }

    //演示使用FileOutputStream将数据写到文件中
    //如果该文件不存在，则创建该文件
    @Test
    public void writeFile() {
        //创建FileOutputStream对象
        String filePath = "E:\\IDEA code JAVA\\wenjian\\news4.txt";
        FileOutputStream fileOutputStream = null;

        try {
            //new FileOutputStream(filePath)       创建方式，当写入内容时，会覆盖原来的内容
            fileOutputStream = new FileOutputStream(filePath);
            //new FileOutputStream(filePath，true) 创建方式，当写入内容时，会追加文件后面
            fileOutputStream = new FileOutputStream(filePath,true);
            //写入一个字节

            fileOutputStream.write('H');

            //写入字符串
            String str = "hello world";

            //str.getBytes() 可以把字符串->字节数组
            fileOutputStream.write(str.getBytes());

            //write(byte[] b,int off,int len)将 len 字节从位于偏移量 off 的指定字节数组写入此文件输出流
            fileOutputStream.write(str.getBytes(), 0, str.length());

        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                fileOutputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

#### 文件拷贝

```java
import org.junit.jupiter.api.Test;

import java.io.*;

public class Main {
    public static void main(String[] args) {

    }

    @Test
    public void writeFile() {
        //拷贝文件 将news4拷贝到new5文件中

        String srcfilePath = "E:\\IDEA code JAVA\\wenjian\\news4.txt";
        String destfilePath = "E:\\IDEA code JAVA\\wenjian\\news5.txt";

        FileInputStream fileInputStream = null;
        FileOutputStream fileOutputStream = null;

        try {
            fileInputStream = new FileInputStream(srcfilePath);
            fileOutputStream = new FileOutputStream(destfilePath);
            byte[] buffer = new byte[1024];
            int readLen = 0;
            while ((readLen = fileInputStream.read(buffer)) != -1) {
                //一边写一边读
                fileOutputStream.write(buffer, 0, readLen);
            }
            System.out.println("拷贝成功");
        } catch (IOException e) {
         e.printStackTrace();
        } finally{
            try {
                //关闭输出流和输入流 释放资源
                if(fileInputStream != null){
                    fileInputStream.close();
                }

                if(fileOutputStream != null){
                    fileOutputStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
}
```

### 4.2 文件字符流

#### FileReader（字符输入流）

**常用方法：**

| 方法                    | 说明           |
| ----------------------- | -------------- |
| `int read()`            | 读取单个字符   |
| `int read(char[] cbuf)` | 读取字符到数组 |
| `void close()`          | 关闭流         |

**辅助方法：**

- `new String(char[])` - 将char[]转换成String
- `new String(char[], off, len)` - 转换char[]的指定部分

**特点：**

- ⭐ 专门处理文本文件
- ⭐ 自动处理字符编码
- ⭐ 比字节流更方便处理文本



```java
import java.io.FileReader;
import java.io.IOException;

//单个字符读取文件
public class Main {
    public static void main(String[] args) {
        String filePath = "E:\\IDEA code JAVA\\wenjian\\news4.txt";
        FileReader fileReader = null;
        
        int data = ' ';
       
        try {
            fileReader  = new FileReader(filePath);
            //循环读取，使用read
            while((data = fileReader.read()) != -1){
                System.out.print((char)data);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                if(fileReader != null){
                    fileReader.close();
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

    }
}

//字符数组读取文件
import java.io.FileReader;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        String filePath = "E:\\IDEA code JAVA\\wenjian\\news4.txt";
        FileReader fileReader = null;

        int readLen = 0;
        char[] buf = new char[1024];

        try {
            fileReader  = new FileReader(filePath);
            //循环读取，使用read
            while((readLen = fileReader.read(buf)) != -1){
                System.out.print(new String(buf, 0, readLen));
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                if(fileReader != null){
                    fileReader.close();
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

    }
}
```



#### FileWriter（字符输出流）

**常用方法：**

| 方法                                   | 说明               |
| -------------------------------------- | ------------------ |
| `write(int c)`                         | 写入单个字符       |
| `write(char[] cbuf)`                   | 写入字符数组       |
| `write(char[] cbuf, int off, int len)` | 写入数组的一部分   |
| `write(String str)`                    | 写入字符串         |
| `write(String str, int off, int len)`  | 写入字符串的一部分 |
| `flush()`                              | 刷新缓冲区         |
| `close()`                              | 关闭流             |

**两种模式：**

- `new FileWriter(path)` - 覆盖模式
- `new FileWriter(path, true)` - 追加模式

**⚠️ 重要提示：**

- FileWriter使用后，必须要**关闭(close)或刷新(flush)**
- 否则数据不会写入文件！

```java
import java.io.FileWriter;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        String filePath = "E:\\IDEA code JAVA\\wenjian\\news1.txt";
        FileWriter fileWriter = null;

        char[] chars = {'a','b','c','d','e','f','g','h'};
        try {
            fileWriter = new FileWriter(filePath);//这里是覆盖写入
            //3)write(int):写入单个字符
            fileWriter.write('H');

            //4)write(char[]):写入指定数组
            fileWriter.write(chars);
            
            //5)write(char[],off,len):写入指定数组的指定部分
            fileWriter.write("木黑联盟".toCharArray(),0,3);
            
            //6)write(string):写入整个字符串
            fileWriter.write("你好北京");
            
            //7)write(string,off,len):写入字符串的指定部分,从0开始写入2个字符
            fileWriter.write("上海天津",0,2);
            
            //*数据量大的情况下，可以用循环
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            //FileWriter使用后，必须要关闭(close)或刷新(flush)
            try {
                fileWriter.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
```



---

## 五、节点流和处理流

### 5.1 节点流和处理流的概念

**节点流（Node Stream）：** 直接从数据源读写数据的流

**处理流（Wrapper Stream）：** 包装节点流，提供更强大的功能

**对比：**

| 特性     | 节点流                      | 处理流                                               |
| -------- | --------------------------- | ---------------------------------------------------- |
| **定义** | 直接连接数据源              | 包装其他流                                           |
| **功能** | 基本的读写操作              | 增强功能（缓冲、转换等）                             |
| **效率** | 一般                        | 更高                                                 |
| **示例** | FileInputStream、FileReader | BufferedInputStream、BufferedReader                  |
| **使用** | `new FileInputStream(file)` | `new BufferedInputStream(new FileInputStream(file))` |

**节点流一览表：**

| 分类       | 字节流                                     | 字符流                          |
| ---------- | ------------------------------------------ | ------------------------------- |
| **文件**   | FileInputStream/FileOutputStream           | FileReader/FileWriter           |
| **数组**   | ByteArrayInputStream/ByteArrayOutputStream | CharArrayReader/CharArrayWriter |
| **管道**   | PipedInputStream/PipedOutputStream         | PipedReader/PipedWriter         |
| **字符串** | -                                          | StringReader/StringWriter       |

**处理流一览表：**

| 分类     | 字节流                                   | 字符流                               | 功能          |
| -------- | ---------------------------------------- | ------------------------------------ | ------------- |
| **缓冲** | BufferedInputStream/BufferedOutputStream | BufferedReader/BufferedWriter        | 提高效率      |
| **转换** | -                                        | InputStreamReader/OutputStreamWriter | 字节流↔字符流 |
| **对象** | ObjectInputStream/ObjectOutputStream     | -                                    | 序列化        |
| **数据** | DataInputStream/DataOutputStream         | -                                    | 读写基本类型  |
| **打印** | PrintStream                              | PrintWriter                          | 便捷输出      |

**处理流的优势：**

1. ✅ **性能优化**：通过缓冲减少IO次数
2. ✅ **功能增强**：提供更多便捷方法（readLine、序列化等）
3. ✅ **统一接口**：装饰者模式，可以灵活组合
4. ✅ **简化操作**：更易用的API

**使用建议：**

- ⭐ 实际开发中推荐使用处理流
- ⭐ 处理流可以多层包装
- ⭐ 关闭最外层的处理流即可

### 5.2 缓冲流（Buffered Stream）

**为什么需要缓冲流？**

- 提高IO效率，减少磁盘访问次数
- 内置缓冲区，批量读写数据
- 性能可提升几百倍

**四个缓冲流类：**

| 类型     | 字节缓冲流           | 字符缓冲流     |
| -------- | -------------------- | -------------- |
| **输入** | BufferedInputStream  | BufferedReader |
| **输出** | BufferedOutputStream | BufferedWriter |

**特点：**

- ⭐ 提高效率（8KB默认缓冲区）
- ⭐ 提供额外方法（如readLine()、newLine()）
- ⭐ 关闭外层流会自动关闭内层流

**缓冲原理：**

```
不使用缓冲：每次read()都访问磁盘 → 1000次IO操作
使用缓冲：一次读取8KB到内存 → 约2次IO操作
性能提升：500倍！
```

#### BufferedReader 和 BufferedWriter

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
* 演示 BufferedReader 使用
*/

public class BufferedReader_ {
    public static void main(String[] args) throws Exception {
        String filePath = "e:\\a.java";
        //创建 bufferedReader
        BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath));

        //读取
        String line; //按行读取, 效率高
        
        //说明
        //1. bufferedReader.readLine() 是按行读取文件
        //2. 当返回 null 时，表示文件读取完毕
        while ((line = bufferedReader.readLine()) != null) {
            System.out.println(line);
        }
        
        //关闭流, 这里注意，只需要关闭 BufferedReader ，因为底层会自动的去关闭 节点流
        //FileReader。
        /*public void close() throws IOException {
            synchronized (lock) {
                if (in == null)
                    return;
                try {
                    in.close();//in 就是我们传入的 new FileReader(filePath), 关闭了. 
                } finally {
                    in = null;
                    cb = null;
                }
            }
        }*/
        bufferedReader.close();
    }
}

```

> 使用BufferedWriter “将hello，懿轩！”，写入到文件中
> BufferedWriter.java

```java
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
/**
 * 演示 BufferedWriter 的使用
 */
public class BufferedWriter_ {
    public static void main(String[] args) throws IOException {
        String filePath = "e:\\ok.txt";
        //创建 BufferedWriter
        //说明:
        //1. new FileWriter(filePath, true) 表示以追加的方式写入
        //2. new FileWriter(filePath) , 表示以覆盖的方式写入
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(filePath));
        bufferedWriter.write("hello, 懿轩!");
        bufferedWriter.newLine();//插入一个和系统相关的换行
        bufferedWriter.write("hello2, 懿轩!");
        bufferedWriter.newLine();
        bufferedWriter.write("hello3, 懿轩!");
        bufferedWriter.newLine();
        
        //说明：关闭外层流即可 ， 传入的 new FileWriter(filePath) ,会在底层关闭
        bufferedWriter.close();
    }
}
```

> 综合使用BufferedReader 和 BufferedWriter 完成 文本文件拷贝，注意文件编码 
>
> BufferedCopy_.java

```java
import java.io.*;

public class BufferedCopy_ {
    public static void main(String[] args) {
        //说明
        //1. BufferedReader 和 BufferedWriter 是安装字符操作
        //2. 不要去操作 二进制文件[声音，视频，doc, pdf ], 可能造成文件损坏
        //BufferedInputStream
        //BufferedOutputStream
        String srcFilePath = "e:\\a.java";
        String destFilePath = "e:\\a2.java";
        // String srcFilePath = "e:\\0245_懿轩零基础学 Java_引出 this.avi";
        // String destFilePath = "e:\\a2 懿轩.avi";
        BufferedReader br = null;
        BufferedWriter bw = null;
        String line;
        try {
            br = new BufferedReader(new FileReader(srcFilePath));
            bw = new BufferedWriter(new FileWriter(destFilePath));
        //说明: readLine 读取一行内容，但是没有换行
            while ((line = br.readLine()) != null) {
        //每读取一行，就写入
                bw.write(line);
        //插入一个换行
                bw.newLine();
            }
            System.out.println("拷贝完毕...");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭流
            try {
                if(br != null) {
                    br.close();
                }
                if(bw != null) {
                    bw.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```



#### BufferedInputStream 和 BufferedOutputStream

**字节缓冲流：** 用于提高字节流的读写效率

**特点：**

- 📦 内置8KB缓冲区
- 📦 减少磁盘访问次数
- 📦 适合处理大文件

**使用方式：**

```java
// 包装FileInputStream
BufferedInputStream bis = new BufferedInputStream(new FileInputStream("file.dat"));

// 包装FileOutputStream
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("file.dat"));
```



```java
import java.io.*;
/**
 * 演示使用 BufferedOutputStream 和 BufferedInputStream 使用
 * 使用他们，可以完成二进制文件拷贝. * 思考：字节流可以操作二进制文件，可以操作文本文件吗？当然可以
 */
public class BufferedCopy02 {
    public static void main(String[] args) {
        // String srcFilePath = "e:\\Koala.jpg";
        // String destFilePath = "e:\\hsp.jpg";
        // String srcFilePath = "e:\\0245_懿轩零基础学 Java_引出 this.avi";
        // String destFilePath = "e:\\hsp.avi";
        String srcFilePath = "e:\\a.java";
        String destFilePath = "e:\\a3.java";
        //创建 BufferedOutputStream 对象 BufferedInputStream 对象
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;
        try {
            //因为 FileInputStream 是 InputStream 子类
            bis = new BufferedInputStream(new FileInputStream(srcFilePath));
            bos = new BufferedOutputStream(new FileOutputStream(destFilePath));
            //循环的读取文件，并写入到 destFilePath
            byte[] buff = new byte[1024];
            int readLen = 0;
            //当返回 -1 时，就表示文件读取完毕
            while ((readLen = bis.read(buff)) != -1) {
                bos.write(buff, 0, readLen);
            }
            System.out.println("文件拷贝完毕~~~");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭流 , 关闭外层的处理流即可，底层会去关闭节点流
            try {
                if(bis != null) {
                    bis.close();
                }
                if(bos != null) {
                    bos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

---

### 5.3 对象流（Object Stream）

**对象流：** 用于对象的序列化和反序列化（处理流的一种）

**核心概念：**

| 概念                 | 说明                                       |
| -------------------- | ------------------------------------------ |
| **序列化**           | 将对象转换为字节流（保存到文件或网络传输） |
| **反序列化**         | 将字节流还原为对象                         |
| **Serializable**     | 标记接口，表示该类可以序列化               |
| **serialVersionUID** | 序列化版本号，用于版本控制                 |

**两个对象流类：**

| 类                   | 功能                 | 继承关系         |
| -------------------- | -------------------- | ---------------- |
| `ObjectOutputStream` | 序列化对象到字节流   | 继承OutputStream |
| `ObjectInputStream`  | 反序列化字节流为对象 | 继承InputStream  |

**序列化要求：**

1. ⭐ 类必须实现Serializable接口（标记接口）
2. ⭐ 类的所有属性都必须可序列化（或用transient修饰）
3. ⭐ 静态属性不会被序列化（属于类，不属于对象）
4. ⭐ 建议声明serialVersionUID（防止版本冲突）

**transient关键字：**

```java
class User implements Serializable {
    private String username;
    private transient String password;  // 不会被序列化
    private static String company;      // 静态属性不会被序列化
}
```

**应用场景：**

- 💾 保存对象到文件（游戏存档、缓存）
- 🌐 网络传输对象（RMI、Socket通信）
- 📦 对象持久化（数据库存储）
- 📋 深拷贝对象

#### ObjectOutputStream（序列化）

**常用方法：**

| 方法                      | 说明        |
| ------------------------- | ----------- |
| `writeObject(Object obj)` | 序列化对象  |
| `writeInt(int v)`         | 写入int     |
| `writeBoolean(boolean v)` | 写入boolean |
| `writeUTF(String str)`    | 写入字符串  |
| `close()`                 | 关闭流      |

**示例代码：**

```java
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

/**
 * 演示 ObjectOutputStream 的使用, 完成数据的序列化
 */
public class ObjectOutStream_ {
    public static void main(String[] args) throws Exception {
        String filePath = "e:\\data.dat";
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath));
        
        // 序列化基本类型
        oos.writeInt(100);
        oos.writeBoolean(true);
        oos.writeChar('a');
        oos.writeDouble(9.5);
        oos.writeUTF("懿轩");
        
        // 序列化对象
        oos.writeObject(new Dog("旺财", 10));
        oos.close();
        System.out.println("序列化完成");
    }
}

// Dog类必须实现Serializable
class Dog implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name;
    private int age;
    
    public Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

#### ObjectInputStream（反序列化）

**常用方法：**

| 方法            | 说明         |
| --------------- | ------------ |
| `readObject()`  | 反序列化对象 |
| `readInt()`     | 读取int      |
| `readBoolean()` | 读取boolean  |
| `readUTF()`     | 读取字符串   |
| `close()`       | 关闭流       |

**示例代码：**

```java
import java.io.FileInputStream;
import java.io.ObjectInputStream;

/**
 * 演示 ObjectInputStream 的使用, 完成数据的反序列化
 */
public class ObjectInputStream_ {
    public static void main(String[] args) throws Exception {
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("e:\\data.dat"));
        
        // 反序列化，读取顺序必须与写入顺序一致
        System.out.println(ois.readInt());      // 100
        System.out.println(ois.readBoolean());  // true
        System.out.println(ois.readChar());     // a
        System.out.println(ois.readDouble());   // 9.5
        System.out.println(ois.readUTF());      // 懿轩
        
        // 反序列化对象
        Dog dog = (Dog) ois.readObject();
        System.out.println(dog);
        
        ois.close();
        System.out.println("反序列化完成");
    }
}
```

**关键点总结：**

- ✅ 读取顺序必须与写入顺序一致
- ✅ 对象必须实现Serializable接口
- ✅ 建议添加serialVersionUID
- ✅ 可以序列化多个对象到同一个文件

**注意事项：**

- ⚠️ 序列化保存的是对象的状态，不包括方法
- ⚠️ 父类也要实现Serializable，否则父类属性不会被序列化
- ⚠️ 修改类结构后，serialVersionUID要保持一致
- ⚠️ 反序列化不会调用构造方法



---

## 六、其他常用流

### 6.1 标准输入输出流

**Java提供的标准流：**

| 流           | 类型        | 说明                 |
| ------------ | ----------- | -------------------- |
| `System.in`  | InputStream | 标准输入流（键盘）   |
| `System.out` | PrintStream | 标准输出流（控制台） |
| `System.err` | PrintStream | 标准错误流（控制台） |

**示例：**

```java
// 从键盘读取输入
Scanner scanner = new Scanner(System.in);
String input = scanner.nextLine();

// 输出到控制台
System.out.println("Hello World");

// 重定向输出到文件
System.setOut(new PrintStream("output.txt"));
System.out.println("输出到文件");
```

### 6.2 转换流（InputStreamReader/OutputStreamWriter）

**作用：** 字节流和字符流之间的桥梁，可以指定字符编码

**为什么需要转换流？**

- 解决字符编码问题（GBK、UTF-8等）
- 字节流→字符流转换

**两个转换流：**

| 类                   | 功能                  | 用途           |
| -------------------- | --------------------- | -------------- |
| `InputStreamReader`  | 字节输入流→字符输入流 | 读取时指定编码 |
| `OutputStreamWriter` | 字符输出流→字节输出流 | 写入时指定编码 |

**乱码问题示例：**

```java
import java.io.*;
/**
 * 看一个中文乱码问题
 */
public class CodeQuestion {
    public static void main(String[] args) throws IOException {
        //读取 e:\\a.txt 文件到程序
        //思路
        //1. 创建字符输入流 BufferedReader [处理流]
        //2. 使用 BufferedReader 对象读取 a.txt
        //3. 默认情况下，读取文件是按照 utf-8 编码
        String filePath = "e:\\a.txt";
        BufferedReader br = new BufferedReader(new FileReader(filePath));
        String s = br.readLine();
        System.out.println("读取到的内容: " + s);
        br.close();
        //InputStreamReader
        //OutputStreamWriter
    }
}
```



**解决方案：使用转换流指定编码**

```java
import java.io.*;
/**
 * 演示使用 InputStreamReader 转换流解决中文乱码问题
 * 将字节流 FileInputStream 转成字符流 InputStreamReader, 指定编码 gbk/utf-8
 */
public class InputStreamReader_ {
    public static void main(String[] args) throws IOException {
        String filePath = "e:\\a.txt";
        //解读
        //1. 把 FileInputStream 转成 InputStreamReader
        //2. 指定编码 gbk
        //InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath), "gbk");
        //3. 把 InputStreamReader 传入 BufferedReader
        //BufferedReader br = new BufferedReader(isr);
        //将 2 和 3 合在一起
        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(filePath), "gbk"));
        //4. 读取
        String s = br.readLine();
        System.out.println("读取内容=" + s);
        //5. 关闭外层流
        br.close();
    }
}
```



**OutputStreamWriter示例：**

```java
// 1.创建流对象，指定GBK编码
OutputStreamWriter osw = new OutputStreamWriter(
    new FileOutputStream("d:\\a.txt"), "GBK"
);
// 2.写入
osw.write("hello,懿轩~");
// 3.关闭
osw.close();
System.out.println("保存成功~");
```

### 6.3 打印流（PrintStream/PrintWriter）

**特点：**

- ⭐ 只有输出流，没有输入流
- ⭐ 不会抛出IOException
- ⭐ 自动flush
- ⭐ 可以直接输出各种数据类型

**两个打印流：**

| 类            | 类型       | 说明                      |
| ------------- | ---------- | ------------------------- |
| `PrintStream` | 字节打印流 | System.out就是PrintStream |
| `PrintWriter` | 字符打印流 | 推荐使用                  |

**常用方法：**

- `print()` - 输出不换行
- `println()` - 输出并换行
- `printf()` - 格式化输出

```java
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
/**
 * 演示 PrintWriter 使用方式
 */
public class PrintWriter_ {
    public static void main(String[] args) throws IOException {
        //PrintWriter printWriter = new PrintWriter(System.out);
        PrintWriter printWriter = new PrintWriter(new FileWriter("e:\\f2.txt"));
        printWriter.print("hi, 北京你好~~~~");
        printWriter.close();//flush + 关闭流, 才会将数据写入到文件..
    }
}
```

```java
import java.io.IOException;
import java.io.PrintStream;

/**
 * 演示 PrintStream （字节打印流/输出流）
 */
public class PrintStream_ {
    public static void main(String[] args) throws IOException {
        PrintStream out = System.out;
        //在默认情况下，PrintStream 输出数据的位置是 标准输出，即显示器
        /*
        public void print(String s) {
            if (s == null) {
                s = "null";
            }
            write(s);
        }
        */
        out.print("john, hello");
        //因为 print 底层使用的是 write , 所以我们可以直接调用 write 进行打印/输出
        out.write("懿轩,你好".getBytes());
        out.close();
        //我们可以去修改打印流输出的位置/设备
        //1. 输出修改成到 "e:\\f1.txt"
        //2. "hello, 懿轩~" 就会输出到 e:\f1.txt
        //3.  public static void setOut(PrintStream out) {
        // checkIO();
        // setOut0(out); // native 方法，修改了 out
        // }
        System.setOut(new PrintStream("e:\\f1.txt"));
        System.out.println("hello, 懿轩~");
    }
}
```

### 6.4 Properties类

**Properties类：** 专门用于读写配置文件的类

**配置文件格式：**

```properties
# 键值对形式
key=value
username=admin
password=123456
```

**常用方法：**

| 方法                                           | 说明                   |
| ---------------------------------------------- | ---------------------- |
| `load(InputStream)`                            | 加载配置文件           |
| `load(Reader)`                                 | 加载配置文件           |
| `getProperty(String key)`                      | 获取属性值             |
| `getProperty(String key, String defaultValue)` | 获取属性值（带默认值） |
| `setProperty(String key, String value)`        | 设置属性值             |
| `store(OutputStream, String comments)`         | 保存到文件             |
| `list(PrintStream)`                            | 打印所有属性           |

**特点：**

- 📝 键值对存储
- 📝 持久化配置信息
- 📝 父类是Hashtable

```java
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Properties01 {
    public static void main(String[] args) throws IOException {
		//读取 mysql.properties 文件，并得到 ip, user 和 pwd
        BufferedReader br = new BufferedReader(new FileReader("src\\mysql.properties"));
        String line = "";
        while ((line = br.readLine()) != null) { //循环读取
            String[] split = line.split("=");
			//如果我们要求指定的 ip 值
            if("ip".equals(split[0])) {
                System.out.println(split[0] + "值是: " + split[1]);
            }
        }
        br.close();
    }
}
```

**读取配置文件示例：**

```java
import java.io.FileReader;
import java.io.IOException;
import java.util.Properties;

public class Properties02 {
    public static void main(String[] args) throws IOException {
        //使用 Properties 类来读取 mysql.properties 文件
        //1. 创建 Properties 对象
        Properties properties = new Properties();
        //2. 加载指定配置文件
        properties.load(new FileReader("src\\mysql.properties"));
        //3. 把 k-v 显示控制台
        properties.list(System.out);
        //4. 根据 key 获取对应的值
        String user = properties.getProperty("user");
        String pwd = properties.getProperty("pwd");
        System.out.println("用户名=" + user);
        System.out.println("密码是=" + pwd);
    }
}
```

```Java
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;

public class Properties03 {
    public static void main(String[] args) throws IOException {
        //使用 Properties 类来创建 配置文件, 修改配置文件内容
        Properties properties = new Properties();
        //创建或修改
        properties.setProperty("charset", "utf8");
        properties.setProperty("user", "汤姆"); 
        properties.setProperty("pwd", "888888");
        //保存到文件
        properties.store(new FileOutputStream("src\\mysql2.properties"), null);
        System.out.println("保存配置文件成功~");
    }
}
```

---

## 七、面试常见问题

### Q1: 字节流和字符流的区别？

**答案：**

| 特性         | 字节流                   | 字符流             |
| ------------ | ------------------------ | ------------------ |
| **基本单位** | 字节（byte，8位）        | 字符（char，16位） |
| **基类**     | InputStream/OutputStream | Reader/Writer      |
| **适用场景** | 所有文件（二进制）       | 文本文件           |
| **编码处理** | 不处理                   | 自动处理字符编码   |
| **典型应用** | 图片、音频、视频         | txt、java、xml     |

**选择原则：**

- 处理文本文件 → 字符流
- 处理二进制文件 → 字节流

---

### Q2: 什么是节点流和处理流？

**答案：**

| 类型     | 节点流                      | 处理流                                               |
| -------- | --------------------------- | ---------------------------------------------------- |
| **定义** | 直接操作数据源              | 包装节点流                                           |
| **示例** | FileInputStream             | BufferedInputStream                                  |
| **功能** | 基本读写                    | 增强功能（缓冲、转换等）                             |
| **使用** | `new FileInputStream(file)` | `new BufferedInputStream(new FileInputStream(file))` |

**处理流的优势：**

1. ✅ 提高性能（缓冲机制）
2. ✅ 增强功能（readLine、序列化等）
3. ✅ 统一接口（装饰者模式）

---

### Q3: 为什么要使用缓冲流？

**答案：**

**原因：** 提高IO效率

**对比：**

```java
// ❌ 低效：每次读取1个字节
FileInputStream fis = new FileInputStream("file.txt");
int data;
while ((data = fis.read()) != -1) {
    // 每次读取都访问磁盘
}

// ✅ 高效：使用缓冲流
BufferedInputStream bis = new BufferedInputStream(new FileInputStream("file.txt"));
int data;
while ((data = bis.read()) != -1) {
    // 从缓冲区读取，减少磁盘访问
}
```

**性能对比：**

- 不使用缓冲：1000次磁盘访问
- 使用缓冲（8KB）：约2次磁盘访问
- 性能提升：500倍！

---

### Q4: 什么是序列化和反序列化？

**答案：**

| 概念         | 说明          | 用途                 |
| ------------ | ------------- | -------------------- |
| **序列化**   | 对象 → 字节流 | 保存到文件或网络传输 |
| **反序列化** | 字节流 → 对象 | 从文件或网络恢复对象 |

**实现步骤：**

```java
// 1. 类实现Serializable接口
class User implements Serializable {
    private String name;
    private int age;
}

// 2. 序列化
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("user.dat"));
oos.writeObject(new User("张三", 20));

// 3. 反序列化
ObjectInputStream ois = new ObjectInputStream(new FileInputStream("user.dat"));
User user = (User) ois.readObject();
```

**注意事项：**

- 类必须实现Serializable接口
- transient修饰的属性不会被序列化
- static属性不会被序列化
- 建议声明serialVersionUID

---

### Q5: 如何解决中文乱码问题？

**答案：**

**方法一：使用转换流指定编码**

```java
// 读取GBK编码的文件
InputStreamReader isr = new InputStreamReader(
    new FileInputStream("file.txt"), "GBK"
);
BufferedReader br = new BufferedReader(isr);

// 写入UTF-8编码的文件
OutputStreamWriter osw = new OutputStreamWriter(
    new FileOutputStream("file.txt"), "UTF-8"
);
BufferedWriter bw = new BufferedWriter(osw);
```

**方法二：使用字符流时指定编码**

```java
// JDK 11+
FileReader fr = new FileReader("file.txt", Charset.forName("GBK"));
FileWriter fw = new FileWriter("file.txt", Charset.forName("UTF-8"));
```

---

### Q6: IO流的关闭顺序是什么？

**答案：**

**原则：** 先开后关，后开先关

```java
FileInputStream fis = null;
BufferedInputStream bis = null;
try {
    fis = new FileInputStream("file.txt");  // 1. 先开
    bis = new BufferedInputStream(fis);      // 2. 后开
    
    // 读取数据
} finally {
    // 4. 后开先关
    if (bis != null) bis.close();   // 关闭处理流会自动关闭节点流
    // 实际上只需要关闭bis即可
}
```

**简化写法（JDK 7+）：**

```java
try (FileInputStream fis = new FileInputStream("file.txt");
     BufferedInputStream bis = new BufferedInputStream(fis)) {
    // 自动关闭资源
}
```

---

### Q7: Properties类的作用是什么？

**答案：**

**作用：** 读写配置文件（.properties）

**常用方法：**

| 方法                                    | 说明         |
| --------------------------------------- | ------------ |
| `load(InputStream)`                     | 加载配置文件 |
| `getProperty(String key)`               | 获取属性值   |
| `setProperty(String key, String value)` | 设置属性值   |
| `store(OutputStream, String comments)`  | 保存到文件   |

**使用场景：**

- 📝 数据库配置
- 📝 应用程序配置
- 📝 国际化资源

---

### Q8: 如何高效地复制文件？

**答案：**

**推荐方式：使用缓冲字节流**

```java
public static void copyFile(String src, String dest) {
    try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));
         BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dest))) {
        
        byte[] buffer = new byte[8192];  // 8KB缓冲区
        int len;
        while ((len = bis.read(buffer)) != -1) {
            bos.write(buffer, 0, len);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

**性能对比：**

1. 字节流 + 无缓冲：慢
2. 字节流 + 小缓冲（1KB）：较快
3. 字节流 + 大缓冲（8KB）：快
4. 缓冲流 + 缓冲数组：最快 ⭐

---

**上一章：** [多线程](06-多线程.md)

**下一章：** [反射](08-反射.md) →

