# 面向对象编程 - 高级

> **本章重点：** static关键字、代码块、单例模式、final、抽象类、接口、内部类
> 
> **面试频率：** ⭐⭐⭐⭐⭐

---

## 目录
- [一、static关键字](#一static关键字)
- [二、代码块](#二代码块)
- [三、单例设计模式](#三单例设计模式)
- [四、final关键字](#四final关键字)
- [五、抽象类](#五抽象类)
- [六、接口](#六接口)
- [七、内部类](#七内部类)
- [八、面试常见问题](#八面试常见问题)

---

## 一、static关键字

### 1.1 类变量（静态变量）

**定义：** 使用 static 修饰的变量，被该类的所有对象共享。

**语法：**
```java
[访问修饰符] static 数据类型 变量名;  // 推荐
static [访问修饰符] 数据类型 变量名;
```

**示例：**
```java
class Student {
    private String name;
    private static int totalCount = 0;  // 类变量
    
    public Student(String name) {
        this.name = name;
        totalCount++;  // 每创建一个学生，总数加1
    }
    
    public static int getTotalCount() {
        return totalCount;
    }
}

// 使用
Student s1 = new Student("张三");
Student s2 = new Student("李四");
System.out.println(Student.getTotalCount());  // 2
```

### 1.2 类变量的访问

**两种访问方式：**
1. `类名.类变量名`（推荐）
2. `对象名.类变量名`

**示例：**
```java
class Student {
    public static int totalCount = 0;
}

// 方式一：类名访问（推荐）
System.out.println(Student.totalCount);

// 方式二：对象名访问
Student s = new Student();
System.out.println(s.totalCount);
```

### 1.3 类变量的特点

**1. 所有对象共享**
```java
class Student {
    public static int count = 0;
}

Student s1 = new Student();
Student s2 = new Student();
s1.count = 10;
System.out.println(s2.count);  // 10（共享同一个变量）
```

**2. 类加载时初始化**
```java
class Test {
    public static int num = 100;
}

// 即使不创建对象，也可以访问
System.out.println(Test.num);  // 100
```

**3. 生命周期长**
- 随类的加载而创建
- 随类的消亡而销毁

### 1.4 类方法（静态方法）

**定义：** 使用 static 修饰的方法。

**语法：**
```java
[访问修饰符] static 返回类型 方法名([参数列表]) {
    // 方法体
}
```

**示例：**
```java
class MathUtils {
    // 静态方法
    public static int add(int a, int b) {
        return a + b;
    }
    
    public static int max(int a, int b) {
        return a > b ? a : b;
    }
}

// 使用：不需要创建对象
int sum = MathUtils.add(10, 20);
int maximum = MathUtils.max(10, 20);
```

### 1.5 类方法的使用场景

**适用场景：**
1. 工具类方法（Math、Arrays）
2. 不需要访问对象属性的方法
3. 需要全局访问的方法

**示例：**
```java
class ArrayUtils {
    // 打印数组
    public static void printArray(int[] arr) {
        for (int num : arr) {
            System.out.print(num + " ");
        }
        System.out.println();
    }
    
    // 查找最大值
    public static int findMax(int[] arr) {
        int max = arr[0];
        for (int num : arr) {
            if (num > max) {
                max = num;
            }
        }
        return max;
    }
}
```

### 1.6 static的注意事项

**重要规则：**

| 特性 | 类方法（静态） | 普通方法 |
|------|---------------|----------|
| 访问类变量 | ✅ 可以 | ✅ 可以 |
| 访问实例变量 | ❌ 不可以 | ✅ 可以 |
| 调用类方法 | ✅ 可以 | ✅ 可以 |
| 调用实例方法 | ❌ 不可以 | ✅ 可以 |
| 使用 this | ❌ 不可以 | ✅ 可以 |
| 使用 super | ❌ 不可以 | ✅ 可以 |

**示例：**
```java
class Test {
    private int num1 = 10;           // 实例变量
    private static int num2 = 20;    // 类变量
    
    public static void staticMethod() {
        // System.out.println(num1);  // ❌ 错误：不能访问实例变量
        System.out.println(num2);     // ✅ 正确：可以访问类变量
        
        // this.method();  // ❌ 错误：不能使用 this
    }
    
    public void instanceMethod() {
        System.out.println(num1);  // ✅ 正确
        System.out.println(num2);  // ✅ 正确
        staticMethod();            // ✅ 正确
    }
}
```

---

## 二、代码块

### 2.1 代码块的概念

**定义：** 类中用 `{}` 包围的代码段，在特定时机自动执行。

**语法：**
```java
[修饰符] {
    // 代码
}
```

**分类：**
1. **静态代码块**：使用 static 修饰
2. **普通代码块**：不使用 static 修饰

### 2.2 静态代码块

**特点：**
- 在类加载时执行，且只执行一次
- 用于初始化类的静态资源
- 优先于构造器执行

**示例：**
```java
class Database {
    private static Connection conn;
    
    // 静态代码块：类加载时执行
    static {
        System.out.println("连接数据库...");
        // conn = DriverManager.getConnection(...);
    }
}
```

### 2.3 普通代码块

**特点：**
- 在创建对象时执行
- 每创建一个对象执行一次
- 在构造器之前执行

**示例：**
```java
class Movie {
    private String name;
    
    // 普通代码块：创建对象时执行
    {
        System.out.println("电影屏幕打开...");
        System.out.println("广告播放...");
    }
    
    public Movie(String name) {
        System.out.println("构造器被调用");
        this.name = name;
    }
}

// 输出：
// 电影屏幕打开...
// 广告播放...
// 构造器被调用
```

### 2.4 代码块的使用场景

**普通代码块的作用：**
- 提取多个构造器中的公共代码
- 减少代码冗余

**示例：**
```java
class Student {
    private String name;
    private int age;
    
    // 公共初始化代码
    {
        System.out.println("欢迎新学生！");
        System.out.println("分配学号...");
    }
    
    public Student(String name) {
        this.name = name;
    }
    
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

### 2.5 代码块的执行顺序

**执行顺序（重要！）：**

```
类加载阶段：
1. 父类的静态代码块和静态属性（按定义顺序）
2. 子类的静态代码块和静态属性（按定义顺序）

对象创建阶段：
3. 父类的普通代码块和普通属性（按定义顺序）
4. 父类的构造器
5. 子类的普通代码块和普通属性（按定义顺序）
6. 子类的构造器
```

**示例：**
```java
class Parent {
    private static int n1 = getN1();
    static {
        System.out.println("1. 父类静态代码块");
    }
    
    {
        System.out.println("3. 父类普通代码块");
    }
    
    public Parent() {
        System.out.println("4. 父类构造器");
    }
    
    public static int getN1() {
        System.out.println("0. 父类静态属性初始化");
        return 100;
    }
}

class Child extends Parent {
    private static int n2 = getN2();
    static {
        System.out.println("2. 子类静态代码块");
    }
    
    {
        System.out.println("5. 子类普通代码块");
    }
    
    public Child() {
        System.out.println("6. 子类构造器");
    }
    
    public static int getN2() {
        System.out.println("1.5. 子类静态属性初始化");
        return 200;
    }
}

// 测试
new Child();
```

---

## 三、单例设计模式

### 3.1 什么是单例模式

**定义：** 采取一定的方法保证整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个获取对象实例的方法。

**应用场景：**
- 数据库连接池
- 配置管理器
- 日志记录器
- Windows的任务管理器

### 3.2 单例模式的实现步骤

**三个关键步骤：**
1. 构造器私有化（防止 new）
2. 类的内部创建对象
3. 向外暴露一个静态的公共方法 `getInstance()`

### 3.3 饿汉式（推荐）

**特点：** 类加载时就创建对象。

**优点：** 线程安全，简单
**缺点：** 可能造成资源浪费

**代码实现：**
```java
class Singleton {
    // 1. 构造器私有化
    private Singleton() {
    }
    
    // 2. 类内部创建对象（类加载时创建）
    private static final Singleton instance = new Singleton();
    
    // 3. 提供公共的获取方法
    public static Singleton getInstance() {
        return instance;
    }
}

// 使用
Singleton s1 = Singleton.getInstance();
Singleton s2 = Singleton.getInstance();
System.out.println(s1 == s2);  // true（同一个对象）
```

### 3.4 懒汉式

**特点：** 使用时才创建对象。

**优点：** 节省资源（用时才创建）
**缺点：** 线程不安全（需要加锁）

**代码实现：**
```java
class Singleton {
    // 1. 构造器私有化
    private Singleton() {
    }
    
    // 2. 定义静态属性（初始为null）
    private static Singleton instance;
    
    // 3. 提供公共的获取方法（使用时才创建）
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

**线程安全的懒汉式：**
```java
class Singleton {
    private Singleton() {
    }
    
    private static Singleton instance;
    
    // 加锁保证线程安全
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### 3.5 饿汉式 vs 懒汉式

| 特性 | 饿汉式 | 懒汉式 |
|------|--------|--------|
| 创建时机 | 类加载时 | 第一次使用时 |
| 线程安全 | 安全 | 不安全（需加锁） |
| 资源利用 | 可能浪费 | 节省资源 |
| 推荐度 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |

**建议：** 一般情况下使用饿汉式！

---

## 四、final关键字

### 4.1 final的作用

**final：** 最终的、不可改变的。

**可以修饰：**
1. 类 - 不能被继承
2. 方法 - 不能被重写
3. 变量 - 不能被修改（常量）

### 4.2 final修饰类

**特点：** 该类不能被继承。

**示例：**
```java
final class FinalClass {
    // 类的内容
}

// class SubClass extends FinalClass { }  // ❌ 错误：不能继承final类
```

**实际应用：**
- `String` 类是 final 的
- 包装类（Integer、Double等）都是 final 的

### 4.3 final修饰方法

**特点：** 该方法不能被子类重写。

**示例：**
```java
class Parent {
    public final void show() {
        System.out.println("父类的final方法");
    }
}

class Child extends Parent {
    // @Override
    // public void show() { }  // ❌ 错误：不能重写final方法
}
```

### 4.4 final修饰变量

**特点：** 该变量变成常量，不能被修改。

**命名规范：** 全大写，多个单词用下划线分隔

**示例：**
```java
class Constants {
    public static final double PI = 3.14159;
    public static final int MAX_VALUE = 100;
    public static final String DB_URL = "jdbc:mysql://localhost:3306/test";
}

// 使用
System.out.println(Constants.PI);
// Constants.PI = 3.14;  // ❌ 错误：不能修改final变量
```

### 4.5 final变量的初始化

**final属性必须赋初值，可以在以下位置之一：**

**1. 定义时**
```java
class Test {
    private final int NUM = 10;
}
```

**2. 构造器中**
```java
class Test {
    private final int NUM;
    
    public Test(int num) {
        this.NUM = num;
    }
}
```

**3. 代码块中**
```java
class Test {
    private final int NUM;
    
    {
        NUM = 10;
    }
}
```

### 4.6 final的注意事项

**1. final + static 效率更高**
```java
class Test {
    public static final int NUM = 100;
}

// 访问时不会导致类初始化
System.out.println(Test.NUM);
```

**2. final不能修饰构造器**
```java
class Test {
    // public final Test() { }  // ❌ 错误
}
```

**3. final修饰引用类型**
```java
final int[] arr = {1, 2, 3};
arr[0] = 100;  // ✅ 可以修改数组元素
// arr = new int[5];  // ❌ 不能改变引用指向
```

---

## 五、抽象类

### 5.1 为什么需要抽象类

**问题场景：**
- 父类的某些方法需要声明，但不确定如何实现
- 不同的子类有不同的实现方式

**解决方案：** 抽象类 + 抽象方法

### 5.2 抽象类的定义

**语法：**
```java
abstract class 类名 {
    // 普通属性
    // 普通方法
    // 抽象方法
    abstract 返回类型 方法名([参数列表]);
}
```

**示例：**
```java
abstract class Animal {
    private String name;
    
    // 普通方法
    public void sleep() {
        System.out.println(name + "在睡觉");
    }
    
    // 抽象方法（没有方法体）
    abstract public void eat();
    abstract public void cry();
}
```

### 5.3 抽象类的使用

**子类必须实现所有抽象方法：**
```java
class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("狗吃骨头");
    }
    
    @Override
    public void cry() {
        System.out.println("汪汪汪");
    }
}

class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("猫吃鱼");
    }
    
    @Override
    public void cry() {
        System.out.println("喵喵喵");
    }
}
```

### 5.4 抽象类的注意事项

**重要规则：**

| 特性 | 说明 |
|------|------|
| 不能实例化 | `new Animal()` ❌ |
| 可以没有抽象方法 | 但有抽象方法必须是抽象类 |
| 可以有构造器 | 用于子类调用 |
| 可以有普通成员 | 属性、方法、代码块等 |
| 抽象方法不能有方法体 | `abstract void eat() { }` ❌ |
| 不能用private修饰 | 抽象方法需要被重写 |
| 不能用final修饰 | final和abstract矛盾 |
| 不能用static修饰 | static和abstract矛盾 |

---

## 六、接口

### 6.1 接口的概念

**接口（Interface）：** 给出一些没有实现的方法，由实现类根据具体情况实现。

**作用：**
- 定义规范
- 实现多继承的效果
- 降低耦合度

### 6.2 接口的定义和实现

**定义接口：**
```java
interface 接口名 {
    // 常量（public static final）
    // 抽象方法（public abstract）
    // 默认方法（JDK 8+）
    // 静态方法（JDK 8+）
}
```

**实现接口：**
```java
class 类名 implements 接口1, 接口2 {
    // 实现所有抽象方法
}
```

**示例：**
```java
interface Flyable {
    // 常量（自动加 public static final）
    int MAX_SPEED = 1000;
    
    // 抽象方法（自动加 public abstract）
    void fly();
}

interface Swimmable {
    void swim();
}

// 实现多个接口
class Duck implements Flyable, Swimmable {
    @Override
    public void fly() {
        System.out.println("鸭子在飞");
    }
    
    @Override
    public void swim() {
        System.out.println("鸭子在游泳");
    }
}
```

### 6.3 接口的特性

**JDK 8 新特性：**

**1. 默认方法（default）**
```java
interface MyInterface {
    // 默认方法（有方法体）
    default void show() {
        System.out.println("默认方法");
    }
}
```

**2. 静态方法**
```java
interface MyInterface {
    // 静态方法
    static void print() {
        System.out.println("静态方法");
    }
}

// 调用
MyInterface.print();
```

### 6.4 接口的注意事项

**重要规则：**

| 特性 | 说明 |
|------|------|
| 不能实例化 | `new Flyable()` ❌ |
| 方法默认public abstract | 可以省略 |
| 属性默认public static final | 必须初始化 |
| 一个类可以实现多个接口 | `implements A, B, C` |
| 接口可以继承多个接口 | `interface A extends B, C` |
| 实现类必须实现所有抽象方法 | 否则必须是抽象类 |

---

## 七、内部类

### 7.1 内部类的概念

**内部类：** 一个类的内部又完整地嵌套了另一个类结构。

**特点：**
- 可以直接访问外部类的私有成员
- 体现类与类之间的包含关系

**语法：**
```java
class Outer {  // 外部类
    class Inner {  // 内部类
    }
}
```

### 7.2 内部类的分类

**1. 局部位置（方法内）：**
- 局部内部类（有类名）
- 匿名内部类（没有类名，重点！）

**2. 成员位置：**
- 成员内部类（没用static修饰）
- 静态内部类（使用static修饰）

### 7.3 匿名内部类（重要！）

**特点：**
- 本质是类
- 内部类
- 没有名字
- 同时是一个对象

**语法：**
```java
new 类或接口(参数列表) {
    // 类体
};
```

**示例一：基于接口**
```java
interface Flyable {
    void fly();
}

class Test {
    public void test() {
        // 匿名内部类
        Flyable bird = new Flyable() {
            @Override
            public void fly() {
                System.out.println("鸟在飞");
            }
        };
        
        bird.fly();
    }
}
```

**示例二：基于类**
```java
class Animal {
    public void eat() {
        System.out.println("动物在吃东西");
    }
}

class Test {
    public void test() {
        // 匿名内部类（继承Animal并重写方法）
        Animal dog = new Animal() {
            @Override
            public void eat() {
                System.out.println("狗在吃骨头");
            }
        };
        
        dog.eat();
    }
}
```

### 7.4 匿名内部类的应用

**场景：** 作为方法参数

```java
interface Comparable {
    int compare(int a, int b);
}

class Sorter {
    public void sort(int[] arr, Comparable comp) {
        // 使用comp进行排序
    }
}

// 使用
Sorter sorter = new Sorter();
sorter.sort(arr, new Comparable() {
    @Override
    public int compare(int a, int b) {
        return a - b;  // 升序
    }
});
```

---

## 八、面试常见问题

### Q1: static关键字的作用？

**答案：**

**作用：**
1. 修饰变量：类变量（所有对象共享）
2. 修饰方法：类方法（不需要对象就能调用）
3. 修饰代码块：静态代码块（类加载时执行）
4. 静态导入：`import static`

**特点：**
- 类加载时初始化
- 所有对象共享
- 可以通过类名直接访问

---

### Q2: 饿汉式和懒汉式单例的区别？

**答案：**

| 特性 | 饿汉式 | 懒汉式 |
|------|--------|--------|
| 创建时机 | 类加载时 | 第一次使用时 |
| 线程安全 | 安全 | 不安全（需加锁） |
| 资源利用 | 可能浪费 | 节省资源 |
| 实现难度 | 简单 | 较复杂 |

---

### Q3: final关键字的作用？

**答案：**

1. **修饰类**：不能被继承（如String）
2. **修饰方法**：不能被重写
3. **修饰变量**：不能被修改（常量）

**注意：**
- final变量必须初始化
- final + static 效率更高
- final不能修饰构造器

---

### Q4: 抽象类和接口的区别？

**答案：**

| 特性 | 抽象类 | 接口 |
|------|--------|------|
| 关键字 | abstract class | interface |
| 继承 | 单继承 | 多实现 |
| 方法 | 可以有普通方法 | JDK 8前只能有抽象方法 |
| 变量 | 各种变量 | 只能是常量 |
| 构造器 | 可以有 | 不能有 |
| 设计理念 | "是什么"（is-a） | "能做什么"（can-do） |

---

### Q5: 什么时候使用抽象类，什么时候使用接口？

**答案：**

**使用抽象类：**
- 有共同的属性和方法
- 需要使用构造器
- 强调"是什么"的关系

**使用接口：**
- 定义规范和能力
- 需要多继承
- 强调"能做什么"

**建议：** 优先使用接口！

---

**上一章：** [面向对象中级](02-面向对象中级（优化版）.md)

**下一章：** [枚举与注解](../3.JAVA提高编程/01-枚举与注解（优化版）.md) →
