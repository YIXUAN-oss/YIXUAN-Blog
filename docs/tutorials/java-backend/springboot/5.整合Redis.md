---
title: 整合Redis
---

# 整合Redis

## 一、Redis简介

### 1.1 什么是Redis？

**Redis** 是一个开源的内存数据结构存储系统，可以用作数据库、缓存和消息中间件。

**特点：**
- 性能极高（读11万次/s，写8万次/s）
- 支持多种数据类型
- 支持数据持久化
- 支持主从复制

### 1.2 应用场景

- ✅ **缓存** - 热点数据缓存
- ✅ **Session共享** - 分布式Session
- ✅ **分布式锁** - 保证并发安全
- ✅ **消息队列** - 发布订阅
- ✅ **排行榜** - Sorted Set

---

## 二、整合Redis

### 2.1 添加依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

<!-- Lettuce 客户端（默认） -->
<dependency>
    <groupId>io.lettuce</groupId>
    <artifactId>lettuce-core</artifactId>
</dependency>

<!-- 连接池 -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>
```

### 2.2 配置Redis

```yaml
spring:
  redis:
    host: localhost
    port: 6379
    password:                    # 密码
    database: 0                  # 数据库索引（0-15）
    timeout: 3000                # 连接超时时间
    
    lettuce:
      pool:
        max-active: 8            # 最大连接数
        max-idle: 8              # 最大空闲连接
        min-idle: 0              # 最小空闲连接
        max-wait: -1ms           # 最大等待时间
```

### 2.3 Redis配置类

```java
@Configuration
public class RedisConfig {
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate(
            RedisConnectionFactory factory) {
        
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        
        // JSON 序列化配置
        Jackson2JsonRedisSerializer<Object> serializer = 
                new Jackson2JsonRedisSerializer<>(Object.class);
        
        ObjectMapper mapper = new ObjectMapper();
        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        mapper.activateDefaultTyping(
            mapper.getPolymorphicTypeValidator(),
            ObjectMapper.DefaultTyping.NON_FINAL
        );
        serializer.setObjectMapper(mapper);
        
        // String 序列化
        StringRedisSerializer stringSerializer = new StringRedisSerializer();
        
        // key 采用 String 序列化
        template.setKeySerializer(stringSerializer);
        template.setHashKeySerializer(stringSerializer);
        
        // value 采用 JSON 序列化
        template.setValueSerializer(serializer);
        template.setHashValueSerializer(serializer);
        
        template.afterPropertiesSet();
        return template;
    }
}
```

---

## 三、RedisTemplate使用

### 3.1 String 操作

```java
@Service
public class RedisService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // 设置值
    public void set(String key, Object value) {
        redisTemplate.opsForValue().set(key, value);
    }
    
    // 设置值（带过期时间）
    public void set(String key, Object value, long timeout, TimeUnit unit) {
        redisTemplate.opsForValue().set(key, value, timeout, unit);
    }
    
    // 获取值
    public Object get(String key) {
        return redisTemplate.opsForValue().get(key);
    }
    
    // 删除
    public Boolean delete(String key) {
        return redisTemplate.delete(key);
    }
    
    // 判断key是否存在
    public Boolean hasKey(String key) {
        return redisTemplate.hasKey(key);
    }
    
    // 设置过期时间
    public Boolean expire(String key, long timeout, TimeUnit unit) {
        return redisTemplate.expire(key, timeout, unit);
    }
    
    // 获取过期时间
    public Long getExpire(String key) {
        return redisTemplate.getExpire(key);
    }
}
```

### 3.2 Hash 操作

```java
// 设置 Hash
public void hSet(String key, String field, Object value) {
    redisTemplate.opsForHash().put(key, field, value);
}

// 获取 Hash
public Object hGet(String key, String field) {
    return redisTemplate.opsForHash().get(key, field);
}

// 获取所有字段
public Map<Object, Object> hGetAll(String key) {
    return redisTemplate.opsForHash().entries(key);
}

// 删除字段
public Long hDelete(String key, Object... fields) {
    return redisTemplate.opsForHash().delete(key, fields);
}
```

### 3.3 List 操作

```java
// 左侧推入
public Long lPush(String key, Object value) {
    return redisTemplate.opsForList().leftPush(key, value);
}

// 右侧推入
public Long rPush(String key, Object value) {
    return redisTemplate.opsForList().rightPush(key, value);
}

// 左侧弹出
public Object lPop(String key) {
    return redisTemplate.opsForList().leftPop(key);
}

// 获取列表
public List<Object> lRange(String key, long start, long end) {
    return redisTemplate.opsForList().range(key, start, end);
}
```

### 3.4 Set 操作

```java
// 添加元素
public Long sAdd(String key, Object... values) {
    return redisTemplate.opsForSet().add(key, values);
}

// 获取所有元素
public Set<Object> sMembers(String key) {
    return redisTemplate.opsForSet().members(key);
}

// 判断是否存在
public Boolean sIsMember(String key, Object value) {
    return redisTemplate.opsForSet().isMember(key, value);
}

// 移除元素
public Long sRemove(String key, Object... values) {
    return redisTemplate.opsForSet().remove(key, values);
}
```

### 3.5 Sorted Set 操作

```java
// 添加元素
public Boolean zAdd(String key, Object value, double score) {
    return redisTemplate.opsForZSet().add(key, value, score);
}

// 获取排名
public Long zRank(String key, Object value) {
    return redisTemplate.opsForZSet().rank(key, value);
}

// 获取范围（升序）
public Set<Object> zRange(String key, long start, long end) {
    return redisTemplate.opsForZSet().range(key, start, end);
}

// 获取范围（降序）
public Set<Object> zReverseRange(String key, long start, long end) {
    return redisTemplate.opsForZSet().reverseRange(key, start, end);
}
```

---

## 四、缓存注解

### 4.1 启用缓存

```java
@SpringBootApplication
@EnableCaching  // 启用缓存
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

### 4.2 @Cacheable

**查询时缓存：**
```java
@Service
public class UserService {
    
    @Cacheable(value = "user", key = "#id")
    public User findById(Long id) {
        System.out.println("从数据库查询：" + id);
        return userMapper.selectById(id);
    }
}
```

### 4.3 @CachePut

**更新缓存：**
```java
@CachePut(value = "user", key = "#user.id")
public User update(User user) {
    userMapper.updateById(user);
    return user;
}
```

### 4.4 @CacheEvict

**删除缓存：**
```java
@CacheEvict(value = "user", key = "#id")
public void deleteById(Long id) {
    userMapper.deleteById(id);
}

// 清空所有缓存
@CacheEvict(value = "user", allEntries = true)
public void deleteAll() {
    userMapper.deleteAll();
}
```

### 4.5 配置缓存

```yaml
spring:
  cache:
    type: redis
    redis:
      time-to-live: 600000     # 缓存过期时间（毫秒）
      cache-null-values: true  # 缓存null值
```

---

## 五、分布式锁

### 5.1 实现分布式锁

```java
@Component
public class RedisLock {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 获取锁
     * @param key 锁的key
     * @param value 锁的值（通常是UUID）
     * @param expire 过期时间（秒）
     */
    public boolean lock(String key, String value, long expire) {
        Boolean result = redisTemplate.opsForValue()
                .setIfAbsent(key, value, expire, TimeUnit.SECONDS);
        return result != null && result;
    }
    
    /**
     * 释放锁
     */
    public boolean unlock(String key, String value) {
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                       "return redis.call('del', KEYS[1]) else return 0 end";
        
        Long result = redisTemplate.execute(
            new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(key),
            value
        );
        return result != null && result == 1;
    }
}
```

### 5.2 使用分布式锁

```java
@Service
public class OrderService {
    
    @Autowired
    private RedisLock redisLock;
    
    public void createOrder(String productId) {
        String lockKey = "lock:product:" + productId;
        String lockValue = UUID.randomUUID().toString();
        
        try {
            // 获取锁
            if (redisLock.lock(lockKey, lockValue, 30)) {
                // 业务逻辑
                System.out.println("创建订单...");
                
                // 模拟业务处理
                Thread.sleep(2000);
            } else {
                System.out.println("获取锁失败");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            // 释放锁
            redisLock.unlock(lockKey, lockValue);
        }
    }
}
```

---

## 六、实战应用

### 6.1 缓存用户信息

```java
@Service
public class UserService {
    
    @Autowired
    private UserMapper userMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    public User findById(Long id) {
        String key = "user:" + id;
        
        // 先查缓存
        User user = (User) redisTemplate.opsForValue().get(key);
        if (user != null) {
            System.out.println("从缓存获取");
            return user;
        }
        
        // 查数据库
        user = userMapper.selectById(id);
        if (user != null) {
            // 写入缓存
            redisTemplate.opsForValue().set(key, user, 30, TimeUnit.MINUTES);
        }
        
        return user;
    }
}
```

### 6.2 排行榜

```java
@Service
public class RankService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String RANK_KEY = "rank:score";
    
    // 添加分数
    public void addScore(String userId, double score) {
        redisTemplate.opsForZSet().add(RANK_KEY, userId, score);
    }
    
    // 增加分数
    public void incrScore(String userId, double delta) {
        redisTemplate.opsForZSet().incrementScore(RANK_KEY, userId, delta);
    }
    
    // 获取排名（从1开始）
    public Long getRank(String userId) {
        Long rank = redisTemplate.opsForZSet().reverseRank(RANK_KEY, userId);
        return rank != null ? rank + 1 : null;
    }
    
    // 获取前N名
    public Set<Object> getTopN(int n) {
        return redisTemplate.opsForZSet().reverseRange(RANK_KEY, 0, n - 1);
    }
}
```

### 6.3 限流

```java
@Component
public class RateLimiter {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 滑动窗口限流
     * @param key 限流key
     * @param limit 限流次数
     * @param period 时间窗口（秒）
     */
    public boolean isAllowed(String key, int limit, int period) {
        long currentTime = System.currentTimeMillis();
        long startTime = currentTime - period * 1000;
        
        // 移除过期的记录
        redisTemplate.opsForZSet().removeRangeByScore(key, 0, startTime);
        
        // 统计当前窗口内的请求数
        Long count = redisTemplate.opsForZSet().count(key, startTime, currentTime);
        
        if (count != null && count < limit) {
            // 添加当前请求
            redisTemplate.opsForZSet().add(key, currentTime, currentTime);
            redisTemplate.expire(key, period, TimeUnit.SECONDS);
            return true;
        }
        
        return false;
    }
}
```

---

## 七、总结

✅ **本章学习内容：**
- Redis 简介和应用场景
- 整合 Redis
- RedisTemplate 使用
- 缓存注解
- 分布式锁
- 实战应用（缓存、排行榜、限流）

✅ **核心要点：**
- Redis 适用于缓存、Session共享、分布式锁
- 使用 RedisTemplate 操作 Redis
- 使用缓存注解简化开发
- 分布式锁需要考虑原子性

**下一章预告：** 我们将学习 Spring Boot 整合消息队列。
