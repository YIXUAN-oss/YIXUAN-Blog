---
title: 消息队列
---

# 消息队列

## 一、消息队列简介

### 1.1 什么是消息队列？

**消息队列（Message Queue）**：应用程序之间的通信方法，通过消息传递实现解耦。

**核心概念：**
- **生产者（Producer）**：发送消息
- **消费者（Consumer）**：接收消息
- **消息队列（Queue）**：存储消息

### 1.2 应用场景

- ✅ **异步处理** - 提高响应速度
- ✅ **应用解耦** - 降低系统耦合度
- ✅ **流量削峰** - 处理突发流量
- ✅ **消息通讯** - 系统间通信
- ✅ **日志处理** - 日志收集

---

## 二、整合RabbitMQ

### 2.1 RabbitMQ简介

**RabbitMQ** 是一个开源的消息代理软件，实现了 AMQP 协议。

**核心概念：**
- **Exchange（交换机）**：接收消息并路由
- **Queue（队列）**：存储消息
- **Binding（绑定）**：Exchange 和 Queue 的关系
- **Routing Key**：路由键

### 2.2 添加依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

### 2.3 配置

```yaml
spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
    virtual-host: /
    
    # 消息确认
    publisher-confirm-type: correlated
    publisher-returns: true
    
    # 消费者配置
    listener:
      simple:
        acknowledge-mode: manual
        prefetch: 1
```

### 2.4 简单队列

**配置队列：**
```java
@Configuration
public class RabbitConfig {
    
    @Bean
    public Queue simpleQueue() {
        return new Queue("simple.queue");
    }
}
```

**生产者：**
```java
@Service
public class Producer {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    public void send(String message) {
        rabbitTemplate.convertAndSend("simple.queue", message);
    }
}
```

**消费者：**
```java
@Component
public class Consumer {
    
    @RabbitListener(queues = "simple.queue")
    public void receive(String message) {
        System.out.println("收到消息：" + message);
    }
}
```

### 2.5 Work Queue（工作队列）

**多个消费者竞争消费：**
```java
@Component
public class WorkConsumer {
    
    @RabbitListener(queues = "work.queue")
    public void receive1(String message) {
        System.out.println("消费者1收到：" + message);
    }
    
    @RabbitListener(queues = "work.queue")
    public void receive2(String message) {
        System.out.println("消费者2收到：" + message);
    }
}
```

### 2.6 Fanout Exchange（广播）

**配置：**
```java
@Configuration
public class FanoutConfig {
    
    @Bean
    public FanoutExchange fanoutExchange() {
        return new FanoutExchange("fanout.exchange");
    }
    
    @Bean
    public Queue fanoutQueue1() {
        return new Queue("fanout.queue1");
    }
    
    @Bean
    public Queue fanoutQueue2() {
        return new Queue("fanout.queue2");
    }
    
    @Bean
    public Binding binding1(FanoutExchange fanoutExchange, Queue fanoutQueue1) {
        return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);
    }
    
    @Bean
    public Binding binding2(FanoutExchange fanoutExchange, Queue fanoutQueue2) {
        return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);
    }
}
```

**发送：**
```java
rabbitTemplate.convertAndSend("fanout.exchange", "", "广播消息");
```

### 2.7 Direct Exchange（路由）

**配置：**
```java
@Configuration
public class DirectConfig {
    
    @Bean
    public DirectExchange directExchange() {
        return new DirectExchange("direct.exchange");
    }
    
    @Bean
    public Queue directQueue1() {
        return new Queue("direct.queue1");
    }
    
    @Bean
    public Queue directQueue2() {
        return new Queue("direct.queue2");
    }
    
    @Bean
    public Binding directBinding1() {
        return BindingBuilder.bind(directQueue1())
                .to(directExchange())
                .with("info");
    }
    
    @Bean
    public Binding directBinding2() {
        return BindingBuilder.bind(directQueue2())
                .to(directExchange())
                .with("error");
    }
}
```

**发送：**
```java
rabbitTemplate.convertAndSend("direct.exchange", "info", "信息日志");
rabbitTemplate.convertAndSend("direct.exchange", "error", "错误日志");
```

### 2.8 Topic Exchange（主题）

**配置：**
```java
@Configuration
public class TopicConfig {
    
    @Bean
    public TopicExchange topicExchange() {
        return new TopicExchange("topic.exchange");
    }
    
    @Bean
    public Queue topicQueue1() {
        return new Queue("topic.queue1");
    }
    
    @Bean
    public Queue topicQueue2() {
        return new Queue("topic.queue2");
    }
    
    @Bean
    public Binding topicBinding1() {
        return BindingBuilder.bind(topicQueue1())
                .to(topicExchange())
                .with("user.*");  // * 匹配一个词
    }
    
    @Bean
    public Binding topicBinding2() {
        return BindingBuilder.bind(topicQueue2())
                .to(topicExchange())
                .with("user.#");  // # 匹配0个或多个词
    }
}
```

**发送：**
```java
rabbitTemplate.convertAndSend("topic.exchange", "user.login", "用户登录");
rabbitTemplate.convertAndSend("topic.exchange", "user.order.create", "创建订单");
```

### 2.9 消息确认

**生产者确认：**
```java
@Service
public class Producer {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    public void send(String message) {
        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -> {
            if (ack) {
                System.out.println("消息发送成功");
            } else {
                System.out.println("消息发送失败：" + cause);
            }
        });
        
        rabbitTemplate.setReturnsCallback(returned -> {
            System.out.println("消息被退回：" + returned.getMessage());
        });
        
        rabbitTemplate.convertAndSend("exchange", "routingKey", message);
    }
}
```

**消费者手动确认：**
```java
@Component
public class Consumer {
    
    @RabbitListener(queues = "simple.queue")
    public void receive(Message message, Channel channel) throws IOException {
        try {
            String msg = new String(message.getBody());
            System.out.println("收到消息：" + msg);
            
            // 处理业务逻辑
            
            // 手动确认
            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
        } catch (Exception e) {
            // 拒绝消息，重新入队
            channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true);
        }
    }
}
```

---

## 三、整合Kafka

### 3.1 Kafka简介

**Kafka** 是一个分布式流处理平台，高吞吐量、低延迟。

**核心概念：**
- **Topic（主题）**：消息分类
- **Partition（分区）**：Topic 的分片
- **Producer（生产者）**：发送消息
- **Consumer（消费者）**：消费消息
- **Consumer Group**：消费者组

### 3.2 添加依赖

```xml
<dependency>
    <groupId>org.springframework.kafka</groupId>
    <artifactId>spring-kafka</artifactId>
</dependency>
```

### 3.3 配置

```yaml
spring:
  kafka:
    bootstrap-servers: localhost:9092
    
    # 生产者配置
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.apache.kafka.common.serialization.StringSerializer
      acks: all
      retries: 3
    
    # 消费者配置
    consumer:
      group-id: my-group
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      auto-offset-reset: earliest
      enable-auto-commit: false
```

### 3.4 生产者

```java
@Service
public class KafkaProducer {
    
    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;
    
    public void send(String topic, String message) {
        kafkaTemplate.send(topic, message);
    }
    
    // 带回调
    public void sendWithCallback(String topic, String message) {
        ListenableFuture<SendResult<String, String>> future = 
                kafkaTemplate.send(topic, message);
        
        future.addCallback(
            result -> System.out.println("发送成功：" + result.getRecordMetadata().offset()),
            ex -> System.out.println("发送失败：" + ex.getMessage())
        );
    }
}
```

### 3.5 消费者

```java
@Component
public class KafkaConsumer {
    
    @KafkaListener(topics = "my-topic", groupId = "my-group")
    public void listen(String message) {
        System.out.println("收到消息：" + message);
    }
    
    // 手动确认
    @KafkaListener(topics = "my-topic", groupId = "my-group")
    public void listenWithAck(ConsumerRecord<String, String> record,
                             Acknowledgment ack) {
        System.out.println("收到消息：" + record.value());
        // 处理业务逻辑
        ack.acknowledge(); // 手动确认
    }
}
```

---

## 四、实战应用

### 4.1 订单异步处理

**场景：** 用户下单后，异步发送短信和邮件。

**生产者：**
```java
@Service
public class OrderService {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    public void createOrder(Order order) {
        // 保存订单
        orderMapper.insert(order);
        
        // 发送消息
        rabbitTemplate.convertAndSend("order.exchange", "order.created", order);
        
        System.out.println("订单创建成功");
    }
}
```

**消费者：**
```java
@Component
public class OrderConsumer {
    
    @RabbitListener(queues = "sms.queue")
    public void sendSms(Order order) {
        System.out.println("发送短信：订单号" + order.getId());
    }
    
    @RabbitListener(queues = "email.queue")
    public void sendEmail(Order order) {
        System.out.println("发送邮件：订单号" + order.getId());
    }
}
```

### 4.2 死信队列

**配置：**
```java
@Configuration
public class DeadLetterConfig {
    
    // 业务队列
    @Bean
    public Queue businessQueue() {
        Map<String, Object> args = new HashMap<>();
        args.put("x-dead-letter-exchange", "dead.exchange");
        args.put("x-dead-letter-routing-key", "dead.key");
        args.put("x-message-ttl", 10000); // 10秒过期
        return new Queue("business.queue", true, false, false, args);
    }
    
    // 死信交换机
    @Bean
    public DirectExchange deadExchange() {
        return new DirectExchange("dead.exchange");
    }
    
    // 死信队列
    @Bean
    public Queue deadQueue() {
        return new Queue("dead.queue");
    }
    
    @Bean
    public Binding deadBinding() {
        return BindingBuilder.bind(deadQueue())
                .to(deadExchange())
                .with("dead.key");
    }
}
```

---

## 五、总结

✅ **本章学习内容：**
- 消息队列简介和应用场景
- 整合 RabbitMQ
- RabbitMQ 四种交换机类型
- 消息确认机制
- 整合 Kafka
- 实战应用（订单处理、死信队列）

✅ **核心要点：**
- RabbitMQ 适用于复杂的路由场景
- Kafka 适用于高吞吐量场景
- 使用消息确认保证消息可靠性
- 死信队列处理异常消息

**下一章预告：** 我们将学习 Spring Boot 自动配置原理。
