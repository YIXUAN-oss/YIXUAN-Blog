---
title: Web开发
---

# Web开发

## 一、RESTful API开发

### 1.1 添加依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

### 1.2 创建实体类

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
    private Long id;
    private String username;
    private String email;
    private Integer age;
    private Date createTime;
}
```

### 1.3 创建 Controller

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private static List<User> users = new ArrayList<>();
    private static AtomicLong idCounter = new AtomicLong(1);
    
    // 查询列表
    @GetMapping
    public List<User> list() {
        return users;
    }
    
    // 查询详情
    @GetMapping("/{id}")
    public User detail(@PathVariable Long id) {
        return users.stream()
                .filter(u -> u.getId().equals(id))
                .findFirst()
                .orElse(null);
    }
    
    // 创建
    @PostMapping
    public User create(@RequestBody User user) {
        user.setId(idCounter.getAndIncrement());
        user.setCreateTime(new Date());
        users.add(user);
        return user;
    }
    
    // 更新
    @PutMapping("/{id}")
    public User update(@PathVariable Long id, @RequestBody User user) {
        User existUser = users.stream()
                .filter(u -> u.getId().equals(id))
                .findFirst()
                .orElse(null);
        if (existUser != null) {
            existUser.setUsername(user.getUsername());
            existUser.setEmail(user.getEmail());
            existUser.setAge(user.getAge());
        }
        return existUser;
    }
    
    // 删除
    @DeleteMapping("/{id}")
    public void delete(@PathVariable Long id) {
        users.removeIf(u -> u.getId().equals(id));
    }
}
```

---

## 二、统一响应格式

### 2.1 定义响应类

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Result<T> {
    private Integer code;
    private String message;
    private T data;
    
    public static <T> Result<T> success(T data) {
        return new Result<>(200, "success", data);
    }
    
    public static <T> Result<T> success() {
        return new Result<>(200, "success", null);
    }
    
    public static <T> Result<T> error(String message) {
        return new Result<>(500, message, null);
    }
    
    public static <T> Result<T> error(Integer code, String message) {
        return new Result<>(code, message, null);
    }
}
```

### 2.2 使用统一响应

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping
    public Result<List<User>> list() {
        return Result.success(users);
    }
    
    @GetMapping("/{id}")
    public Result<User> detail(@PathVariable Long id) {
        User user = findById(id);
        if (user == null) {
            return Result.error(404, "用户不存在");
        }
        return Result.success(user);
    }
    
    @PostMapping
    public Result<User> create(@RequestBody User user) {
        // 保存逻辑
        return Result.success(user);
    }
}
```

---

## 三、全局异常处理

### 3.1 自定义异常

```java
@Data
public class BusinessException extends RuntimeException {
    private Integer code;
    
    public BusinessException(String message) {
        super(message);
        this.code = 500;
    }
    
    public BusinessException(Integer code, String message) {
        super(message);
        this.code = code;
    }
}
```

### 3.2 全局异常处理器

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    // 业务异常
    @ExceptionHandler(BusinessException.class)
    public Result<?> handleBusinessException(BusinessException e) {
        log.error("业务异常：{}", e.getMessage());
        return Result.error(e.getCode(), e.getMessage());
    }
    
    // 参数验证异常
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result<?> handleValidException(MethodArgumentNotValidException e) {
        BindingResult result = e.getBindingResult();
        Map<String, String> errors = new HashMap<>();
        result.getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        return Result.error(400, "参数验证失败").setData(errors);
    }
    
    // 参数类型异常
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public Result<?> handleTypeMismatch(MethodArgumentTypeMismatchException e) {
        return Result.error(400, "参数类型错误");
    }
    
    // 404异常
    @ExceptionHandler(NoHandlerFoundException.class)
    public Result<?> handleNotFound(NoHandlerFoundException e) {
        return Result.error(404, "接口不存在");
    }
    
    // 系统异常
    @ExceptionHandler(Exception.class)
    public Result<?> handleException(Exception e) {
        log.error("系统异常：", e);
        return Result.error("系统错误，请联系管理员");
    }
}
```

---

## 四、参数验证

### 4.1 添加依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

### 4.2 实体类添加验证注解

```java
@Data
public class UserDTO {
    
    @NotBlank(message = "用户名不能为空")
    @Size(min = 2, max = 20, message = "用户名长度在2-20之间")
    private String username;
    
    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    private String email;
    
    @NotNull(message = "年龄不能为空")
    @Min(value = 1, message = "年龄最小为1")
    @Max(value = 150, message = "年龄最大为150")
    private Integer age;
    
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    private String phone;
}
```

### 4.3 Controller 使用验证

```java
@PostMapping
public Result<User> create(@Valid @RequestBody UserDTO dto) {
    // @Valid 启用验证
    // 验证失败会抛出 MethodArgumentNotValidException
    // 被全局异常处理器捕获
    User user = convertToUser(dto);
    return Result.success(user);
}
```

---

## 五、拦截器

### 5.1 创建拦截器

```java
@Slf4j
@Component
public class LoginInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                            HttpServletResponse response, 
                            Object handler) throws Exception {
        log.info("请求URI：{}", request.getRequestURI());
        
        // 检查token
        String token = request.getHeader("Authorization");
        if (token == null) {
            response.setStatus(401);
            response.getWriter().write("未登录");
            return false;
        }
        
        return true;
    }
    
    @Override
    public void postHandle(HttpServletRequest request, 
                          HttpServletResponse response, 
                          Object handler, 
                          ModelAndView modelAndView) {
        log.info("postHandle");
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, 
                               HttpServletResponse response, 
                               Object handler, 
                               Exception ex) {
        log.info("afterCompletion");
    }
}
```

### 5.2 注册拦截器

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Autowired
    private LoginInterceptor loginInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginInterceptor)
                .addPathPatterns("/api/**")
                .excludePathPatterns("/api/login", "/api/register");
    }
}
```

---

## 六、过滤器

### 6.1 创建过滤器

```java
@WebFilter(urlPatterns = "/*")
@Order(1)
public class LogFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, 
                         ServletResponse response, 
                         FilterChain chain) throws IOException, ServletException {
        
        HttpServletRequest req = (HttpServletRequest) request;
        long start = System.currentTimeMillis();
        
        chain.doFilter(request, response);
        
        long end = System.currentTimeMillis();
        System.out.println("请求：" + req.getRequestURI() + "，耗时：" + (end - start) + "ms");
    }
}
```

### 6.2 启用过滤器

```java
@SpringBootApplication
@ServletComponentScan  // 扫描 @WebFilter
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

---

## 七、跨域配置

### 7.1 全局跨域配置

```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOriginPatterns("*")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(3600);
    }
}
```

### 7.2 使用 @CrossOrigin

```java
@RestController
@RequestMapping("/api/users")
@CrossOrigin(origins = "*")
public class UserController {
    // 所有方法都允许跨域
}
```

---

## 八、Swagger接口文档

### 8.1 添加依赖

```xml
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-boot-starter</artifactId>
    <version>3.0.0</version>
</dependency>
```

### 8.2 配置 Swagger

```java
@Configuration
@EnableOpenApi
public class SwaggerConfig {
    
    @Bean
    public Docket api() {
        return new Docket(DocumentationType.OAS_30)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.example.demo.controller"))
                .paths(PathSelectors.any())
                .build();
    }
    
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("用户管理系统API")
                .description("用户管理系统接口文档")
                .version("1.0")
                .contact(new Contact("张三", "http://example.com", "test@example.com"))
                .build();
    }
}
```

### 8.3 使用 Swagger 注解

```java
@Api(tags = "用户管理")
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @ApiOperation("查询用户列表")
    @GetMapping
    public Result<List<User>> list() {
        return Result.success(users);
    }
    
    @ApiOperation("查询用户详情")
    @ApiImplicitParam(name = "id", value = "用户ID", required = true)
    @GetMapping("/{id}")
    public Result<User> detail(@PathVariable Long id) {
        return Result.success(findById(id));
    }
    
    @ApiOperation("创建用户")
    @PostMapping
    public Result<User> create(@RequestBody @ApiParam("用户信息") UserDTO dto) {
        return Result.success(createUser(dto));
    }
}
```

**实体类注解：**
```java
@ApiModel("用户")
@Data
public class User {
    
    @ApiModelProperty("用户ID")
    private Long id;
    
    @ApiModelProperty(value = "用户名", required = true)
    private String username;
    
    @ApiModelProperty("邮箱")
    private String email;
}
```

### 8.4 访问文档

```
http://localhost:8080/swagger-ui/index.html
```

---

## 九、文件上传

### 9.1 配置文件大小

```yaml
spring:
  servlet:
    multipart:
      max-file-size: 10MB      # 单个文件最大
      max-request-size: 50MB   # 总请求最大
```

### 9.2 单文件上传

```java
@PostMapping("/upload")
public Result<String> upload(@RequestParam("file") MultipartFile file) {
    if (file.isEmpty()) {
        return Result.error("文件为空");
    }
    
    try {
        // 保存路径
        String uploadDir = "/uploads/";
        File dir = new File(uploadDir);
        if (!dir.exists()) {
            dir.mkdirs();
        }
        
        // 文件名
        String fileName = UUID.randomUUID() + "_" + file.getOriginalFilename();
        String filePath = uploadDir + fileName;
        
        // 保存文件
        file.transferTo(new File(filePath));
        
        return Result.success(filePath);
    } catch (IOException e) {
        return Result.error("上传失败");
    }
}
```

### 9.3 多文件上传

```java
@PostMapping("/upload/multiple")
public Result<List<String>> uploadMultiple(@RequestParam("files") MultipartFile[] files) {
    List<String> filePaths = new ArrayList<>();
    
    for (MultipartFile file : files) {
        if (!file.isEmpty()) {
            String fileName = UUID.randomUUID() + "_" + file.getOriginalFilename();
            String filePath = "/uploads/" + fileName;
            file.transferTo(new File(filePath));
            filePaths.add(filePath);
        }
    }
    
    return Result.success(filePaths);
}
```

---

## 十、总结

✅ **本章学习内容：**
- RESTful API 开发
- 统一响应格式
- 全局异常处理
- 参数验证
- 拦截器和过滤器
- 跨域配置
- Swagger 接口文档
- 文件上传

✅ **核心要点：**
- 使用统一响应格式提高接口规范性
- 使用全局异常处理统一错误处理
- 使用参数验证保证数据完整性
- Swagger 自动生成接口文档

**下一章预告：** 我们将学习 Spring Boot 数据访问。
