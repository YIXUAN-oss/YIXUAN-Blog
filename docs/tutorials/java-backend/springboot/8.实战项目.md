---
title: 实战项目
---

# 实战项目

## 一、项目架构设计

### 1.1 技术栈

**后端：**
- Spring Boot 2.7.x
- MyBatis-Plus 3.5.x
- Redis 5.0+
- MySQL 8.0+
- JWT 认证
- Swagger 3.0

**分层架构：**
```
controller → service → mapper → database
    ↓          ↓         ↓
   DTO       Entity   Entity
```

### 1.2 项目结构

```
springboot-project/
├── pom.xml
└── src/main/java/com/example/project/
    ├── ProjectApplication.java         # 启动类
    ├── controller/                     # 控制层
    │   ├── UserController.java
    │   └── AuthController.java
    ├── service/                        # 业务层
    │   ├── UserService.java
    │   └── impl/
    │       └── UserServiceImpl.java
    ├── mapper/                         # 数据访问层
    │   └── UserMapper.java
    ├── entity/                         # 实体类
    │   └── User.java
    ├── dto/                            # 数据传输对象
    │   ├── LoginDTO.java
    │   └── RegisterDTO.java
    ├── vo/                             # 视图对象
    │   └── UserVO.java
    ├── config/                         # 配置类
    │   ├── WebConfig.java
    │   ├── RedisConfig.java
    │   └── SwaggerConfig.java
    ├── interceptor/                    # 拦截器
    │   └── AuthInterceptor.java
    ├── exception/                      # 异常处理
    │   ├── BusinessException.java
    │   └── GlobalExceptionHandler.java
    ├── common/                         # 公共类
    │   ├── Result.java
    │   └── Constants.java
    └── util/                           # 工具类
        ├── JwtUtil.java
        └── PasswordUtil.java
```

---

## 二、用户认证与授权（JWT）

### 2.1 添加依赖

```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>
```

### 2.2 JWT工具类

```java
@Component
public class JwtUtil {
    
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration}")
    private Long expiration;
    
    // 生成Token
    public String generateToken(Long userId, String username) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId);
        claims.put("username", username);
        
        return Jwts.builder()
                .setClaims(claims)
                .setExpiration(new Date(System.currentTimeMillis() + expiration * 1000))
                .signWith(SignatureAlgorithm.HS512, secret)
                .compact();
    }
    
    // 解析Token
    public Claims parseToken(String token) {
        try {
            return Jwts.parser()
                    .setSigningKey(secret)
                    .parseClaimsJws(token)
                    .getBody();
        } catch (Exception e) {
            return null;
        }
    }
    
    // 验证Token
    public boolean validateToken(String token) {
        try {
            Claims claims = parseToken(token);
            return claims != null && !isTokenExpired(claims);
        } catch (Exception e) {
            return false;
        }
    }
    
    // 是否过期
    private boolean isTokenExpired(Claims claims) {
        return claims.getExpiration().before(new Date());
    }
    
    // 获取用户ID
    public Long getUserId(String token) {
        Claims claims = parseToken(token);
        return claims != null ? claims.get("userId", Long.class) : null;
    }
}
```

### 2.3 登录注册

**LoginDTO：**
```java
@Data
public class LoginDTO {
    @NotBlank(message = "用户名不能为空")
    private String username;
    
    @NotBlank(message = "密码不能为空")
    private String password;
}
```

**AuthController：**
```java
@RestController
@RequestMapping("/api/auth")
public class AuthController {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @PostMapping("/login")
    public Result<String> login(@Valid @RequestBody LoginDTO dto) {
        // 验证用户
        User user = userService.login(dto.getUsername(), dto.getPassword());
        if (user == null) {
            return Result.error("用户名或密码错误");
        }
        
        // 生成Token
        String token = jwtUtil.generateToken(user.getId(), user.getUsername());
        
        return Result.success(token);
    }
    
    @PostMapping("/register")
    public Result<User> register(@Valid @RequestBody RegisterDTO dto) {
        User user = userService.register(dto);
        return Result.success(user);
    }
}
```

### 2.4 认证拦截器

```java
@Component
public class AuthInterceptor implements HandlerInterceptor {
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                            HttpServletResponse response, 
                            Object handler) throws Exception {
        
        // 获取Token
        String token = request.getHeader("Authorization");
        if (token == null || !token.startsWith("Bearer ")) {
            throw new BusinessException(401, "未登录");
        }
        
        token = token.substring(7);
        
        // 验证Token
        if (!jwtUtil.validateToken(token)) {
            throw new BusinessException(401, "Token无效或已过期");
        }
        
        // 将用户ID放入请求属性
        Long userId = jwtUtil.getUserId(token);
        request.setAttribute("userId", userId);
        
        return true;
    }
}
```

### 2.5 注册拦截器

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Autowired
    private AuthInterceptor authInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(authInterceptor)
                .addPathPatterns("/api/**")
                .excludePathPatterns("/api/auth/**", "/swagger-ui/**");
    }
}
```

---

## 三、文件上传下载

### 3.1 配置

```yaml
file:
  upload-dir: /uploads/
  max-size: 10485760  # 10MB
```

### 3.2 文件上传

```java
@RestController
@RequestMapping("/api/file")
public class FileController {
    
    @Value("${file.upload-dir}")
    private String uploadDir;
    
    @PostMapping("/upload")
    public Result<String> upload(@RequestParam("file") MultipartFile file) {
        if (file.isEmpty()) {
            return Result.error("文件为空");
        }
        
        try {
            // 创建目录
            File dir = new File(uploadDir);
            if (!dir.exists()) {
                dir.mkdirs();
            }
            
            // 生成文件名
            String fileName = UUID.randomUUID() + "_" + file.getOriginalFilename();
            String filePath = uploadDir + fileName;
            
            // 保存文件
            file.transferTo(new File(filePath));
            
            return Result.success(fileName);
        } catch (IOException e) {
            return Result.error("上传失败");
        }
    }
    
    @GetMapping("/download/{fileName}")
    public ResponseEntity<Resource> download(@PathVariable String fileName) 
            throws IOException {
        
        Path filePath = Paths.get(uploadDir + fileName);
        Resource resource = new UrlResource(filePath.toUri());
        
        if (resource.exists()) {
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, 
                           "attachment; filename=\"" + fileName + "\"")
                    .body(resource);
        }
        
        return ResponseEntity.notFound().build();
    }
}
```

---

## 四、定时任务

### 4.1 启用定时任务

```java
@SpringBootApplication
@EnableScheduling  // 启用定时任务
public class ProjectApplication {
    public static void main(String[] args) {
        SpringApplication.run(ProjectApplication.class, args);
    }
}
```

### 4.2 创建定时任务

```java
@Component
@Slf4j
public class ScheduledTasks {
    
    // 每天凌晨1点执行
    @Scheduled(cron = "0 0 1 * * ?")
    public void cleanExpiredData() {
        log.info("清理过期数据...");
        // 业务逻辑
    }
    
    // 每5分钟执行一次
    @Scheduled(fixedRate = 300000)
    public void syncData() {
        log.info("同步数据...");
    }
    
    // 启动10秒后执行，之后每1分钟执行
    @Scheduled(initialDelay = 10000, fixedRate = 60000)
    public void checkStatus() {
        log.info("检查状态...");
    }
}
```

---

## 五、邮件发送

### 5.1 添加依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
```

### 5.2 配置

```yaml
spring:
  mail:
    host: smtp.qq.com
    port: 587
    username: your-email@qq.com
    password: your-password
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
```

### 5.3 发送邮件

```java
@Service
public class EmailService {
    
    @Autowired
    private JavaMailSender mailSender;
    
    @Value("${spring.mail.username}")
    private String from;
    
    // 发送简单邮件
    public void sendSimpleMail(String to, String subject, String content) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setFrom(from);
        message.setTo(to);
        message.setSubject(subject);
        message.setText(content);
        mailSender.send(message);
    }
    
    // 发送HTML邮件
    public void sendHtmlMail(String to, String subject, String content) 
            throws MessagingException {
        MimeMessage message = mailSender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(message, true);
        
        helper.setFrom(from);
        helper.setTo(to);
        helper.setSubject(subject);
        helper.setText(content, true);
        
        mailSender.send(message);
    }
}
```

---

## 六、日志管理

### 6.1 Logback配置

**logback-spring.xml：**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <property name="LOG_PATH" value="logs"/>
    
    <!-- 控制台输出 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 文件输出 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/app.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/app-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy 
                class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>10MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 错误日志 -->
    <appender name="ERROR" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/error.log</file>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/error-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
        <appender-ref ref="ERROR"/>
    </root>
</configuration>
```

---

## 七、监控与部署

### 7.1 Actuator监控

**添加依赖：**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

**配置：**
```yaml
management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: always
```

**访问：**
```
http://localhost:8080/actuator/health
http://localhost:8080/actuator/metrics
http://localhost:8080/actuator/env
```

### 7.2 打包部署

**打包：**
```bash
mvn clean package
```

**运行：**
```bash
java -jar app.jar

# 指定环境
java -jar app.jar --spring.profiles.active=prod

# 后台运行
nohup java -jar app.jar > app.log 2>&1 &
```

---

## 八、总结

✅ **本章学习内容：**
- 项目架构设计
- 用户认证与授权（JWT）
- 文件上传下载
- 定时任务
- 邮件发送
- 日志管理
- 监控与部署

✅ **核心要点：**
- 分层架构清晰
- JWT 实现无状态认证
- 使用拦截器进行权限控制
- 定时任务处理周期性业务
- 日志管理便于问题排查

**下一章预告：** 我们将整理 Spring Boot 常见面试题。
