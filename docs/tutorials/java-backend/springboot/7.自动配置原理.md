---
title: 自动配置原理
---

# 自动配置原理

## 一、@SpringBootApplication解析

### 1.1 注解组成

```java
@SpringBootApplication
= @SpringBootConfiguration     // 配置类
+ @EnableAutoConfiguration    // 自动配置
+ @ComponentScan             // 组件扫描
```

### 1.2 详细分析

**@SpringBootConfiguration：**
```java
@Configuration
public @interface SpringBootConfiguration {
}
// 等价于 @Configuration，标识这是一个配置类
```

**@ComponentScan：**
```java
// 扫描当前包及子包下的组件
@ComponentScan(basePackages = "com.example.demo")
```

**@EnableAutoConfiguration：** 核心，实现自动配置

---

## 二、@EnableAutoConfiguration原理

### 2.1 源码分析

```java
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {
}
```

**AutoConfigurationImportSelector** 负责导入自动配置类。

### 2.2 执行流程

```
1. Spring Boot 启动
   ↓
2. @EnableAutoConfiguration 生效
   ↓
3. AutoConfigurationImportSelector 执行
   ↓
4. 读取 META-INF/spring.factories
   ↓
5. 加载所有自动配置类
   ↓
6. 根据条件注解(@Conditional)过滤
   ↓
7. 生效的配置类注册到容器
```

### 2.3 spring.factories

**位置：** `META-INF/spring.factories`

**内容：**
```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\
...
```

**作用：** 定义所有可能的自动配置类。

---

## 三、条件注解

### 3.1 @Conditional

**Spring Boot 自动配置的核心：根据条件决定是否生效。**

### 3.2 常用条件注解

| 注解 | 说明 |
|------|------|
| @ConditionalOnClass | 类路径存在指定类 |
| @ConditionalOnMissingClass | 类路径不存在指定类 |
| @ConditionalOnBean | 容器中存在指定 Bean |
| @ConditionalOnMissingBean | 容器中不存在指定 Bean |
| @ConditionalOnProperty | 配置文件存在指定属性 |
| @ConditionalOnResource | 存在指定资源文件 |
| @ConditionalOnWebApplication | Web 应用 |
| @ConditionalOnNotWebApplication | 非 Web 应用 |

### 3.3 示例

**DataSourceAutoConfiguration：**
```java
@Configuration
@ConditionalOnClass({DataSource.class, EmbeddedDatabaseType.class})
@EnableConfigurationProperties(DataSourceProperties.class)
public class DataSourceAutoConfiguration {
    
    @Bean
    @ConditionalOnMissingBean
    public DataSource dataSource() {
        // 创建数据源
    }
}
```

**解释：**
- 只有类路径存在 DataSource 类时才生效
- 只有容器中不存在 DataSource Bean 时才创建

---

## 四、自动配置源码分析

### 4.1 WebMvcAutoConfiguration

**Web MVC 自动配置：**
```java
@Configuration
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class})
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({DispatcherServletAutoConfiguration.class})
public class WebMvcAutoConfiguration {
    
    @Bean
    @ConditionalOnMissingBean
    public InternalResourceViewResolver defaultViewResolver() {
        // 配置视图解析器
    }
    
    // 其他配置...
}
```

### 4.2 RedisAutoConfiguration

**Redis 自动配置：**
```java
@Configuration
@ConditionalOnClass(RedisOperations.class)
@EnableConfigurationProperties(RedisProperties.class)
public class RedisAutoConfiguration {
    
    @Bean
    @ConditionalOnMissingBean(name = "redisTemplate")
    public RedisTemplate<Object, Object> redisTemplate(
            RedisConnectionFactory redisConnectionFactory) {
        // 创建 RedisTemplate
    }
}
```

---

## 五、自定义Starter

### 5.1 Starter命名规范

- **官方：** `spring-boot-starter-{name}`
- **自定义：** `{name}-spring-boot-starter`

### 5.2 创建自定义Starter

**目标：** 创建一个短信发送 Starter

**1. 创建 Maven 项目**
```xml
<groupId>com.example</groupId>
<artifactId>sms-spring-boot-starter</artifactId>
<version>1.0.0</version>
```

**2. 添加依赖**
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>
    
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-configuration-processor</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

**3. 创建配置属性类**
```java
@ConfigurationProperties(prefix = "sms")
@Data
public class SmsProperties {
    private String accessKey;
    private String accessSecret;
    private String signName;
}
```

**4. 创建服务类**
```java
public class SmsService {
    
    private SmsProperties properties;
    
    public SmsService(SmsProperties properties) {
        this.properties = properties;
    }
    
    public void sendSms(String phone, String content) {
        System.out.println("发送短信到：" + phone);
        System.out.println("内容：" + content);
        System.out.println("签名：" + properties.getSignName());
    }
}
```

**5. 创建自动配置类**
```java
@Configuration
@ConditionalOnClass(SmsService.class)
@EnableConfigurationProperties(SmsProperties.class)
public class SmsAutoConfiguration {
    
    @Bean
    @ConditionalOnMissingBean
    public SmsService smsService(SmsProperties properties) {
        return new SmsService(properties);
    }
}
```

**6. 创建 spring.factories**

**META-INF/spring.factories：**
```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.sms.autoconfigure.SmsAutoConfiguration
```

**7. 打包**
```bash
mvn clean install
```

### 5.3 使用自定义Starter

**1. 添加依赖**
```xml
<dependency>
    <groupId>com.example</groupId>
    <artifactId>sms-spring-boot-starter</artifactId>
    <version>1.0.0</version>
</dependency>
```

**2. 配置**
```yaml
sms:
  access-key: your-key
  access-secret: your-secret
  sign-name: 测试签名
```

**3. 使用**
```java
@RestController
public class SmsController {
    
    @Autowired
    private SmsService smsService;
    
    @GetMapping("/send")
    public String send() {
        smsService.sendSms("13800138000", "验证码：123456");
        return "success";
    }
}
```

---

## 六、SPI机制

### 6.1 什么是SPI？

**SPI（Service Provider Interface）**：服务提供接口，一种服务发现机制。

**Spring Boot 使用 SPI：**
- `spring.factories` 文件
- 定义接口和实现的映射关系
- 实现可插拔式扩展

### 6.2 Spring Factories Loader

**源码：**
```java
public abstract class SpringFactoriesLoader {
    
    public static <T> List<T> loadFactories(Class<T> factoryClass, 
                                           @Nullable ClassLoader classLoader) {
        // 读取所有 META-INF/spring.factories
        // 加载指定接口的实现类
    }
}
```

---

## 七、配置优先级

### 7.1 优先级顺序

```
1. 命令行参数
2. SPRING_APPLICATION_JSON（环境变量或系统属性中的内联 JSON）
3. ServletConfig 初始化参数
4. ServletContext 初始化参数
5. JNDI 属性
6. Java 系统属性（System.getProperties()）
7. 操作系统环境变量
8. RandomValuePropertySource
9. jar 包外部的 application-{profile}.properties 或 yml
10. jar 包内部的 application-{profile}.properties 或 yml
11. jar 包外部的 application.properties 或 yml
12. jar 包内部的 application.properties 或 yml
13. @Configuration 类上的 @PropertySource
14. 默认属性（SpringApplication.setDefaultProperties）
```

---

## 八、总结

✅ **本章学习内容：**
- @SpringBootApplication 解析
- @EnableAutoConfiguration 原理
- 条件注解详解
- 自动配置源码分析
- 自定义 Starter
- SPI 机制
- 配置优先级

✅ **核心要点：**
- Spring Boot 通过 @EnableAutoConfiguration 实现自动配置
- 自动配置通过条件注解决定是否生效
- spring.factories 定义自动配置类
- 自定义 Starter 实现功能扩展

**下一章预告：** 我们将学习 Spring Boot 实战项目。
