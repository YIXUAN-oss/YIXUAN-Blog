# 视图

> 视图是虚拟表，简化复杂查询，提高SQL的可重用性和安全性。本章学习视图的创建和使用。

## 📋 本章目录

- [一、视图概述](#一视图概述)
- [二、视图操作](#二视图操作)
- [三、检查选项](#三检查选项)
- [四、视图的更新](#四视图的更新)
- [五、视图的应用场景](#五视图的应用场景)

---

## 一、视图概述

### 1.1 什么是视图？

**视图（View）** 是一种虚拟存在的表，不存储实际数据，只保存查询的SQL逻辑。

**特点：**
- 📝 视图是虚拟表，数据来自基础表
- 🔄 动态生成数据，实时反映基础表的变化
- 💾 只存储SQL定义，不存储数据
- 🔒 可以隐藏复杂查询，提高安全性

### 1.2 视图 vs 表

| 特性 | 视图 | 表 |
|------|------|-----|
| 数据存储 | ❌ 不存储数据 | ✅ 存储实际数据 |
| 占用空间 | 极小（只存SQL） | 根据数据量 |
| 更新限制 | 有限制 | 无限制 |
| 性能 | 依赖基础表 | 直接查询 |
| 用途 | 简化查询、权限控制 | 存储数据 |

### 1.3 视图的优势

**1. 简化复杂查询**
```sql
-- 不使用视图：每次都要写复杂SQL
SELECT u.name, o.order_no, o.total_amount
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 1;

-- 使用视图：简化查询
CREATE VIEW v_user_orders AS
SELECT u.name, o.order_no, o.total_amount
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 1;

-- 使用时只需：
SELECT * FROM v_user_orders;
```

**2. 提高安全性**
```sql
-- 隐藏敏感字段（如密码、工资）
CREATE VIEW v_public_users AS
SELECT id, name, email FROM users;  -- 不包含password字段
```

**3. 数据独立性**
- 表结构改变时，视图可以保持接口不变
- 应用程序不需要修改

---

## 二、视图操作

### 2.1 创建视图

**语法：**
```sql
CREATE [OR REPLACE] VIEW 视图名称 [(列名列表)]
AS
SELECT 语句
[WITH [CASCADED | LOCAL] CHECK OPTION];
```

**示例1：基本视图**
```sql
-- 创建学生信息视图（只显示id和name）
CREATE VIEW v_student AS
SELECT id, name, age FROM students WHERE id <= 10;

-- 查询视图
SELECT * FROM v_student;
```

**示例2：复杂视图**
```sql
-- 创建订单统计视图
CREATE VIEW v_user_order_stats AS
SELECT 
    u.id,
    u.name AS user_name,
    COUNT(o.id) AS order_count,
    IFNULL(SUM(o.amount), 0) AS total_amount
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;

-- 使用视图
SELECT * FROM v_user_order_stats WHERE order_count > 5;
```

**示例3：OR REPLACE（更新视图）**
```sql
-- 如果视图存在则替换
CREATE OR REPLACE VIEW v_student AS
SELECT id, name, age, class FROM students WHERE id <= 10;
```

### 2.2 查看视图

```sql
-- 查看所有视图
SHOW TABLES;  -- 视图也会显示在表列表中

-- 查看视图定义
SHOW CREATE VIEW v_student;

-- 查看视图结构
DESC v_student;

-- 查询视图数据
SELECT * FROM v_student;
SELECT * FROM v_student WHERE age > 18;
```

### 2.3 修改视图

```sql
-- 方式1：CREATE OR REPLACE
CREATE OR REPLACE VIEW v_student AS
SELECT id, name, age, gender FROM students WHERE id <= 10;

-- 方式2：ALTER VIEW
ALTER VIEW v_student AS
SELECT id, name FROM students WHERE id <= 5;
```

### 2.4 删除视图

```sql
-- 删除单个视图
DROP VIEW IF EXISTS v_student;

-- 删除多个视图
DROP VIEW IF EXISTS v_student, v_user_orders;
```

---

## 三、检查选项

### 3.1 WITH CHECK OPTION

当使用 `WITH CHECK OPTION` 创建视图时，通过视图插入、更新、删除数据时，MySQL会检查数据是否符合视图的WHERE条件。

### 3.2 CASCADED（默认）

**CASCADED** 是默认选项，会递归检查所有依赖视图的条件。

```sql
-- 创建基础视图
CREATE VIEW v1 AS
SELECT * FROM students WHERE age >= 18;

-- 创建级联检查视图
CREATE VIEW v2 AS
SELECT * FROM v1 WHERE age <= 25
WITH CASCADED CHECK OPTION;

-- ✅ 可以插入（满足 age>=18 AND age<=25）
INSERT INTO v2 VALUES (1, '张三', 20, '一班');

-- ❌ 插入失败（age=30 不满足 v2 的条件 age<=25）
INSERT INTO v2 VALUES (2, '李四', 30, '二班');

-- ❌ 插入失败（age=16 不满足 v1 的条件 age>=18）
INSERT INTO v2 VALUES (3, '王五', 16, '三班');
```

**CASCADED 检查逻辑：**
- 检查 v2 的条件：age <= 25
- 递归检查 v1 的条件：age >= 18
- 两个条件都要满足

### 3.3 LOCAL

**LOCAL** 只检查当前视图的条件，不递归检查依赖视图。

```sql
-- 创建基础视图（无检查选项）
CREATE VIEW v1 AS
SELECT * FROM students WHERE age >= 18;

-- 创建本地检查视图
CREATE VIEW v2 AS
SELECT * FROM v1 WHERE age <= 25
WITH LOCAL CHECK OPTION;

-- ✅ 可以插入（只检查 v2 的条件 age<=25）
INSERT INTO v2 VALUES (1, '张三', 20, '一班');

-- ❌ 插入失败（不满足 v2 的条件 age<=25）
INSERT INTO v2 VALUES (2, '李四', 30, '二班');

-- ⚠️ 可以插入（LOCAL不检查v1的条件，但实际上违反了age>=18）
-- 注意：虽然可以尝试插入，但如果基础表有约束可能还是会失败
INSERT INTO v2 VALUES (3, '王五', 16, '三班');
```

### 3.4 对比总结

| 选项 | 检查范围 | 使用场景 |
|------|---------|---------|
| **CASCADED** | 递归检查所有视图条件 | 严格数据验证（推荐） |
| **LOCAL** | 只检查当前视图条件 | 灵活的数据插入 |
| **不使用** | 不检查条件 | 只读视图 |

---

## 四、视图的更新

### 4.1 可更新视图

视图可更新的条件：视图中的行与基础表中的行存在 **一对一** 的关系。

**可更新的视图示例：**
```sql
-- 简单视图（可更新）
CREATE VIEW v_students AS
SELECT id, name, age FROM students;

-- 可以进行增删改操作
INSERT INTO v_students VALUES (100, '新学生', 20);
UPDATE v_students SET age = 21 WHERE id = 100;
DELETE FROM v_students WHERE id = 100;
```

### 4.2 不可更新视图

如果视图包含以下任意一项，则视图 **不可更新**：

**1. 聚合函数或窗口函数**
```sql
CREATE VIEW v_avg_age AS
SELECT class, AVG(age) AS avg_age FROM students GROUP BY class;

-- ❌ 不能更新
UPDATE v_avg_age SET avg_age = 20 WHERE class = '一班';
```

**2. DISTINCT**
```sql
CREATE VIEW v_distinct_class AS
SELECT DISTINCT class FROM students;

-- ❌ 不能更新
```

**3. GROUP BY**
```sql
CREATE VIEW v_class_count AS
SELECT class, COUNT(*) AS cnt FROM students GROUP BY class;

-- ❌ 不能更新
```

**4. HAVING**
```sql
CREATE VIEW v_class_having AS
SELECT class, COUNT(*) AS cnt 
FROM students 
GROUP BY class 
HAVING COUNT(*) > 5;

-- ❌ 不能更新
```

**5. UNION 或 UNION ALL**
```sql
CREATE VIEW v_union AS
SELECT id, name FROM students
UNION
SELECT id, name FROM teachers;

-- ❌ 不能更新
```

**6. 子查询**
```sql
CREATE VIEW v_subquery AS
SELECT * FROM students 
WHERE age > (SELECT AVG(age) FROM students);

-- ❌ 不能更新
```

### 4.3 更新限制总结

| 视图类型 | 是否可更新 | 示例 |
|---------|----------|------|
| 简单SELECT | ✅ 可以 | SELECT id, name FROM t |
| 包含聚合函数 | ❌ 不可以 | SELECT AVG(age) ... |
| 包含DISTINCT | ❌ 不可以 | SELECT DISTINCT ... |
| 包含GROUP BY | ❌ 不可以 | ... GROUP BY class |
| 包含JOIN | ⚠️ 部分可以 | 取决于具体情况 |

---

## 五、💼 实际工作中什么时候用视图？

### 5.1 场景1：简化复杂查询（最常用）

```sql
-- 场景：经常需要查询用户的订单统计信息
CREATE VIEW v_user_stats AS
SELECT 
    u.id,
    u.username,
    u.email,
    COUNT(o.id) AS order_count,
    SUM(o.amount) AS total_spent,
    MAX(o.create_time) AS last_order_time
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.username, u.email;

-- 使用时非常简单
SELECT * FROM v_user_stats WHERE order_count > 10;
```

### 5.2 场景2：权限控制和数据安全（重要）

**真实案例**：一个公司的员工管理系统，不同部门看到的数据不同。

```sql
-- HR部门：只能看基本信息（不包含工资）
CREATE VIEW v_hr_employees AS
SELECT id, name, dept, hire_date, phone, email FROM employees;
GRANT SELECT ON v_hr_employees TO 'hr_user'@'%';

-- 财务部门：可以看工资信息
CREATE VIEW v_finance_employees AS
SELECT id, name, dept, salary, bonus FROM employees;
GRANT SELECT ON v_finance_employees TO 'finance_user'@'%';

-- 普通员工：只能看自己的信息
CREATE VIEW v_my_profile AS
SELECT id, name, email, phone, dept FROM employees 
WHERE username = USER();
GRANT SELECT ON v_my_profile TO 'employee'@'%';

-- 经理：可以看本部门员工信息
CREATE VIEW v_dept_employees AS
SELECT e.id, e.name, e.position, e.hire_date
FROM employees e
WHERE e.dept_id = (
    SELECT dept_id FROM employees WHERE username = USER()
);
```

**为什么用视图**：
- ✅ 不同用户看不同数据，无需修改应用代码
- ✅ 隐藏敏感字段（如密码、工资）
- ✅ 细粒度的权限控制
- ✅ 数据安全性更高

**实际工作中的应用**：
- 🏢 OA系统：不同级别员工看到不同审批流程
- 💰 财务系统：只有财务人员能看金额
- 📊 数据分析：给分析师提供脱敏后的数据视图
- 🏥 医疗系统：医生只能看自己的患者

### 5.3 数据格式转换

```sql
-- 场景：格式化显示数据
CREATE VIEW v_formatted_orders AS
SELECT 
    order_id,
    user_name,
    DATE_FORMAT(order_time, '%Y-%m-%d %H:%i:%s') AS order_time,
    CONCAT('¥', FORMAT(amount, 2)) AS amount_formatted,
    CASE status
        WHEN 1 THEN '待支付'
        WHEN 2 THEN '已支付'
        WHEN 3 THEN '已发货'
        WHEN 4 THEN '已完成'
        ELSE '未知'
    END AS status_text
FROM orders;
```

### 5.4 兼容性

```sql
-- 场景：表结构改变，但保持对外接口不变
-- 原表：users(id, name, address)
-- 新表：users(id, name), addresses(user_id, address)

-- 创建视图保持兼容
CREATE VIEW v_users_compatible AS
SELECT u.id, u.name, a.address
FROM users u
LEFT JOIN addresses a ON u.id = a.user_id;

-- 应用程序不需要修改
SELECT * FROM v_users_compatible;
```

---

## 六、最佳实践

### 6.1 命名规范

```sql
-- 建议视图名以 v_ 开头
CREATE VIEW v_user_orders AS ...
CREATE VIEW v_product_stats AS ...
```

### 6.2 性能注意事项

**1. 避免嵌套过深**
```sql
-- ❌ 不推荐：视图嵌套过深
CREATE VIEW v1 AS SELECT * FROM t1;
CREATE VIEW v2 AS SELECT * FROM v1;
CREATE VIEW v3 AS SELECT * FROM v2;  -- 影响性能
```

**2. 复杂视图考虑物化**
```sql
-- 对于复杂统计，考虑创建物理表定期更新
CREATE TABLE t_user_stats AS
SELECT ... FROM users ... ;  -- 定期更新
```

### 6.3 安全性

```sql
-- 创建视图时指定字段，不用 SELECT *
CREATE VIEW v_users AS
SELECT id, name, email FROM users;  -- ✅ 明确字段

-- 而不是
CREATE VIEW v_users AS
SELECT * FROM users;  -- ❌ 可能暴露敏感字段
```

---

## 七、本章总结

### 核心要点

1. **视图是虚拟表**：只存储SQL定义，不存储数据
2. **简化查询**：隐藏复杂SQL逻辑
3. **权限控制**：不同用户看不同视图
4. **WITH CHECK OPTION**：CASCADED递归检查，LOCAL只检查当前
5. **更新限制**：包含聚合、DISTINCT、GROUP BY等的视图不可更新

### 使用建议

| 场景 | 建议 |
|------|------|
| 简化复杂查询 | ✅ 推荐使用视图 |
| 权限控制 | ✅ 推荐使用视图 |
| 频繁更新数据 | ❌ 不推荐视图 |
| 大量计算统计 | ⚠️ 考虑物化表 |

---

## 练习题

```sql
-- 1. 创建学生成绩视图
CREATE VIEW v_student_scores AS
SELECT 
    s.id,
    s.name,
    c.course_name,
    sc.score
FROM students s
JOIN scores sc ON s.id = sc.student_id
JOIN courses c ON sc.course_id = c.id;

-- 2. 创建平均分统计视图
CREATE VIEW v_avg_scores AS
SELECT 
    s.id,
    s.name,
    AVG(sc.score) AS avg_score,
    COUNT(*) AS course_count
FROM students s
JOIN scores sc ON s.id = sc.student_id
GROUP BY s.id, s.name;

-- 3. 带检查选项的视图
CREATE VIEW v_high_score AS
SELECT * FROM scores WHERE score >= 60
WITH CASCADED CHECK OPTION;

-- 测试插入
INSERT INTO v_high_score VALUES (1, 1, 1, 85);  -- ✅ 可以
INSERT INTO v_high_score VALUES (2, 2, 2, 50);  -- ❌ 失败
```

---

**下一章：[第11章 - 存储过程](11-存储过程.md)** →
