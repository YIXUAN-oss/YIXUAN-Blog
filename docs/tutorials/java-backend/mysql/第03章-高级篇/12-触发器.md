# 触发器

> 触发器是与表关联的特殊存储过程，在特定事件发生时自动执行。本章学习触发器的使用。

## 📋 本章目录

- [一、触发器概述](#一触发器概述)
- [二、触发器语法](#二触发器语法)
- [三、触发器应用](#三触发器应用)
- [四、触发器最佳实践](#四触发器最佳实践)

---

## 一、触发器概述

### 1.1 什么是触发器？

**触发器（Trigger）** 是与表关联的数据库对象，在INSERT/UPDATE/DELETE操作之前或之后自动触发执行。

**特点：**
- 🔄 **自动执行**：无需手动调用
- 📝 **数据校验**：在数据变更前进行验证
- 📊 **审计日志**：自动记录数据变更
- 🔗 **关联操作**：同步更新相关表

### 1.2 触发器类型

MySQL支持6种触发器：

| 触发时机 | 操作类型 | 说明 |
|---------|---------|------|
| BEFORE | INSERT | 插入数据前触发 |
| AFTER | INSERT | 插入数据后触发 |
| BEFORE | UPDATE | 更新数据前触发 |
| AFTER | UPDATE | 更新数据后触发 |
| BEFORE | DELETE | 删除数据前触发 |
| AFTER | DELETE | 删除数据后触发 |

### 1.3 NEW 和 OLD

触发器中使用NEW和OLD引用变更的数据：

| 触发器类型 | NEW | OLD |
|-----------|-----|-----|
| **INSERT** | ✅ 新插入的数据 | ❌ 无 |
| **UPDATE** | ✅ 更新后的数据 | ✅ 更新前的数据 |
| **DELETE** | ❌ 无 | ✅ 被删除的数据 |

**示例：**
```sql
-- INSERT触发器
NEW.id, NEW.name  -- 访问新插入的数据

-- UPDATE触发器
OLD.price  -- 更新前的价格
NEW.price  -- 更新后的价格

-- DELETE触发器
OLD.id, OLD.name  -- 被删除的数据
```

### 1.4 💼 实际工作中什么时候用触发器？

**适合使用触发器的场景：**

**场景1：自动记录操作日志（最常用）**
```sql
-- 用户表的任何修改都自动记录到日志表
-- 应用场景：审计系统、数据追溯、安全合规
CREATE TRIGGER tr_users_audit
AFTER UPDATE ON users FOR EACH ROW
BEGIN
    INSERT INTO audit_logs(table_name, record_id, action, old_value, new_value)
    VALUES ('users', NEW.id, 'UPDATE', 
            JSON_OBJECT('name', OLD.name, 'email', OLD.email),
            JSON_OBJECT('name', NEW.name, 'email', NEW.email));
END;
```
**为什么用触发器**：自动执行，应用代码无需关心日志记录，不会遗漏。

**场景2：库存自动同步**
```sql
-- 订单创建时自动扣减库存
-- 应用场景：电商系统、进销存系统
CREATE TRIGGER tr_order_reduce_stock
AFTER INSERT ON order_items FOR EACH ROW
BEGIN
    UPDATE products SET stock = stock - NEW.quantity 
    WHERE id = NEW.product_id;
END;
```
**为什么用触发器**：数据一致性由数据库保证，减少应用层错误。

**场景3：数据校验（防止脏数据）**
```sql
-- 插入订单前检查库存是否充足
CREATE TRIGGER tr_check_stock
BEFORE INSERT ON order_items FOR EACH ROW
BEGIN
    DECLARE v_stock INT;
    SELECT stock INTO v_stock FROM products WHERE id = NEW.product_id;
    IF v_stock < NEW.quantity THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '库存不足';
    END IF;
END;
```
**为什么用触发器**：在数据层强制校验，任何方式（SQL、程序）插入都会检查。

**场景4：自动更新统计字段**
```sql
-- 用户下单后自动更新用户的订单统计
CREATE TRIGGER tr_update_user_stats
AFTER INSERT ON orders FOR EACH ROW
BEGIN
    UPDATE users SET 
        total_orders = total_orders + 1,
        total_amount = total_amount + NEW.amount
    WHERE id = NEW.user_id;
END;
```

**场景5：级联更新（代替外键级联）**
```sql
-- 商品分类删除时，自动更新商品的分类为"未分类"
CREATE TRIGGER tr_category_delete
BEFORE DELETE ON categories FOR EACH ROW
BEGIN
    UPDATE products SET category_id = 0 
    WHERE category_id = OLD.id;
END;
```

**不适合使用触发器的场景：**
- ❌ 复杂的业务逻辑（调试困难，维护成本高）
- ❌ 需要频繁修改的规则（每次改动都要ALTER触发器）
- ❌ 跨数据库的操作（触发器只能操作本库）
- ❌ 性能敏感的高并发场景（触发器会增加额外开销）
- ❌ 需要异步处理的场景（触发器是同步的）

**实际工作中的建议：**
- ✅ **推荐**：审计日志、数据校验、简单的级联更新
- ⚠️ **谨慎**：业务逻辑、复杂计算
- ❌ **不推荐**：频繁变更的规则、复杂的业务流程

**真实案例：**
- 🏦 **银行系统**：每笔交易自动记录审计日志（监管要求）
- 🛒 **电商平台**：订单状态变更自动记录到历史表
- 📊 **数据仓库**：源表数据变更自动同步到汇总表
- 🏥 **医疗系统**：患者信息修改自动记录（法律要求）

### 1.5 触发器限制

**注意事项：**
- ⚠️ MySQL只支持**行级触发器**，不支持语句级触发器
- ⚠️ 一个表的同一事件和时机只能定义一个触发器
- ⚠️ 触发器不能显式调用，只能由事件触发
- ⚠️ 触发器中不能使用CALL调用存储过程（5.0版本后支持）

---

## 二、触发器语法

### 2.1 创建触发器

**语法：**
```sql
CREATE TRIGGER 触发器名称
BEFORE/AFTER INSERT/UPDATE/DELETE
ON 表名
FOR EACH ROW  -- 行级触发器
BEGIN
    -- 触发器逻辑
END;
```

**示例：简单触发器**
```sql
DELIMITER $$

CREATE TRIGGER tr_users_insert
AFTER INSERT ON users
FOR EACH ROW
BEGIN
    INSERT INTO user_logs(operation, operation_time, user_id)
    VALUES ('INSERT', NOW(), NEW.id);
END$$

DELIMITER ;
```

### 2.2 查看触发器

```sql
-- 查看所有触发器
SHOW TRIGGERS;

-- 查看指定数据库的触发器
SHOW TRIGGERS FROM database_name;

-- 查看触发器详细信息
SELECT * FROM information_schema.TRIGGERS 
WHERE TRIGGER_SCHEMA = 'database_name';

-- 查看触发器定义
SHOW CREATE TRIGGER tr_users_insert;
```

### 2.3 删除触发器

```sql
DROP TRIGGER IF EXISTS tr_users_insert;
```

---

## 三、触发器应用

### 3.1 应用场景1：审计日志

**需求：**记录所有对用户表的增删改操作。

**第一步：创建日志表**
```sql
CREATE TABLE user_logs(
    id INT PRIMARY KEY AUTO_INCREMENT,
    operation VARCHAR(20) NOT NULL COMMENT '操作类型：INSERT/UPDATE/DELETE',
    operation_time DATETIME NOT NULL COMMENT '操作时间',
    operation_id INT NOT NULL COMMENT '操作的记录ID',
    operation_params TEXT COMMENT '操作详情',
    INDEX idx_time (operation_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**第二步：创建INSERT触发器**
```sql
DELIMITER $$

CREATE TRIGGER tr_users_insert_log
AFTER INSERT ON users
FOR EACH ROW
BEGIN
    INSERT INTO user_logs(operation, operation_time, operation_id, operation_params)
    VALUES (
        'INSERT',
        NOW(),
        NEW.id,
        CONCAT('新增用户：id=', NEW.id, 
               ', name=', NEW.name,
               ', email=', NEW.email)
    );
END$$

DELIMITER ;
```

**第三步：创建UPDATE触发器**
```sql
DELIMITER $$

CREATE TRIGGER tr_users_update_log
AFTER UPDATE ON users
FOR EACH ROW
BEGIN
    INSERT INTO user_logs(operation, operation_time, operation_id, operation_params)
    VALUES (
        'UPDATE',
        NOW(),
        NEW.id,
        CONCAT('更新用户：',
               '旧值[id=', OLD.id, ', name=', OLD.name, ', email=', OLD.email, '] ',
               '新值[id=', NEW.id, ', name=', NEW.name, ', email=', NEW.email, ']')
    );
END$$

DELIMITER ;
```

**第四步：创建DELETE触发器**
```sql
DELIMITER $$

CREATE TRIGGER tr_users_delete_log
AFTER DELETE ON users
FOR EACH ROW
BEGIN
    INSERT INTO user_logs(operation, operation_time, operation_id, operation_params)
    VALUES (
        'DELETE',
        NOW(),
        OLD.id,
        CONCAT('删除用户：id=', OLD.id,
               ', name=', OLD.name,
               ', email=', OLD.email)
    );
END$$

DELIMITER ;
```

**测试：**
```sql
-- 插入数据
INSERT INTO users(id, name, email) VALUES (1, '张三', 'zhang@example.com');

-- 更新数据
UPDATE users SET name = '张三丰' WHERE id = 1;

-- 删除数据
DELETE FROM users WHERE id = 1;

-- 查看日志
SELECT * FROM user_logs ORDER BY operation_time DESC;
```

### 3.2 应用场景2：数据校验

**需求：**插入订单时，自动检查库存是否充足。

```sql
DELIMITER $$

CREATE TRIGGER tr_orders_before_insert
BEFORE INSERT ON order_items
FOR EACH ROW
BEGIN
    DECLARE v_stock INT;
    
    -- 查询库存
    SELECT stock INTO v_stock 
    FROM products 
    WHERE id = NEW.product_id;
    
    -- 检查库存
    IF v_stock < NEW.quantity THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '库存不足，无法下单';
    END IF;
END$$

DELIMITER ;
```

### 3.3 应用场景3：自动更新统计

**需求：**订单状态改变时，自动更新用户的订单统计。

```sql
-- 用户表添加统计字段
ALTER TABLE users ADD COLUMN total_orders INT DEFAULT 0;
ALTER TABLE users ADD COLUMN total_amount DECIMAL(10,2) DEFAULT 0;

DELIMITER $$

-- 新增订单时更新统计
CREATE TRIGGER tr_orders_insert_stats
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    UPDATE users
    SET total_orders = total_orders + 1,
        total_amount = total_amount + NEW.amount
    WHERE id = NEW.user_id;
END$$

-- 删除订单时更新统计
CREATE TRIGGER tr_orders_delete_stats
AFTER DELETE ON orders
FOR EACH ROW
BEGIN
    UPDATE users
    SET total_orders = total_orders - 1,
        total_amount = total_amount - OLD.amount
    WHERE id = OLD.user_id;
END$$

DELIMITER ;
```

### 3.4 应用场景4：库存管理

**需求：**下单时自动扣减库存，取消订单时恢复库存。

```sql
DELIMITER $$

-- 下单扣减库存
CREATE TRIGGER tr_order_items_insert_stock
AFTER INSERT ON order_items
FOR EACH ROW
BEGIN
    UPDATE products
    SET stock = stock - NEW.quantity
    WHERE id = NEW.product_id;
END$$

-- 取消订单恢复库存
CREATE TRIGGER tr_order_items_delete_stock
AFTER DELETE ON order_items
FOR EACH ROW
BEGIN
    UPDATE products
    SET stock = stock + OLD.quantity
    WHERE id = OLD.product_id;
END$$

-- 修改订单数量调整库存
CREATE TRIGGER tr_order_items_update_stock
AFTER UPDATE ON order_items
FOR EACH ROW
BEGIN
    -- 恢复旧数量
    UPDATE products
    SET stock = stock + OLD.quantity
    WHERE id = OLD.product_id;
    
    -- 扣减新数量
    UPDATE products
    SET stock = stock - NEW.quantity
    WHERE id = NEW.product_id;
END$$

DELIMITER ;
```

### 3.5 应用场景5：数据同步

**需求：**主表数据变更时，自动同步到历史表。

```sql
-- 创建历史表
CREATE TABLE users_history LIKE users;
ALTER TABLE users_history ADD COLUMN change_type VARCHAR(10);
ALTER TABLE users_history ADD COLUMN change_time DATETIME;

DELIMITER $$

CREATE TRIGGER tr_users_to_history
AFTER UPDATE ON users
FOR EACH ROW
BEGIN
    INSERT INTO users_history
    SELECT *, 'UPDATE', NOW() FROM users WHERE id = NEW.id;
END$$

DELIMITER ;
```

---

## 四、触发器最佳实践

### 4.1 性能优化

**1. 避免复杂逻辑**
```sql
-- ❌ 不推荐：触发器中执行复杂查询
CREATE TRIGGER tr_complex
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    -- 复杂的统计查询
    SELECT COUNT(*), SUM(amount) FROM orders ...;
    -- 多表关联查询
    SELECT ... FROM t1 JOIN t2 JOIN t3 ...;
END;

-- ✅ 推荐：简单快速的操作
CREATE TRIGGER tr_simple
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    UPDATE statistics SET order_count = order_count + 1;
END;
```

**2. 避免递归触发**
```sql
-- ⚠️ 警告：可能导致无限循环
CREATE TRIGGER tr_users_update
AFTER UPDATE ON users
FOR EACH ROW
BEGIN
    UPDATE users SET updated_at = NOW() WHERE id = NEW.id;
    -- 这会再次触发触发器！
END;
```

### 4.2 错误处理

```sql
DELIMITER $$

CREATE TRIGGER tr_safe_insert
BEFORE INSERT ON orders
FOR EACH ROW
BEGIN
    -- 数据校验
    IF NEW.amount <= 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '订单金额必须大于0';
    END IF;
    
    IF NEW.user_id NOT IN (SELECT id FROM users) THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '用户不存在';
    END IF;
END$$

DELIMITER ;
```

### 4.3 命名规范

```sql
-- 推荐的命名规范：
-- tr_[表名]_[触发时机]_[操作类型]_[功能]

tr_users_after_insert_log      -- 用户表插入后记录日志
tr_orders_before_insert_check  -- 订单表插入前检查
tr_products_after_update_sync  -- 商品表更新后同步
```

### 4.4 使用建议

**✅ 适合使用触发器的场景：**
- 审计日志记录
- 简单的数据校验
- 统计字段的自动更新
- 数据同步（主从表）

**❌ 不适合使用触发器的场景：**
- 复杂的业务逻辑（应该在应用层处理）
- 大量数据处理（影响性能）
- 需要灵活控制的逻辑
- 跨数据库操作

### 4.5 调试技巧

```sql
-- 创建调试日志表
CREATE TABLE trigger_debug_log(
    id INT PRIMARY KEY AUTO_INCREMENT,
    trigger_name VARCHAR(50),
    message TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 在触发器中记录调试信息
DELIMITER $$

CREATE TRIGGER tr_debug_example
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    INSERT INTO trigger_debug_log(trigger_name, message)
    VALUES ('tr_debug_example', CONCAT('处理订单：', NEW.id));
    
    -- 触发器逻辑...
END$$

DELIMITER ;
```

---

## 五、综合案例

### 案例：完整的订单管理系统

```sql
-- 1. 创建表结构
CREATE TABLE products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    price DECIMAL(10,2),
    stock INT DEFAULT 0
);

CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    total_amount DECIMAL(10,2),
    status TINYINT DEFAULT 1,  -- 1:待支付 2:已支付 3:已取消
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE order_items (
    id INT PRIMARY KEY AUTO_INCREMENT,
    order_id INT,
    product_id INT,
    quantity INT,
    price DECIMAL(10,2)
);

-- 2. 创建日志表
CREATE TABLE order_logs (
    id INT PRIMARY KEY AUTO_INCREMENT,
    order_id INT,
    action VARCHAR(50),
    details TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 3. 下单时检查库存并扣减
DELIMITER $$

CREATE TRIGGER tr_order_items_check_stock
BEFORE INSERT ON order_items
FOR EACH ROW
BEGIN
    DECLARE v_stock INT;
    
    SELECT stock INTO v_stock FROM products WHERE id = NEW.product_id;
    
    IF v_stock < NEW.quantity THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '库存不足';
    END IF;
END$$

CREATE TRIGGER tr_order_items_reduce_stock
AFTER INSERT ON order_items
FOR EACH ROW
BEGIN
    UPDATE products 
    SET stock = stock - NEW.quantity 
    WHERE id = NEW.product_id;
    
    INSERT INTO order_logs(order_id, action, details)
    VALUES (NEW.order_id, 'STOCK_REDUCE', 
            CONCAT('商品', NEW.product_id, '库存减少', NEW.quantity));
END$$

-- 4. 取消订单恢复库存
CREATE TRIGGER tr_orders_cancel_restore_stock
AFTER UPDATE ON orders
FOR EACH ROW
BEGIN
    IF OLD.status != 3 AND NEW.status = 3 THEN
        UPDATE products p
        INNER JOIN order_items oi ON p.id = oi.product_id
        SET p.stock = p.stock + oi.quantity
        WHERE oi.order_id = NEW.id;
        
        INSERT INTO order_logs(order_id, action, details)
        VALUES (NEW.id, 'ORDER_CANCEL', '订单取消，库存已恢复');
    END IF;
END$$

DELIMITER ;

-- 5. 测试
INSERT INTO products VALUES (1, 'iPhone', 5999, 100);

INSERT INTO orders VALUES (1, 1, 5999, 1, NOW());
INSERT INTO order_items VALUES (1, 1, 1, 2, 5999);  -- 购买2台

SELECT * FROM products;  -- 库存变为98
SELECT * FROM order_logs;  -- 查看日志

UPDATE orders SET status = 3 WHERE id = 1;  -- 取消订单
SELECT * FROM products;  -- 库存恢复为100
```

---

## 六、本章总结

### 核心要点

1. **触发器**：自动执行的特殊存储过程
2. **触发时机**：BEFORE/AFTER + INSERT/UPDATE/DELETE
3. **NEW和OLD**：访问变更前后的数据
4. **应用场景**：审计日志、数据校验、自动统计、库存管理
5. **性能影响**：避免复杂逻辑，防止递归触发

### 优缺点

**优点：**
- ✅ 自动执行，无需手动调用
- ✅ 保证数据完整性和一致性
- ✅ 简化应用层代码
- ✅ 集中管理业务规则

**缺点：**
- ❌ 调试困难
- ❌ 影响性能（大批量操作）
- ❌ 可维护性差（隐藏逻辑）
- ❌ 可能导致意外的级联操作

### 使用建议

1. ✅ 命名清晰：`tr_[表名]_[时机]_[操作]_[功能]`
2. ✅ 保持简单：避免复杂逻辑
3. ✅ 添加注释：说明触发器用途
4. ✅ 充分测试：考虑各种边界情况
5. ⚠️ 谨慎使用：能在应用层处理的就不用触发器

---

## 练习题

```sql
-- 1. 创建员工薪资变更日志触发器
CREATE TABLE salary_logs (
    id INT PRIMARY KEY AUTO_INCREMENT,
    emp_id INT,
    old_salary DECIMAL(10,2),
    new_salary DECIMAL(10,2),
    change_time DATETIME
);

DELIMITER $$
CREATE TRIGGER tr_emp_salary_change
AFTER UPDATE ON employees
FOR EACH ROW
BEGIN
    IF OLD.salary != NEW.salary THEN
        INSERT INTO salary_logs VALUES 
        (NULL, NEW.id, OLD.salary, NEW.salary, NOW());
    END IF;
END$$
DELIMITER ;

-- 2. 创建商品价格限制触发器
DELIMITER $$
CREATE TRIGGER tr_product_price_check
BEFORE INSERT ON products
FOR EACH ROW
BEGIN
    IF NEW.price < 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '商品价格不能为负数';
    END IF;
END$$
DELIMITER ;
```

---

**下一章：[第13章 - 锁机制](13-锁机制.md)** →
