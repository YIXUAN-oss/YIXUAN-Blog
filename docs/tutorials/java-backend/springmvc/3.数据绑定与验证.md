---
title: 数据绑定与验证
---

# 数据绑定与验证

## 一、请求参数绑定

### 1.1 简单类型绑定

```java
@GetMapping("/user")
public String getUser(@RequestParam String name,
                     @RequestParam Integer age,
                     @RequestParam Boolean active) {
    // Spring 自动类型转换
    return "user";
}
```

### 1.2 对象绑定

**实体类：**
```java
public class User {
    private String name;
    private Integer age;
    private String email;
    // getter/setter
}
```

**Controller：**
```java
@PostMapping("/user")
public String addUser(User user) {
    // Spring 自动绑定属性
    // name=张三&age=20&email=test@example.com
    return "success";
}
```

### 1.3 嵌套对象绑定

**实体类：**
```java
public class User {
    private String name;
    private Address address; // 嵌套对象
    // getter/setter
}

public class Address {
    private String province;
    private String city;
    // getter/setter
}
```

**绑定：**
```java
@PostMapping("/user")
public String addUser(User user) {
    // 参数：name=张三&address.province=北京&address.city=朝阳
    return "success";
}
```

### 1.4 集合绑定

**List 绑定：**
```java
public class UserForm {
    private List<User> users;
    // getter/setter
}

@PostMapping("/users")
public String addUsers(UserForm form) {
    // 参数：users[0].name=张三&users[0].age=20&users[1].name=李四&users[1].age=25
    return "success";
}
```

**数组绑定：**
```java
@PostMapping("/delete")
public String delete(@RequestParam Long[] ids) {
    // 参数：ids=1&ids=2&ids=3
    return "success";
}
```

---

## 二、日期类型转换

### 2.1 问题

```java
@PostMapping("/user")
public String addUser(@RequestParam Date birthday) {
    // 默认格式：yyyy/MM/dd
    // 传入 2024-01-01 会报错
    return "success";
}
```

### 2.2 @DateTimeFormat

```java
@PostMapping("/user")
public String addUser(
    @RequestParam 
    @DateTimeFormat(pattern = "yyyy-MM-dd") 
    Date birthday) {
    // 可以接收 2024-01-01 格式
    return "success";
}
```

**实体类中使用：**
```java
public class User {
    private String name;
    
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    private Date birthday;
    // getter/setter
}
```

### 2.3 全局日期格式

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Override
    public void addFormatters(FormatterRegistry registry) {
        DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
        registrar.setDateFormatter(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
        registrar.registerFormatters(registry);
    }
}
```

---

## 三、数据验证

### 3.1 添加依赖

```xml
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>6.2.5.Final</version>
</dependency>
```

### 3.2 常用验证注解

| 注解 | 说明 |
|------|------|
| @NotNull | 不能为 null |
| @NotEmpty | 不能为 null 或空（字符串、集合） |
| @NotBlank | 不能为 null 或空白（字符串） |
| @Min | 最小值 |
| @Max | 最大值 |
| @Size | 长度范围 |
| @Email | 邮箱格式 |
| @Pattern | 正则表达式 |
| @Past | 过去的日期 |
| @Future | 未来的日期 |

### 3.3 使用验证

**实体类：**
```java
public class User {
    
    @NotBlank(message = "用户名不能为空")
    @Size(min = 2, max = 20, message = "用户名长度在2-20之间")
    private String username;
    
    @NotNull(message = "年龄不能为空")
    @Min(value = 1, message = "年龄最小为1")
    @Max(value = 150, message = "年龄最大为150")
    private Integer age;
    
    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    private String email;
    
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    private String phone;
    
    // getter/setter
}
```

**Controller：**
```java
@PostMapping("/user")
public String addUser(@Valid User user, BindingResult result) {
    // @Valid 启用验证
    // BindingResult 接收验证结果
    
    if (result.hasErrors()) {
        // 有错误
        List<ObjectError> errors = result.getAllErrors();
        for (ObjectError error : errors) {
            System.out.println(error.getDefaultMessage());
        }
        return "error";
    }
    
    userService.save(user);
    return "success";
}
```

### 3.4 RESTful 验证

```java
@RestController
@RequestMapping("/api/user")
public class UserController {
    
    @PostMapping
    public ResponseEntity<?> addUser(@Valid @RequestBody User user, 
                                     BindingResult result) {
        if (result.hasErrors()) {
            Map<String, String> errors = new HashMap<>();
            result.getFieldErrors().forEach(error -> 
                errors.put(error.getField(), error.getDefaultMessage())
            );
            return ResponseEntity.badRequest().body(errors);
        }
        
        userService.save(user);
        return ResponseEntity.ok("success");
    }
}
```

---

## 四、分组验证

### 4.1 定义分组

```java
// 定义分组接口
public interface AddGroup {}
public interface UpdateGroup {}
```

### 4.2 使用分组

```java
public class User {
    
    @NotNull(groups = UpdateGroup.class, message = "更新时ID不能为空")
    private Long id;
    
    @NotBlank(groups = {AddGroup.class, UpdateGroup.class}, 
             message = "用户名不能为空")
    private String username;
    
    // getter/setter
}
```

**Controller：**
```java
@PostMapping("/add")
public String add(@Validated(AddGroup.class) User user, 
                  BindingResult result) {
    // 只验证 AddGroup 的规则
    return "success";
}

@PutMapping("/update")
public String update(@Validated(UpdateGroup.class) User user, 
                     BindingResult result) {
    // 只验证 UpdateGroup 的规则
    return "success";
}
```

---

## 五、自定义验证器

### 5.1 创建注解

```java
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PhoneValidator.class)
public @interface Phone {
    String message() default "手机号格式不正确";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
```

### 5.2 创建验证器

```java
public class PhoneValidator implements ConstraintValidator<Phone, String> {
    
    @Override
    public void initialize(Phone phone) {
        // 初始化
    }
    
    @Override
    public boolean isValid(String value, 
                          ConstraintValidatorContext context) {
        if (value == null || value.isEmpty()) {
            return true; // 空值交给 @NotBlank 处理
        }
        return value.matches("^1[3-9]\\d{9}$");
    }
}
```

### 5.3 使用自定义验证

```java
public class User {
    @Phone(message = "手机号格式不正确")
    private String phone;
    // getter/setter
}
```

---

## 六、JSON数据绑定

### 6.1 @RequestBody

```java
@PostMapping("/user")
public String addUser(@RequestBody User user) {
    // 接收 JSON 数据
    // {"name":"张三","age":20}
    return "success";
}
```

### 6.2 Jackson 注解

```java
public class User {
    
    @JsonProperty("user_name") // JSON 字段名映射
    private String name;
    
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss") // 日期格式
    private Date createTime;
    
    @JsonIgnore // 忽略字段
    private String password;
    
    // getter/setter
}
```

---

## 七、类型转换器

### 7.1 自定义转换器

```java
public class StringToDateConverter implements Converter<String, Date> {
    
    @Override
    public Date convert(String source) {
        try {
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
            return sdf.parse(source);
        } catch (ParseException e) {
            throw new RuntimeException(e);
        }
    }
}
```

### 7.2 注册转换器

```xml
<mvc:annotation-driven conversion-service="conversionService"/>

<bean id="conversionService" 
      class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
    <property name="converters">
        <set>
            <bean class="com.example.converter.StringToDateConverter"/>
        </set>
    </property>
</bean>
```

---

## 八、总结

✅ **本章学习内容：**
- 请求参数绑定
- 日期类型转换
- 数据验证（JSR-303）
- 分组验证
- 自定义验证器
- JSON 数据绑定

✅ **核心要点：**
- Spring MVC 自动完成参数绑定和类型转换
- 使用 @Valid 进行数据验证
- 使用 BindingResult 获取验证结果
- 合理使用分组验证
- 掌握自定义验证器的创建

**下一章预告：** 我们将学习 RESTful 接口开发。
