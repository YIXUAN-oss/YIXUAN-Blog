---
title: Spring AOP
---

# Spring AOP

## 一、AOP概述

### 1.1 什么是AOP？

**AOP（Aspect Oriented Programming）**：面向切面编程，是一种编程思想。

**核心思想：** 将横切关注点（cross-cutting concerns）从业务逻辑中分离出来。

**横切关注点示例：**
- 日志记录
- 权限检查
- 事务管理
- 性能监控
- 异常处理

**传统方式的问题：**
```java
public class UserService {
    public void addUser(User user) {
        // 日志记录
        System.out.println("开始添加用户");
        
        // 权限检查
        checkPermission();
        
        // 业务逻辑
        userDao.save(user);
        
        // 日志记录
        System.out.println("添加用户完成");
    }
}
```

**问题：**
- 代码重复：每个方法都要写日志、权限检查
- 代码混乱：业务逻辑与横切关注点混在一起
- 难以维护：修改日志逻辑需要改动所有方法

**AOP 方式：**
```java
// 业务类：只关注业务逻辑
public class UserService {
    public void addUser(User user) {
        userDao.save(user); // 纯粹的业务逻辑
    }
}

// 切面类：统一处理横切关注点
@Aspect
@Component
public class LogAspect {
    @Around("execution(* com.example.service.*.*(..))")
    public Object log(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("开始执行方法");
        Object result = pjp.proceed();
        System.out.println("方法执行完成");
        return result;
    }
}
```

### 1.2 AOP的优势

✅ **代码解耦**：业务逻辑和横切关注点分离
✅ **代码复用**：横切逻辑只需写一次
✅ **易于维护**：修改横切逻辑不影响业务代码
✅ **集中管理**：统一管理日志、事务等功能

---

## 二、AOP核心概念

### 2.1 核心术语

| 术语 | 说明 | 示例 |
|------|------|------|
| **切面（Aspect）** | 横切关注点的模块化 | 日志切面、事务切面 |
| **连接点（Join Point）** | 可以被拦截的点 | 方法调用、异常抛出 |
| **切点（Pointcut）** | 要拦截哪些连接点 | 所有 Service 层的方法 |
| **通知（Advice）** | 在切点执行的操作 | 前置通知、后置通知 |
| **目标对象（Target）** | 被代理的对象 | UserService 对象 |
| **代理（Proxy）** | AOP 创建的代理对象 | UserService 的代理 |
| **织入（Weaving）** | 将切面应用到目标对象 | 运行时织入 |

**关系：**
```
切面（Aspect） = 切点（Pointcut） + 通知（Advice）

在什么地方（切点）做什么（通知）
```

### 2.2 通知类型

| 通知类型 | 注解 | 执行时机 |
|---------|------|---------|
| **前置通知** | @Before | 目标方法执行前 |
| **后置通知** | @After | 目标方法执行后（无论是否异常） |
| **返回通知** | @AfterReturning | 目标方法正常返回后 |
| **异常通知** | @AfterThrowing | 目标方法抛出异常后 |
| **环绕通知** | @Around | 包围目标方法执行 |

**执行顺序：**
```
正常流程：
@Before → 目标方法 → @AfterReturning → @After

异常流程：
@Before → 目标方法 → @AfterThrowing → @After

环绕通知：
@Around {
    前置逻辑
    → 目标方法
    → 后置逻辑
}
```

---

## 三、AOP的实现方式

### 3.1 JDK 动态代理

**特点：**
- 基于接口的代理
- 目标对象必须实现接口
- 代理对象和目标对象实现相同的接口

**示例：**
```java
// 接口
public interface UserService {
    void addUser();
}

// 实现类
public class UserServiceImpl implements UserService {
    @Override
    public void addUser() {
        System.out.println("添加用户");
    }
}

// JDK 动态代理
UserService proxy = (UserService) Proxy.newProxyInstance(
    UserServiceImpl.class.getClassLoader(),
    new Class[]{UserService.class},
    (proxy, method, args) -> {
        System.out.println("前置通知");
        Object result = method.invoke(new UserServiceImpl(), args);
        System.out.println("后置通知");
        return result;
    }
);

proxy.addUser();
```

### 3.2 CGLIB 代理

**特点：**
- 基于继承的代理
- 不需要实现接口
- 代理对象是目标对象的子类
- 不能代理 final 类和 final 方法

**Spring AOP 的选择：**
```
如果目标对象实现了接口 → JDK 动态代理
如果目标对象没有实现接口 → CGLIB 代理
```

**强制使用 CGLIB：**
```java
@EnableAspectJAutoProxy(proxyTargetClass = true)
```

---

## 四、切点表达式

### 4.1 execution 表达式

**语法：**
```
execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)

execution(修饰符? 返回值 包名.类名?方法名(参数) 异常?)
```

**常用写法：**

```java
// 1. 匹配所有方法
execution(* *(..))

// 2. 匹配指定包下的所有方法
execution(* com.example.service.*.*(..))

// 3. 匹配指定类的所有方法
execution(* com.example.service.UserService.*(..))

// 4. 匹配指定方法
execution(* com.example.service.UserService.addUser(..))

// 5. 匹配指定包及子包
execution(* com.example.service..*.*(..))

// 6. 匹配指定返回值类型
execution(String com.example.service.*.*(..))

// 7. 匹配指定参数
execution(* com.example.service.*.*(String, int))

// 8. 匹配指定修饰符
execution(public * com.example.service.*.*(..))
```

**通配符：**
- `*`：匹配任意字符
- `..`：匹配任意数量的包或参数
- `+`：匹配指定类及其子类

### 4.2 其他切点表达式

**@annotation：**
```java
// 匹配带有指定注解的方法
@Pointcut("@annotation(org.springframework.transaction.annotation.Transactional)")
```

**within：**
```java
// 匹配指定包下的所有方法
@Pointcut("within(com.example.service..*)")
```

**args：**
```java
// 匹配参数类型
@Pointcut("args(String, int)")
```

**@within：**
```java
// 匹配带有指定注解的类中的所有方法
@Pointcut("@within(org.springframework.stereotype.Service)")
```

### 4.3 切点表达式组合

```java
// 逻辑与
@Pointcut("execution(* com.example.service.*.*(..)) && args(String)")

// 逻辑或
@Pointcut("execution(* com.example.service.*.*(..)) || execution(* com.example.dao.*.*(..))")

// 逻辑非
@Pointcut("execution(* com.example.service.*.*(..)) && !execution(* com.example.service.UserService.*(..))")
```

---

## 五、通知详解

### 5.1 @Before 前置通知

**执行时机：** 目标方法执行之前

**示例：**
```java
@Aspect
@Component
public class LogAspect {
    
    @Before("execution(* com.example.service.*.*(..))")
    public void before(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        System.out.println("方法 " + methodName + " 开始执行，参数：" + Arrays.toString(args));
    }
}
```

### 5.2 @After 后置通知

**执行时机：** 目标方法执行之后（无论是否抛出异常）

**示例：**
```java
@After("execution(* com.example.service.*.*(..))")
public void after(JoinPoint joinPoint) {
    System.out.println("方法 " + joinPoint.getSignature().getName() + " 执行完成");
}
```

### 5.3 @AfterReturning 返回通知

**执行时机：** 目标方法正常返回后

**示例：**
```java
@AfterReturning(
    pointcut = "execution(* com.example.service.*.*(..))",
    returning = "result"
)
public void afterReturning(JoinPoint joinPoint, Object result) {
    System.out.println("方法 " + joinPoint.getSignature().getName() + " 返回值：" + result);
}
```

### 5.4 @AfterThrowing 异常通知

**执行时机：** 目标方法抛出异常后

**示例：**
```java
@AfterThrowing(
    pointcut = "execution(* com.example.service.*.*(..))",
    throwing = "ex"
)
public void afterThrowing(JoinPoint joinPoint, Exception ex) {
    System.out.println("方法 " + joinPoint.getSignature().getName() + " 抛出异常：" + ex.getMessage());
}
```

### 5.5 @Around 环绕通知

**执行时机：** 包围目标方法执行

**特点：**
- 功能最强大
- 可以控制目标方法是否执行
- 可以修改参数和返回值

**示例：**
```java
@Around("execution(* com.example.service.*.*(..))")
public Object around(ProceedingJoinPoint pjp) throws Throwable {
    System.out.println("环绕通知 - 前置");
    
    // 修改参数
    Object[] args = pjp.getArgs();
    
    // 执行目标方法
    Object result = pjp.proceed(args);
    
    System.out.println("环绕通知 - 后置");
    
    // 修改返回值
    return result;
}
```

---

## 六、AOP实战应用

### 6.1 日志记录

```java
@Aspect
@Component
@Slf4j
public class LogAspect {
    
    @Around("execution(* com.example.service.*.*(..))")
    public Object log(ProceedingJoinPoint pjp) throws Throwable {
        String className = pjp.getTarget().getClass().getName();
        String methodName = pjp.getSignature().getName();
        Object[] args = pjp.getArgs();
        
        log.info("开始执行：{}.{}，参数：{}", className, methodName, args);
        
        long startTime = System.currentTimeMillis();
        Object result = null;
        
        try {
            result = pjp.proceed();
            long endTime = System.currentTimeMillis();
            log.info("执行成功：{}.{}，耗时：{}ms，返回值：{}", 
                     className, methodName, (endTime - startTime), result);
        } catch (Throwable e) {
            log.error("执行失败：{}.{}，异常：{}", className, methodName, e.getMessage());
            throw e;
        }
        
        return result;
    }
}
```

### 6.2 权限校验

**自定义注解：**
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequirePermission {
    String value(); // 需要的权限
}
```

**切面：**
```java
@Aspect
@Component
public class PermissionAspect {
    
    @Before("@annotation(permission)")
    public void checkPermission(JoinPoint joinPoint, RequirePermission permission) {
        String requiredPermission = permission.value();
        
        // 获取当前用户
        User currentUser = getCurrentUser();
        
        // 检查权限
        if (!currentUser.hasPermission(requiredPermission)) {
            throw new PermissionDeniedException("权限不足");
        }
    }
}
```

**使用：**
```java
@Service
public class UserService {
    
    @RequirePermission("user:add")
    public void addUser(User user) {
        userDao.save(user);
    }
}
```

### 6.3 性能监控

```java
@Aspect
@Component
public class PerformanceAspect {
    
    @Around("execution(* com.example.service.*.*(..))")
    public Object monitor(ProceedingJoinPoint pjp) throws Throwable {
        long startTime = System.currentTimeMillis();
        
        Object result = pjp.proceed();
        
        long endTime = System.currentTimeMillis();
        long duration = endTime - startTime;
        
        // 如果执行时间超过 1 秒，记录警告
        if (duration > 1000) {
            System.out.println("警告：方法 " + pjp.getSignature().getName() 
                             + " 执行时间过长：" + duration + "ms");
        }
        
        return result;
    }
}
```

### 6.4 异常处理

```java
@Aspect
@Component
@Slf4j
public class ExceptionAspect {
    
    @AfterThrowing(
        pointcut = "execution(* com.example.service.*.*(..))",
        throwing = "ex"
    )
    public void handleException(JoinPoint joinPoint, Exception ex) {
        String methodName = joinPoint.getSignature().getName();
        
        // 记录异常日志
        log.error("方法 {} 抛出异常", methodName, ex);
        
        // 发送告警
        sendAlert(methodName, ex);
        
        // 保存异常信息到数据库
        saveExceptionLog(methodName, ex);
    }
}
```

---

## 七、完整示例

### 7.1 项目结构

```
src/main/java/com/example/
├── aspect/
│   ├── LogAspect.java
│   └── PerformanceAspect.java
├── service/
│   ├── UserService.java
│   └── OrderService.java
├── config/
│   └── AppConfig.java
└── App.java
```

### 7.2 启用AOP

```java
@Configuration
@ComponentScan("com.example")
@EnableAspectJAutoProxy  // 启用 AOP
public class AppConfig {
}
```

### 7.3 定义切面

```java
@Aspect
@Component
public class LogAspect {
    
    // 定义切点
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethod() {}
    
    // 前置通知
    @Before("serviceMethod()")
    public void before(JoinPoint joinPoint) {
        System.out.println("=== 前置通知 ===");
        System.out.println("方法：" + joinPoint.getSignature().getName());
    }
    
    // 后置通知
    @After("serviceMethod()")
    public void after() {
        System.out.println("=== 后置通知 ===");
    }
    
    // 返回通知
    @AfterReturning(pointcut = "serviceMethod()", returning = "result")
    public void afterReturning(Object result) {
        System.out.println("=== 返回通知 ===");
        System.out.println("返回值：" + result);
    }
    
    // 异常通知
    @AfterThrowing(pointcut = "serviceMethod()", throwing = "ex")
    public void afterThrowing(Exception ex) {
        System.out.println("=== 异常通知 ===");
        System.out.println("异常：" + ex.getMessage());
    }
    
    // 环绕通知
    @Around("serviceMethod()")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("=== 环绕通知 - 开始 ===");
        Object result = pjp.proceed();
        System.out.println("=== 环绕通知 - 结束 ===");
        return result;
    }
}
```

### 7.4 业务类

```java
@Service
public class UserService {
    
    public String getUser(Long id) {
        System.out.println(">>> 执行 getUser 方法");
        return "User-" + id;
    }
    
    public void throwException() {
        throw new RuntimeException("测试异常");
    }
}
```

### 7.5 测试

```java
public class App {
    public static void main(String[] args) {
        ApplicationContext context = 
            new AnnotationConfigApplicationContext(AppConfig.class);
        
        UserService userService = context.getBean(UserService.class);
        
        // 测试正常方法
        String user = userService.getUser(1L);
        
        // 测试异常方法
        try {
            userService.throwException();
        } catch (Exception e) {
            // 忽略
        }
    }
}
```

---

## 八、常见问题

### 8.1 AOP不生效

**原因1：未启用AOP**
```java
@Configuration
@EnableAspectJAutoProxy  // 必须添加
public class AppConfig {
}
```

**原因2：切点表达式错误**
```java
// 错误：包名不对
@Before("execution(* com.wrong.package.*.*(..))")

// 正确
@Before("execution(* com.example.service.*.*(..))")
```

**原因3：方法内部调用**
```java
@Service
public class UserService {
    public void methodA() {
        this.methodB(); // AOP 不生效
    }
    
    public void methodB() {
        // ...
    }
}

// 解决方案：注入自己
@Autowired
private UserService self;

public void methodA() {
    self.methodB(); // AOP 生效
}
```

### 8.2 多个切面的执行顺序

**使用 @Order 指定顺序：**
```java
@Aspect
@Component
@Order(1)  // 数字越小，优先级越高
public class LogAspect {
}

@Aspect
@Component
@Order(2)
public class PermissionAspect {
}
```

---

## 九、总结

✅ **本章学习内容：**
- AOP 的概念和优势
- AOP 核心术语
- 切点表达式的编写
- 五种通知类型
- AOP 实战应用

✅ **核心要点：**
- AOP 用于分离横切关注点
- 切面 = 切点 + 通知
- @Around 最强大，可控制全过程
- 合理使用 AOP 提高代码质量

**下一章预告：** 我们将学习 Spring 事务管理。
