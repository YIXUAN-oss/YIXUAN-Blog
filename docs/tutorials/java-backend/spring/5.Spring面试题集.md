---
title: Spring面试题集
---

# Spring面试题集

## 一、IoC和DI

### 1. 什么是Spring IoC？

**答：**

**IoC（Inversion of Control）控制反转**，是一种设计思想。

**传统方式：** 程序员主动创建对象
```java
UserService service = new UserServiceImpl();
```

**IoC方式：** 由Spring容器创建和管理对象
```java
@Autowired
private UserService service; // Spring注入
```

**核心思想：** 将对象的创建权和控制权交给Spring容器管理。

**优势：**
- 降低耦合度
- 易于测试和维护
- 提高代码复用性

---

### 2. 什么是依赖注入？有哪些方式？

**答：**

**DI（Dependency Injection）依赖注入**，是IoC的一种实现方式。

**三种注入方式：**

**1. 构造器注入（推荐）**
```java
@Service
public class UserService {
    private final UserDao userDao;
    
    @Autowired
    public UserService(UserDao userDao) {
        this.userDao = userDao;
    }
}
```
**优点：** 依赖不可变、保证不为null、易于测试

**2. Setter注入**
```java
@Service
public class UserService {
    private UserDao userDao;
    
    @Autowired
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

**3. 字段注入（不推荐）**
```java
@Service
public class UserService {
    @Autowired
    private UserDao userDao;
}
```
**缺点：** 无法注入final字段、难以测试、违反封装

---

### 3. BeanFactory和ApplicationContext的区别？

**答：**

| 特性 | BeanFactory | ApplicationContext |
|------|-------------|-------------------|
| 功能 | 基础IoC容器 | 高级IoC容器 |
| 加载方式 | 延迟加载 | 立即加载 |
| 国际化 | 不支持 | 支持 |
| 事件发布 | 不支持 | 支持 |
| AOP | 手动配置 | 自动配置 |
| 使用场景 | 资源受限环境 | 企业级应用 |

**推荐使用：** ApplicationContext

**常用实现类：**
```java
// XML配置
ApplicationContext context = 
    new ClassPathXmlApplicationContext("applicationContext.xml");

// 注解配置
ApplicationContext context = 
    new AnnotationConfigApplicationContext(AppConfig.class);

// Web应用
// 自动创建，在web.xml中配置ContextLoaderListener
```

---

### 4. @Autowired和@Resource的区别？

**答：**

| 特性 | @Autowired | @Resource |
|------|-----------|-----------|
| 来源 | Spring | JDK (JSR-250) |
| 装配方式 | 按类型 | 按名称 |
| 支持范围 | 字段、构造器、方法 | 字段、Setter |
| 必需性 | required属性 | 无 |
| 配合使用 | @Qualifier | name属性 |

**示例：**
```java
// @Autowired - 按类型
@Autowired
@Qualifier("userDaoImpl")
private UserDao userDao;

// @Resource - 按名称
@Resource(name = "userDaoImpl")
private UserDao userDao;
```

**推荐：** 优先使用@Autowired（Spring标准）

---

## 二、Bean管理

### 5. Spring Bean的作用域有哪些？

**答：**

| 作用域 | 说明 |
|--------|------|
| **singleton** | 单例，容器中只有一个实例（默认） |
| **prototype** | 原型，每次获取创建新实例 |
| **request** | 每个HTTP请求一个实例（Web） |
| **session** | 每个HTTP会话一个实例（Web） |
| **application** | 整个Web应用一个实例（Web） |

**配置：**
```java
@Service
@Scope("singleton") // 或 "prototype"
public class UserService {
}
```

**注意：** 
- singleton是线程不安全的，避免使用成员变量
- prototype每次都创建新对象，注意内存

---

### 6. Spring Bean的生命周期？

**答：**

**完整流程：**
```
1. 实例化Bean（调用构造器）
2. 设置属性值（依赖注入）
3. 调用BeanNameAware的setBeanName()
4. 调用BeanFactoryAware的setBeanFactory()
5. 调用ApplicationContextAware的setApplicationContext()
6. 调用BeanPostProcessor的postProcessBeforeInitialization()
7. 调用@PostConstruct方法
8. 调用InitializingBean的afterPropertiesSet()
9. 调用自定义init-method
10. 调用BeanPostProcessor的postProcessAfterInitialization()
11. Bean可以使用了
12. 容器关闭
13. 调用@PreDestroy方法
14. 调用DisposableBean的destroy()
15. 调用自定义destroy-method
```

**简化版：**
```
实例化 → 属性赋值 → 初始化 → 使用 → 销毁
```

**示例：**
```java
@Component
public class User {
    
    public User() {
        System.out.println("1. 构造器");
    }
    
    @Autowired
    public void setName(String name) {
        System.out.println("2. 属性赋值");
    }
    
    @PostConstruct
    public void init() {
        System.out.println("3. 初始化");
    }
    
    @PreDestroy
    public void destroy() {
        System.out.println("5. 销毁");
    }
}
```

---

### 7. Spring如何解决循环依赖？

**答：**

**循环依赖：** A依赖B，B又依赖A。

**Spring的解决方案：三级缓存**

```java
// 一级缓存：完整的Bean
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>();

// 二级缓存：早期Bean（未完成初始化）
private final Map<String, Object> earlySingletonObjects = new HashMap<>();

// 三级缓存：Bean工厂
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>();
```

**解决过程：**
```
1. 创建A，放入三级缓存
2. A需要注入B
3. 创建B，放入三级缓存
4. B需要注入A
5. 从三级缓存获取A（早期引用）
6. B创建完成，放入一级缓存
7. A注入B
8. A创建完成，放入一级缓存
```

**限制：**
- 只能解决单例Bean的循环依赖
- 构造器注入的循环依赖无法解决
- 原型Bean的循环依赖无法解决

**解决构造器循环依赖：**
- 使用@Lazy延迟注入
- 重新设计，避免循环依赖

---

## 三、AOP

### 8. 什么是AOP？AOP的应用场景？

**答：**

**AOP（Aspect Oriented Programming）面向切面编程。**

**核心思想：** 将横切关注点从业务逻辑中分离。

**应用场景：**
- ✅ 日志记录
- ✅ 权限检查
- ✅ 事务管理
- ✅ 性能监控
- ✅ 异常处理
- ✅ 缓存管理

**示例：**
```java
@Aspect
@Component
public class LogAspect {
    @Around("execution(* com.example.service.*.*(..))")
    public Object log(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("开始执行");
        Object result = pjp.proceed();
        System.out.println("执行完成");
        return result;
    }
}
```

---

### 9. AOP的核心概念？

**答：**

| 概念 | 说明 |
|------|------|
| **切面（Aspect）** | 横切关注点的模块化 |
| **连接点（Join Point）** | 可以被拦截的点 |
| **切点（Pointcut）** | 要拦截哪些连接点 |
| **通知（Advice）** | 在切点执行的操作 |
| **目标对象（Target）** | 被代理的对象 |
| **代理（Proxy）** | AOP创建的代理对象 |
| **织入（Weaving）** | 将切面应用到目标对象 |

**关系：** 切面 = 切点 + 通知

---

### 10. AOP的实现方式？

**答：**

**1. JDK动态代理**
- 基于接口
- 目标对象必须实现接口
- 代理对象和目标对象实现相同接口

**2. CGLIB代理**
- 基于继承
- 不需要实现接口
- 代理对象是目标对象的子类
- 不能代理final类和final方法

**Spring的选择：**
```
有接口 → JDK动态代理
无接口 → CGLIB代理
```

**强制使用CGLIB：**
```java
@EnableAspectJAutoProxy(proxyTargetClass = true)
```

---

### 11. 通知的类型和执行顺序？

**答：**

**通知类型：**
- @Before：前置通知
- @After：后置通知
- @AfterReturning：返回通知
- @AfterThrowing：异常通知
- @Around：环绕通知

**执行顺序：**
```
正常流程：
@Around前置 → @Before → 目标方法 → @AfterReturning → @After → @Around后置

异常流程：
@Around前置 → @Before → 目标方法 → @AfterThrowing → @After
```

**示例：**
```java
@Aspect
@Component
public class LogAspect {
    
    @Before("execution(* com.example.service.*.*(..))")
    public void before() {
        System.out.println("前置通知");
    }
    
    @After("execution(* com.example.service.*.*(..))")
    public void after() {
        System.out.println("后置通知");
    }
    
    @AfterReturning(pointcut = "execution(...)", returning = "result")
    public void afterReturning(Object result) {
        System.out.println("返回通知: " + result);
    }
    
    @AfterThrowing(pointcut = "execution(...)", throwing = "ex")
    public void afterThrowing(Exception ex) {
        System.out.println("异常通知: " + ex.getMessage());
    }
    
    @Around("execution(* com.example.service.*.*(..))")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("环绕前置");
        Object result = pjp.proceed();
        System.out.println("环绕后置");
        return result;
    }
}
```

---

## 四、事务管理

### 12. Spring事务的实现方式？

**答：**

**1. 编程式事务**
```java
@Autowired
private TransactionTemplate transactionTemplate;

public void save() {
    transactionTemplate.execute(status -> {
        // 业务操作
        return null;
    });
}
```
**缺点：** 代码侵入性强

**2. 声明式事务（推荐）**
```java
@Transactional
public void save() {
    // 业务操作
}
```
**优点：** 代码简洁，业务逻辑和事务管理分离

---

### 13. @Transactional的属性？

**答：**

| 属性 | 说明 |
|------|------|
| **propagation** | 事务传播行为 |
| **isolation** | 事务隔离级别 |
| **timeout** | 超时时间（秒） |
| **readOnly** | 是否只读 |
| **rollbackFor** | 回滚的异常类型 |
| **noRollbackFor** | 不回滚的异常类型 |

**完整示例：**
```java
@Transactional(
    propagation = Propagation.REQUIRED,
    isolation = Isolation.READ_COMMITTED,
    timeout = 30,
    readOnly = false,
    rollbackFor = Exception.class
)
public void save() {
    // 业务操作
}
```

---

### 14. 事务的传播行为有哪些？

**答：**

| 传播行为 | 说明 |
|---------|------|
| **REQUIRED** | 有事务就加入，没有就创建（默认） |
| **REQUIRES_NEW** | 总是创建新事务，挂起当前事务 |
| **SUPPORTS** | 有事务就加入，没有就非事务执行 |
| **NOT_SUPPORTED** | 非事务执行，挂起当前事务 |
| **MANDATORY** | 必须在事务中执行，否则抛异常 |
| **NEVER** | 非事务执行，有事务就抛异常 |
| **NESTED** | 嵌套事务 |

**常用场景：**

**REQUIRED（最常用）：**
```java
@Transactional(propagation = Propagation.REQUIRED)
public void save() {
    // 加入当前事务或创建新事务
}
```

**REQUIRES_NEW：**
```java
// 日志记录使用独立事务
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void saveLog() {
    // 独立事务，不受外层事务影响
}
```

---

### 15. 事务的隔离级别？

**答：**

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
|---------|------|-----------|------|
| READ_UNCOMMITTED | ✓ | ✓ | ✓ |
| READ_COMMITTED | × | ✓ | ✓ |
| REPEATABLE_READ | × | × | ✓ |
| SERIALIZABLE | × | × | × |

**并发问题：**
- **脏读：** 读到未提交的数据
- **不可重复读：** 同一事务多次读取数据不一致
- **幻读：** 同一事务多次查询记录数不一致

**MySQL默认：** REPEATABLE_READ

**使用：**
```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void transfer() {
    // 读已提交
}
```

---

### 16. 事务失效的场景？

**答：**

**1. 方法内部调用**
```java
public void methodA() {
    this.methodB(); // 事务失效
}

@Transactional
public void methodB() {
}
```
**原因：** 不经过代理
**解决：** 注入自己或从容器获取

**2. 方法非public**
```java
@Transactional
private void save() { // 失效
}
```
**解决：** 改为public

**3. 异常被捕获**
```java
@Transactional
public void save() {
    try {
        // 操作
    } catch (Exception e) {
        // 异常被捕获，不回滚
    }
}
```
**解决：** 手动回滚或重新抛出

**4. 异常类型不匹配**
```java
@Transactional // 默认只回滚RuntimeException
public void save() throws Exception {
    throw new Exception(); // 不会回滚
}
```
**解决：**
```java
@Transactional(rollbackFor = Exception.class)
```

**5. 数据库不支持事务**
- MySQL的MyISAM不支持事务
- 使用InnoDB引擎

---

## 五、Spring Boot

### 17. Spring和Spring Boot的区别？

**答：**

| 特性 | Spring | Spring Boot |
|------|--------|-------------|
| 配置 | 大量XML/注解配置 | 自动配置 |
| 依赖管理 | 手动管理版本 | starter统一管理 |
| 内嵌服务器 | 需外部Tomcat | 内置Tomcat |
| 学习曲线 | 陡峭 | 平缓 |
| 开发效率 | 一般 | 高 |

**Spring Boot的优势：**
- ✅ 开箱即用
- ✅ 约定优于配置
- ✅ 快速开发
- ✅ 生产就绪（监控、健康检查）

---

### 18. Spring Boot自动配置原理？

**答：**

**核心注解：** @SpringBootApplication

```java
@SpringBootApplication
= @SpringBootConfiguration  // 配置类
+ @EnableAutoConfiguration  // 自动配置
+ @ComponentScan           // 组件扫描
```

**自动配置流程：**
```
1. @EnableAutoConfiguration 启用自动配置
2. 加载 spring.factories 文件
3. 读取所有自动配置类
4. 根据条件注解判断是否生效
5. 创建对应的Bean
```

**条件注解：**
```java
@ConditionalOnClass(DataSource.class)  // 类存在
@ConditionalOnMissingBean(DataSource.class)  // Bean不存在
@ConditionalOnProperty(name = "app.enabled")  // 属性匹配
```

---

## 六、综合题

### 19. Spring中用到了哪些设计模式？

**答：**

| 设计模式 | 应用 |
|---------|------|
| **工厂模式** | BeanFactory |
| **单例模式** | Bean默认单例 |
| **代理模式** | AOP |
| **模板方法** | JdbcTemplate |
| **观察者模式** | ApplicationEvent |
| **适配器模式** | HandlerAdapter |
| **装饰器模式** | BeanWrapper |
| **策略模式** | Resource加载 |

---

### 20. 如何优化Spring应用的启动速度？

**答：**

**1. 使用懒加载**
```java
@Lazy
@Component
public class ExpensiveBean {
}
```

**2. 减少组件扫描范围**
```java
@ComponentScan("com.example.specific")
```

**3. 排除不需要的自动配置**
```java
@SpringBootApplication(exclude = {
    DataSourceAutoConfiguration.class
})
```

**4. 使用索引**
```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context-indexer</artifactId>
</dependency>
```

**5. 调整JVM参数**
```bash
-XX:TieredStopAtLevel=1
-noverify
```

---

## 七、总结

### 高频考点

✅ **必须掌握：**
- IoC和DI的概念
- Bean的生命周期
- AOP的原理和应用
- 事务的传播行为和隔离级别
- @Autowired和@Resource的区别
- 事务失效场景

✅ **加分项：**
- 循环依赖的解决
- Spring Boot自动配置原理
- 设计模式的应用
- 性能优化经验

### 面试技巧

1. **先说原理，再举例子**
2. **对比说明**（如@Autowired vs @Resource）
3. **结合实际项目经验**
4. **说明遇到的问题和解决方案**

### 复习建议

- 熟记Bean生命周期
- 理解事务传播行为
- 掌握AOP的应用场景
- 了解事务失效原因
- 实践编码，加深理解
