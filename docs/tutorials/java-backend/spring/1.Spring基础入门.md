---
title: Spring基础入门
---

# Spring基础入门

## 一、Spring是什么？

### 1.1 Spring简介

**Spring** 是一个开源的轻量级 Java 开发框架，由 Rod Johnson 于 2002 年创建。Spring 的核心是**控制反转（IoC）**和**面向切面编程（AOP）**。

**Spring 的含义：**
- Spring = 春天
- 寓意：为 Java 企业级开发带来春天般的简洁和活力

### 1.2 Spring的核心特性

**1. IoC（Inversion of Control）- 控制反转**
- 对象的创建和管理由 Spring 容器负责
- 降低代码耦合度

**2. AOP（Aspect Oriented Programming）- 面向切面编程**
- 将横切关注点（如日志、事务）从业务逻辑中分离
- 提高代码复用性

**3. 声明式事务管理**
- 通过注解或配置管理事务
- 无需编写繁琐的事务代码

**4. 整合能力强**
- 可以整合各种优秀框架（MyBatis、Hibernate、JPA等）
- 提供统一的开发方式

### 1.3 为什么要使用Spring？

**传统开发的问题：**
```java
// 高耦合：直接创建对象
public class UserController {
    private UserService userService = new UserServiceImpl();
    // UserController 与 UserServiceImpl 紧密耦合
}
```

**使用 Spring 的好处：**
```java
// 低耦合：Spring 注入对象
@Controller
public class UserController {
    @Autowired
    private UserService userService; // 由 Spring 注入
    // UserController 只依赖接口，不依赖实现
}
```

**优势总结：**
- ✅ 解耦：降低组件之间的耦合度
- ✅ 易测试：可以方便地进行单元测试
- ✅ 易维护：修改实现类不需要改动调用代码
- ✅ 代码简洁：减少样板代码
- ✅ 整合方便：与各种框架无缝集成

---

## 二、Spring体系结构

### 2.1 Spring框架组成

```
Spring Framework
│
├── Core Container (核心容器层)
│   ├── spring-core      # 核心工具类
│   ├── spring-beans     # Bean 管理
│   ├── spring-context   # 上下文（IoC容器）
│   └── spring-expression # SpEL 表达式
│
├── AOP (面向切面编程层)
│   ├── spring-aop       # AOP 实现
│   └── spring-aspects   # AspectJ 集成
│
├── Data Access (数据访问层)
│   ├── spring-jdbc      # JDBC 支持
│   ├── spring-tx        # 事务管理
│   ├── spring-orm       # ORM 框架集成
│   └── spring-oxm       # 对象/XML 映射
│
├── Web (Web 层)
│   ├── spring-web       # Web 基础功能
│   ├── spring-webmvc    # Spring MVC
│   └── spring-websocket # WebSocket 支持
│
└── Test (测试层)
    └── spring-test      # 单元测试支持
```

### 2.2 核心模块说明

**Core Container（核心容器）：**
- Spring 框架的基础，提供 IoC 和 DI 功能
- 所有其他模块都依赖于核心容器

**AOP：**
- 实现面向切面编程
- 提供事务管理、日志记录等功能

**Data Access：**
- 简化数据库访问
- 提供事务管理

**Web：**
- 提供 Web 开发支持
- Spring MVC 是最常用的 Web 框架

---

## 三、IoC控制反转

### 3.1 什么是IoC？

**IoC（Inversion of Control）**：控制反转，是一种设计思想。

**传统方式：**
```
程序员主动创建和管理对象
程序 → 主动 new 对象 → 使用对象
```

**IoC 方式：**
```
由 IoC 容器创建和管理对象
程序 → 从容器获取对象 → 使用对象
```

### 3.2 传统方式 vs IoC

**传统方式：**
```java
public class UserService {
    // 直接创建依赖对象
    private UserDao userDao = new UserDaoImpl();
    
    public void addUser() {
        userDao.save();
    }
}
```
**问题：**
- UserService 和 UserDaoImpl 高度耦合
- 修改 UserDaoImpl 需要修改 UserService
- 难以进行单元测试

**IoC 方式：**
```java
public class UserService {
    // 不自己创建，等待注入
    private UserDao userDao;
    
    // 通过 setter 方法注入
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
    
    public void addUser() {
        userDao.save();
    }
}
```
**优势：**
- UserService 不依赖具体实现
- 可以注入不同的 UserDao 实现
- 易于测试和维护

### 3.3 IoC容器

**IoC 容器的作用：**
1. 创建对象
2. 管理对象的生命周期
3. 维护对象之间的依赖关系

**Spring 的两大核心容器：**

**1. BeanFactory**
- 基础容器
- 延迟加载（用到时才创建 Bean）
- 功能简单

**2. ApplicationContext（常用）**
- 高级容器，继承 BeanFactory
- 立即加载（启动时创建所有单例 Bean）
- 功能强大

**ApplicationContext 的实现类：**
```java
// 1. 从类路径加载 XML 配置
ApplicationContext context = 
    new ClassPathXmlApplicationContext("applicationContext.xml");

// 2. 从文件系统加载 XML 配置
ApplicationContext context = 
    new FileSystemXmlApplicationContext("D:/config/applicationContext.xml");

// 3. 注解配置
ApplicationContext context = 
    new AnnotationConfigApplicationContext(AppConfig.class);

// 4. Web 应用中（自动创建）
// 在 web.xml 中配置 ContextLoaderListener
```

---

## 四、DI依赖注入

### 4.1 什么是DI？

**DI（Dependency Injection）**：依赖注入，是 IoC 的一种实现方式。

**核心思想：**
- 对象的依赖关系由容器在运行时动态注入
- 对象只需声明依赖，不需要自己创建

### 4.2 依赖注入的方式

#### 4.2.1 构造器注入（推荐）

**XML 配置：**
```xml
<bean id="userService" class="com.example.service.UserService">
    <constructor-arg ref="userDao"/>
</bean>

<bean id="userDao" class="com.example.dao.UserDaoImpl"/>
```

**Java 代码：**
```java
public class UserService {
    private final UserDao userDao;
    
    // 构造器注入
    public UserService(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

**注解方式：**
```java
@Service
public class UserService {
    private final UserDao userDao;
    
    @Autowired
    public UserService(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

**优点：**
- 保证依赖不可变（final）
- 保证依赖不为 null
- 提高代码的可测试性

#### 4.2.2 Setter 注入

**XML 配置：**
```xml
<bean id="userService" class="com.example.service.UserService">
    <property name="userDao" ref="userDao"/>
</bean>
```

**Java 代码：**
```java
public class UserService {
    private UserDao userDao;
    
    // Setter 注入
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

**注解方式：**
```java
@Service
public class UserService {
    private UserDao userDao;
    
    @Autowired
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

#### 4.2.3 字段注入（不推荐）

```java
@Service
public class UserService {
    @Autowired
    private UserDao userDao; // 直接注入字段
}
```

**缺点：**
- 无法注入 final 字段
- 难以进行单元测试
- 隐藏了依赖关系

### 4.3 注入不同类型的值

#### 4.3.1 注入基本类型

**XML 配置：**
```xml
<bean id="user" class="com.example.entity.User">
    <property name="name" value="张三"/>
    <property name="age" value="20"/>
</bean>
```

**注解方式：**
```java
@Component
public class User {
    @Value("张三")
    private String name;
    
    @Value("20")
    private int age;
}
```

#### 4.3.2 注入集合类型

**XML 配置：**
```xml
<bean id="userService" class="com.example.service.UserService">
    <!-- List -->
    <property name="list">
        <list>
            <value>值1</value>
            <value>值2</value>
        </list>
    </property>
    
    <!-- Map -->
    <property name="map">
        <map>
            <entry key="key1" value="value1"/>
            <entry key="key2" value="value2"/>
        </map>
    </property>
    
    <!-- Properties -->
    <property name="props">
        <props>
            <prop key="username">admin</prop>
            <prop key="password">123456</prop>
        </props>
    </property>
</bean>
```

---

## 五、Bean的配置与管理

### 5.1 Bean的定义

**Bean** 是 Spring 容器管理的对象。

**三种配置方式：**
1. XML 配置（传统方式）
2. 注解配置（常用）
3. Java 配置（推荐）

### 5.2 XML 配置方式

**applicationContext.xml：**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <!-- 定义 Bean -->
    <bean id="userDao" class="com.example.dao.UserDaoImpl"/>
    
    <bean id="userService" class="com.example.service.UserService">
        <property name="userDao" ref="userDao"/>
    </bean>
</beans>
```

### 5.3 注解配置方式

**开启组件扫描：**
```xml
<context:component-scan base-package="com.example"/>
```

**使用注解：**
```java
@Repository
public class UserDaoImpl implements UserDao {
    // ...
}

@Service
public class UserService {
    @Autowired
    private UserDao userDao;
}
```

### 5.4 Java 配置方式（推荐）

**配置类：**
```java
@Configuration
@ComponentScan("com.example")
public class AppConfig {
    
    @Bean
    public UserDao userDao() {
        return new UserDaoImpl();
    }
    
    @Bean
    public UserService userService() {
        UserService service = new UserService();
        service.setUserDao(userDao());
        return service;
    }
}
```

**使用配置：**
```java
ApplicationContext context = 
    new AnnotationConfigApplicationContext(AppConfig.class);
UserService userService = context.getBean(UserService.class);
```

### 5.5 Bean的作用域

**作用域类型：**

| 作用域 | 说明 |
|--------|------|
| **singleton** | 单例（默认），整个容器中只有一个实例 |
| **prototype** | 原型，每次获取都创建新实例 |
| request | Web环境，每个请求一个实例 |
| session | Web环境，每个会话一个实例 |
| application | Web环境，整个应用一个实例 |

**配置作用域：**

**XML 方式：**
```xml
<bean id="userService" class="com.example.service.UserService" scope="prototype"/>
```

**注解方式：**
```java
@Service
@Scope("prototype")
public class UserService {
    // ...
}
```

### 5.6 Bean的生命周期

**完整生命周期：**
```
1. 实例化 Bean（调用构造器）
2. 设置属性值（依赖注入）
3. 调用 BeanNameAware 的 setBeanName()
4. 调用 BeanFactoryAware 的 setBeanFactory()
5. 调用 ApplicationContextAware 的 setApplicationContext()
6. 调用 BeanPostProcessor 的 postProcessBeforeInitialization()
7. 调用 @PostConstruct 注解的方法
8. 调用 InitializingBean 的 afterPropertiesSet()
9. 调用自定义的 init-method
10. 调用 BeanPostProcessor 的 postProcessAfterInitialization()
11. Bean 可以使用了
12. 容器关闭
13. 调用 @PreDestroy 注解的方法
14. 调用 DisposableBean 的 destroy()
15. 调用自定义的 destroy-method
```

**简化版：**
```
实例化 → 属性赋值 → 初始化 → 使用 → 销毁
```

**示例代码：**
```java
@Component
public class User {
    
    private String name;
    
    public User() {
        System.out.println("1. 构造器");
    }
    
    public void setName(String name) {
        System.out.println("2. 属性赋值");
        this.name = name;
    }
    
    @PostConstruct
    public void init() {
        System.out.println("3. 初始化方法");
    }
    
    @PreDestroy
    public void destroy() {
        System.out.println("5. 销毁方法");
    }
}
```

---

## 六、创建第一个Spring项目

### 6.1 项目结构

```
spring-demo/
├── pom.xml
└── src/
    ├── main/
    │   ├── java/
    │   │   └── com/example/
    │   │       ├── dao/
    │   │       │   ├── UserDao.java
    │   │       │   └── UserDaoImpl.java
    │   │       ├── service/
    │   │       │   └── UserService.java
    │   │       ├── config/
    │   │       │   └── AppConfig.java
    │   │       └── App.java
    │   └── resources/
    │       └── applicationContext.xml
    └── test/
        └── java/
```

### 6.2 添加依赖

**pom.xml：**
```xml
<dependencies>
    <!-- Spring Context -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.3.30</version>
    </dependency>
    
    <!-- JUnit -->
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.13.2</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### 6.3 编写代码

**UserDao.java：**
```java
package com.example.dao;

public interface UserDao {
    void save();
}
```

**UserDaoImpl.java：**
```java
package com.example.dao;

import org.springframework.stereotype.Repository;

@Repository
public class UserDaoImpl implements UserDao {
    @Override
    public void save() {
        System.out.println("保存用户到数据库");
    }
}
```

**UserService.java：**
```java
package com.example.service;

import com.example.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService {
    
    @Autowired
    private UserDao userDao;
    
    public void addUser() {
        System.out.println("执行业务逻辑");
        userDao.save();
    }
}
```

**AppConfig.java：**
```java
package com.example.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan("com.example")
public class AppConfig {
}
```

**App.java：**
```java
package com.example;

import com.example.config.AppConfig;
import com.example.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class App {
    public static void main(String[] args) {
        // 创建 Spring 容器
        ApplicationContext context = 
            new AnnotationConfigApplicationContext(AppConfig.class);
        
        // 从容器获取 Bean
        UserService userService = context.getBean(UserService.class);
        
        // 调用方法
        userService.addUser();
    }
}
```

### 6.4 运行结果

```
执行业务逻辑
保存用户到数据库
```

---

## 七、实战练习

### 7.1 练习1：实现用户管理

**任务：** 创建一个简单的用户管理系统。

**实体类 User.java：**
```java
public class User {
    private Long id;
    private String username;
    private String email;
    
    // getter/setter/toString
}
```

**Dao 层：**
```java
@Repository
public class UserDaoImpl implements UserDao {
    private List<User> users = new ArrayList<>();
    
    @Override
    public void save(User user) {
        users.add(user);
        System.out.println("保存用户: " + user);
    }
    
    @Override
    public List<User> findAll() {
        return users;
    }
}
```

**Service 层：**
```java
@Service
public class UserService {
    
    @Autowired
    private UserDao userDao;
    
    public void addUser(String username, String email) {
        User user = new User();
        user.setId(System.currentTimeMillis());
        user.setUsername(username);
        user.setEmail(email);
        userDao.save(user);
    }
    
    public void listUsers() {
        List<User> users = userDao.findAll();
        users.forEach(System.out::println);
    }
}
```

**测试：**
```java
public static void main(String[] args) {
    ApplicationContext context = 
        new AnnotationConfigApplicationContext(AppConfig.class);
    
    UserService userService = context.getBean(UserService.class);
    
    userService.addUser("张三", "zhangsan@example.com");
    userService.addUser("李四", "lisi@example.com");
    
    userService.listUsers();
}
```

---

## 八、常见问题

### 8.1 找不到 Bean

**错误：**
```
NoSuchBeanDefinitionException: No qualifying bean of type 'xxx' available
```

**解决：**
1. 检查是否添加了组件注解（@Component、@Service等）
2. 检查包扫描路径是否正确
3. 检查是否有多个同类型的 Bean

### 8.2 循环依赖

**问题：** A 依赖 B，B 又依赖 A。

**Spring 的解决方案：**
- 单例 Bean 的循环依赖：Spring 通过三级缓存解决
- 构造器注入的循环依赖：无法解决，需要重新设计

**建议：** 避免循环依赖，重新设计类结构。

---

## 九、总结

✅ **本章学习内容：**
- Spring 的概念和核心特性
- Spring 体系结构
- IoC 控制反转
- DI 依赖注入
- Bean 的配置与管理
- Bean 的生命周期
- 第一个 Spring 项目

✅ **核心要点：**
- 理解 IoC 的思想：控制权的转移
- 掌握 DI 的三种方式：构造器、Setter、字段
- 熟悉 Bean 的作用域和生命周期
- 优先使用注解配置

**下一章预告：** 我们将深入学习 Spring 的核心注解。
