---
title: Spring事务管理
---

# Spring事务管理

## 一、事务基础

### 1.1 什么是事务？

**事务（Transaction）**：一组数据库操作，要么全部成功，要么全部失败。

**经典例子 - 转账：**
```java
// 事务操作
1. 从 A 账户扣款 1000 元
2. 向 B 账户加款 1000 元

// 要求：要么都成功，要么都失败
```

### 1.2 事务的ACID特性

| 特性 | 说明 |
|------|------|
| **原子性（Atomicity）** | 事务是不可分割的最小单元，要么全部成功，要么全部失败 |
| **一致性（Consistency）** | 事务前后数据的完整性必须保持一致 |
| **隔离性（Isolation）** | 多个事务之间相互隔离，互不干扰 |
| **持久性（Durability）** | 事务一旦提交，对数据库的改变是永久的 |

### 1.3 没有事务的问题

```java
public void transfer(Long fromId, Long toId, BigDecimal amount) {
    // 1. 扣款
    accountDao.deduct(fromId, amount);
    
    // 2. 如果这里发生异常...
    int i = 1 / 0;  // 模拟异常
    
    // 3. 加款（不会执行）
    accountDao.add(toId, amount);
}

// 结果：A 扣了钱，B 没收到钱 → 数据不一致
```

---

## 二、Spring事务管理方式

### 2.1 编程式事务

**手动管理事务的提交和回滚。**

**示例：**
```java
@Service
public class UserService {
    
    @Autowired
    private TransactionTemplate transactionTemplate;
    
    public void addUser(User user) {
        transactionTemplate.execute(status -> {
            try {
                // 业务操作
                userDao.save(user);
                // 提交事务（自动）
                return null;
            } catch (Exception e) {
                // 回滚事务
                status.setRollbackOnly();
                throw e;
            }
        });
    }
}
```

**缺点：**
- 代码侵入性强
- 事务代码和业务代码混在一起
- 难以维护

### 2.2 声明式事务（推荐）

**通过注解或配置管理事务。**

**示例：**
```java
@Service
public class UserService {
    
    @Transactional
    public void addUser(User user) {
        userDao.save(user); // 纯粹的业务逻辑
        // Spring 自动管理事务
    }
}
```

**优点：**
- 代码简洁
- 业务逻辑和事务管理分离
- 易于维护

---

## 三、@Transactional 注解详解

### 3.1 基本使用

```java
@Service
public class UserService {
    
    // 方法级别
    @Transactional
    public void addUser(User user) {
        userDao.save(user);
    }
}

// 类级别（对所有方法生效）
@Service
@Transactional
public class OrderService {
    
    public void createOrder(Order order) {
        orderDao.save(order);
    }
    
    public void updateOrder(Order order) {
        orderDao.update(order);
    }
}
```

### 3.2 @Transactional 属性

#### 3.2.1 传播行为（Propagation）

**作用：** 定义事务的传播方式。

| 传播行为 | 说明 |
|---------|------|
| **REQUIRED**（默认） | 如果当前有事务，就加入该事务；如果没有，就创建新事务 |
| **REQUIRES_NEW** | 总是创建新事务，如果当前有事务，就挂起当前事务 |
| **SUPPORTS** | 如果当前有事务，就加入该事务；如果没有，就以非事务方式执行 |
| **NOT_SUPPORTED** | 以非事务方式执行，如果当前有事务，就挂起当前事务 |
| **MANDATORY** | 必须在事务中执行，如果没有事务，就抛出异常 |
| **NEVER** | 以非事务方式执行，如果当前有事务，就抛出异常 |
| **NESTED** | 如果当前有事务，就在嵌套事务中执行；如果没有，就创建新事务 |

**REQUIRED 示例：**
```java
@Service
public class OrderService {
    @Autowired
    private LogService logService;
    
    @Transactional(propagation = Propagation.REQUIRED)
    public void createOrder(Order order) {
        orderDao.save(order);
        logService.saveLog("创建订单"); // 加入当前事务
    }
}

@Service
public class LogService {
    @Transactional(propagation = Propagation.REQUIRED)
    public void saveLog(String message) {
        logDao.save(message);
    }
}

// 结果：createOrder 和 saveLog 在同一个事务中
// 如果 saveLog 失败，createOrder 也会回滚
```

**REQUIRES_NEW 示例：**
```java
@Service
public class OrderService {
    @Autowired
    private LogService logService;
    
    @Transactional
    public void createOrder(Order order) {
        orderDao.save(order);
        logService.saveLog("创建订单"); // 新事务
    }
}

@Service
public class LogService {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveLog(String message) {
        logDao.save(message);
    }
}

// 结果：saveLog 在独立的事务中
// 如果 createOrder 失败，saveLog 不会回滚（已提交）
```

#### 3.2.2 隔离级别（Isolation）

**作用：** 定义事务之间的隔离程度。

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
|---------|------|-----------|------|
| **READ_UNCOMMITTED** | ✓ | ✓ | ✓ |
| **READ_COMMITTED** | × | ✓ | ✓ |
| **REPEATABLE_READ**（MySQL默认） | × | × | ✓ |
| **SERIALIZABLE** | × | × | × |

**并发问题说明：**

**1. 脏读：** 读取到其他事务未提交的数据
```
事务 A                      事务 B
                           修改数据（未提交）
读取数据（读到未提交的）
                           回滚
数据错误
```

**2. 不可重复读：** 同一事务中多次读取数据不一致
```
事务 A                      事务 B
读取数据 X = 100
                           修改 X = 200 并提交
再次读取 X = 200
X 的值改变了
```

**3. 幻读：** 同一事务中多次查询记录数不一致
```
事务 A                      事务 B
查询记录数 = 10
                           插入 1 条记录并提交
再次查询记录数 = 11
记录数改变了
```

**使用示例：**
```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void transfer(Long fromId, Long toId, BigDecimal amount) {
    // 读已提交，避免脏读
}
```

#### 3.2.3 超时时间（timeout）

**作用：** 事务超时时间（秒），超时自动回滚。

```java
@Transactional(timeout = 30) // 30 秒
public void longTimeOperation() {
    // 长时间操作
}
```

#### 3.2.4 只读事务（readOnly）

**作用：** 标记为只读事务，优化性能。

```java
@Transactional(readOnly = true)
public List<User> findAll() {
    return userDao.findAll();
}
```

**注意：** 只读事务中不能进行增删改操作。

#### 3.2.5 回滚规则（rollbackFor）

**默认：** 只有 RuntimeException 和 Error 会回滚。

**自定义回滚异常：**
```java
// 遇到所有异常都回滚
@Transactional(rollbackFor = Exception.class)
public void addUser(User user) throws Exception {
    userDao.save(user);
}

// 遇到指定异常不回滚
@Transactional(noRollbackFor = BusinessException.class)
public void operation() {
    // 业务操作
}
```

### 3.3 @Transactional 完整示例

```java
@Transactional(
    propagation = Propagation.REQUIRED,
    isolation = Isolation.READ_COMMITTED,
    timeout = 30,
    readOnly = false,
    rollbackFor = Exception.class
)
public void complexOperation() {
    // 业务操作
}
```

---

## 四、事务传播行为详解

### 4.1 REQUIRED（常用）

```java
@Service
public class UserService {
    @Autowired
    private OrderService orderService;
    
    @Transactional
    public void register(User user) {
        userDao.save(user);
        orderService.createWelcomeOrder(user.getId());
    }
}

@Service
public class OrderService {
    @Transactional(propagation = Propagation.REQUIRED)
    public void createWelcomeOrder(Long userId) {
        orderDao.save(new Order(userId));
    }
}

// 结果：
// register 开启事务 T1
// createWelcomeOrder 加入事务 T1
// 如果任何一个失败，全部回滚
```

### 4.2 REQUIRES_NEW（常用）

```java
@Service
public class OrderService {
    @Autowired
    private LogService logService;
    
    @Transactional
    public void createOrder(Order order) {
        orderDao.save(order);
        logService.saveLog("创建订单"); // 独立事务
        // 即使这里抛异常，saveLog 已提交不会回滚
    }
}

@Service
public class LogService {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveLog(String message) {
        logDao.save(message);
    }
}
```

### 4.3 NESTED

```java
@Service
public class OrderService {
    @Autowired
    private CouponService couponService;
    
    @Transactional
    public void createOrder(Order order) {
        orderDao.save(order);
        
        try {
            couponService.useCoupon(order.getCouponId());
        } catch (Exception e) {
            // 优惠券使用失败，订单继续
            log.error("优惠券使用失败", e);
        }
    }
}

@Service
public class CouponService {
    @Transactional(propagation = Propagation.NESTED)
    public void useCoupon(Long couponId) {
        couponDao.use(couponId);
    }
}

// 结果：
// useCoupon 在嵌套事务中执行
// 如果 useCoupon 失败并被捕获，只回滚 useCoupon
// createOrder 继续执行
```

---

## 五、事务失效场景

### 5.1 方法内部调用

**问题：**
```java
@Service
public class UserService {
    
    public void register(User user) {
        this.saveUser(user); // 内部调用，事务失效
    }
    
    @Transactional
    public void saveUser(User user) {
        userDao.save(user);
    }
}
```

**原因：** Spring 事务基于 AOP 代理，内部调用不经过代理，事务失效。

**解决方案1：** 注入自己
```java
@Service
public class UserService {
    @Autowired
    private UserService self;
    
    public void register(User user) {
        self.saveUser(user); // 通过代理调用
    }
    
    @Transactional
    public void saveUser(User user) {
        userDao.save(user);
    }
}
```

**解决方案2：** 从容器获取代理对象
```java
@Service
public class UserService {
    @Autowired
    private ApplicationContext context;
    
    public void register(User user) {
        UserService proxy = context.getBean(UserService.class);
        proxy.saveUser(user);
    }
}
```

### 5.2 方法非 public

**问题：**
```java
@Service
public class UserService {
    @Transactional
    private void saveUser(User user) { // private 方法
        userDao.save(user);
    }
}
```

**原因：** Spring AOP 默认只代理 public 方法。

**解决：** 改为 public 方法。

### 5.3 异常被捕获

**问题：**
```java
@Service
public class UserService {
    @Transactional
    public void saveUser(User user) {
        try {
            userDao.save(user);
            int i = 1 / 0; // 异常
        } catch (Exception e) {
            // 异常被捕获，事务不会回滚
            log.error("保存失败", e);
        }
    }
}
```

**解决：** 手动回滚或重新抛出异常
```java
@Transactional
public void saveUser(User user) {
    try {
        userDao.save(user);
        int i = 1 / 0;
    } catch (Exception e) {
        // 方式1：手动回滚
        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
        
        // 方式2：重新抛出
        throw new RuntimeException(e);
    }
}
```

### 5.4 异常类型不匹配

**问题：**
```java
@Transactional // 默认只回滚 RuntimeException
public void saveUser(User user) throws Exception {
    userDao.save(user);
    throw new Exception("错误"); // 不会回滚
}
```

**解决：** 指定回滚异常
```java
@Transactional(rollbackFor = Exception.class)
public void saveUser(User user) throws Exception {
    userDao.save(user);
    throw new Exception("错误"); // 会回滚
}
```

### 5.5 数据库不支持事务

**问题：** MySQL 的 MyISAM 引擎不支持事务。

**解决：** 使用 InnoDB 引擎。

---

## 六、实战案例

### 6.1 转账功能

```java
@Service
public class AccountService {
    
    @Autowired
    private AccountDao accountDao;
    
    @Transactional(rollbackFor = Exception.class)
    public void transfer(Long fromId, Long toId, BigDecimal amount) {
        // 1. 检查余额
        Account from = accountDao.findById(fromId);
        if (from.getBalance().compareTo(amount) < 0) {
            throw new BusinessException("余额不足");
        }
        
        // 2. 扣款
        accountDao.deduct(fromId, amount);
        
        // 3. 加款
        accountDao.add(toId, amount);
        
        // 如果任何步骤失败，全部回滚
    }
}
```

### 6.2 订单创建（多表操作）

```java
@Service
public class OrderService {
    
    @Autowired
    private OrderDao orderDao;
    @Autowired
    private OrderItemDao orderItemDao;
    @Autowired
    private StockService stockService;
    
    @Transactional(rollbackFor = Exception.class)
    public Long createOrder(Order order, List<OrderItem> items) {
        // 1. 保存订单
        orderDao.save(order);
        
        // 2. 保存订单明细
        for (OrderItem item : items) {
            item.setOrderId(order.getId());
            orderItemDao.save(item);
            
            // 3. 扣减库存
            stockService.deduct(item.getProductId(), item.getQuantity());
        }
        
        return order.getId();
    }
}

@Service
public class StockService {
    
    @Transactional(propagation = Propagation.REQUIRED)
    public void deduct(Long productId, Integer quantity) {
        Stock stock = stockDao.findByProductId(productId);
        if (stock.getQuantity() < quantity) {
            throw new BusinessException("库存不足");
        }
        stockDao.deduct(productId, quantity);
    }
}
```

---

## 七、总结

✅ **本章学习内容：**
- 事务的基本概念和 ACID 特性
- Spring 事务管理方式
- @Transactional 注解详解
- 事务传播行为
- 事务隔离级别
- 事务失效场景及解决方案

✅ **核心要点：**
- 优先使用声明式事务（@Transactional）
- 理解事务传播行为，合理选择
- 注意事务失效的场景
- 异常要正确抛出才能回滚
- 避免方法内部调用导致事务失效

✅ **最佳实践：**
- 事务方法尽量简短
- 不要在事务中执行耗时操作
- 合理设置超时时间
- 只读操作使用 readOnly=true
- 明确指定 rollbackFor

**下一章预告：** 我们将整理 Spring 常见面试题。
