---
title: 高级功能
---

# 高级功能

## 一、逻辑删除

### 1.1 什么是逻辑删除？

**逻辑删除：** 删除数据时不真正删除，而是标记为已删除。

**优点：**
- ✅ 数据可恢复
- ✅ 保留历史记录
- ✅ 便于审计

### 1.2 配置逻辑删除

**全局配置：**
```yaml
mybatis-plus:
  global-config:
    db-config:
      logic-delete-field: deleted  # 全局逻辑删除字段
      logic-delete-value: 1        # 删除值
      logic-not-delete-value: 0    # 未删除值
```

**实体类配置：**
```java
@Data
public class User {
    private Long id;
    private String username;
    
    @TableLogic
    private Integer deleted;  // 0-未删除 1-已删除
}
```

### 1.3 使用逻辑删除

```java
// 删除操作
userMapper.deleteById(1L);
// 实际SQL：UPDATE user SET deleted=1 WHERE id=1 AND deleted=0

// 查询操作（自动过滤已删除数据）
List<User> users = userMapper.selectList(null);
// 实际SQL：SELECT * FROM user WHERE deleted=0
```

### 1.4 查询已删除数据

```java
// 方式1：原生SQL
@Select("SELECT * FROM user WHERE deleted = 1")
List<User> selectDeleted();

// 方式2：在Mapper XML中写SQL
```

---

## 二、自动填充

### 2.1 配置自动填充

**实体类：**
```java
@Data
public class User {
    private Long id;
    private String username;
    
    @TableField(fill = FieldFill.INSERT)
    private Date createTime;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Date updateTime;
    
    @TableField(fill = FieldFill.INSERT)
    private String createBy;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private String updateBy;
}
```

**处理器：**
```java
@Component
public class MyMetaObjectHandler implements MetaObjectHandler {
    
    @Override
    public void insertFill(MetaObject metaObject) {
        // 插入时填充
        this.strictInsertFill(metaObject, "createTime", Date.class, new Date());
        this.strictInsertFill(metaObject, "updateTime", Date.class, new Date());
        this.strictInsertFill(metaObject, "createBy", String.class, getCurrentUser());
        this.strictInsertFill(metaObject, "updateBy", String.class, getCurrentUser());
    }
    
    @Override
    public void updateFill(MetaObject metaObject) {
        // 更新时填充
        this.strictUpdateFill(metaObject, "updateTime", Date.class, new Date());
        this.strictUpdateFill(metaObject, "updateBy", String.class, getCurrentUser());
    }
    
    private String getCurrentUser() {
        // 获取当前用户（从 Spring Security 或 JWT）
        return "admin";
    }
}
```

---

## 三、乐观锁

### 3.1 什么是乐观锁？

**乐观锁：** 通过版本号机制，解决并发更新问题。

**原理：**
```
1. 查询时获取版本号
2. 更新时比较版本号
3. 版本号匹配才更新
4. 更新后版本号+1
```

### 3.2 配置乐观锁

**添加插件：**
```java
@Configuration
public class MybatisPlusConfig {
    
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        
        // 乐观锁插件
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
        
        return interceptor;
    }
}
```

**实体类：**
```java
@Data
public class User {
    private Long id;
    private String username;
    private Integer stock;  // 库存
    
    @Version
    private Integer version;  // 版本号
}
```

### 3.3 使用乐观锁

```java
// 查询
User user = userMapper.selectById(1L);
// version = 1

// 更新
user.setStock(user.getStock() - 1);
userMapper.updateById(user);
// SQL: UPDATE user SET stock=stock-1, version=2 WHERE id=1 AND version=1

// 如果version不匹配，更新失败
```

### 3.4 并发场景

```java
// 线程1
User user1 = userMapper.selectById(1L);  // version=1
user1.setStock(90);

// 线程2
User user2 = userMapper.selectById(1L);  // version=1
user2.setStock(80);

// 线程1更新成功
userMapper.updateById(user1);  // version=2

// 线程2更新失败（version不匹配）
int rows = userMapper.updateById(user2);  // rows=0
```

---

## 四、多租户

### 4.1 什么是多租户？

**多租户：** 一套系统支持多个租户，数据隔离。

**实现方式：**
1. 独立数据库
2. 共享数据库，独立Schema
3. 共享数据库，共享Schema，通过租户ID区分

### 4.2 配置多租户

**添加插件：**
```java
@Configuration
public class MybatisPlusConfig {
    
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        
        // 多租户插件
        TenantLineInnerInterceptor tenantInterceptor = new TenantLineInnerInterceptor();
        tenantInterceptor.setTenantLineHandler(new TenantLineHandler() {
            
            @Override
            public Expression getTenantId() {
                // 返回当前租户ID
                return new LongValue(getCurrentTenantId());
            }
            
            @Override
            public boolean ignoreTable(String tableName) {
                // 忽略某些表（如系统配置表）
                return "sys_config".equals(tableName);
            }
        });
        
        interceptor.addInnerInterceptor(tenantInterceptor);
        
        return interceptor;
    }
    
    private Long getCurrentTenantId() {
        // 从 ThreadLocal 或 JWT 中获取
        return 1L;
    }
}
```

**实体类：**
```java
@Data
public class User {
    private Long id;
    private String username;
    private Long tenantId;  // 租户ID
}
```

**自动添加租户条件：**
```java
// 查询
List<User> users = userMapper.selectList(null);
// SQL: SELECT * FROM user WHERE tenant_id = 1

// 插入
User user = new User();
user.setUsername("张三");
userMapper.insert(user);
// SQL: INSERT INTO user (username, tenant_id) VALUES ('张三', 1)
```

---

## 五、动态表名

### 5.1 配置动态表名

```java
@Configuration
public class MybatisPlusConfig {
    
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        
        // 动态表名插件
        DynamicTableNameInnerInterceptor dynamicTableNameInnerInterceptor = 
            new DynamicTableNameInnerInterceptor();
        
        dynamicTableNameInnerInterceptor.setTableNameHandler((sql, tableName) -> {
            // 根据条件返回不同的表名
            if ("user".equals(tableName)) {
                return "user_" + getCurrentMonth();  // user_202310
            }
            return tableName;
        });
        
        interceptor.addInnerInterceptor(dynamicTableNameInnerInterceptor);
        
        return interceptor;
    }
    
    private String getCurrentMonth() {
        return new SimpleDateFormat("yyyyMM").format(new Date());
    }
}
```

---

## 六、SQL注入器

### 6.1 自定义通用方法

**自定义方法：**
```java
public interface MyBaseMapper<T> extends BaseMapper<T> {
    
    // 自定义批量插入
    int insertBatchSomeColumn(List<T> entityList);
}
```

**SQL注入器：**
```java
public class MySqlInjector extends DefaultSqlInjector {
    
    @Override
    public List<AbstractMethod> getMethodList(Class<?> mapperClass, TableInfo tableInfo) {
        List<AbstractMethod> methodList = super.getMethodList(mapperClass, tableInfo);
        
        // 添加自定义方法
        methodList.add(new InsertBatchSomeColumn());
        
        return methodList;
    }
}
```

**配置：**
```java
@Bean
public MySqlInjector sqlInjector() {
    return new MySqlInjector();
}
```

---

## 七、总结

✅ **本章学习内容：**
- 逻辑删除
- 自动填充
- 乐观锁
- 多租户
- 动态表名
- SQL注入器

✅ **核心要点：**
- 逻辑删除保留历史数据
- 自动填充简化开发
- 乐观锁解决并发问题
- 多租户实现数据隔离

**下一章预告：** 我们将整理 MyBatis-Plus 面试题。
