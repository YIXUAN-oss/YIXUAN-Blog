---
title: 高级映射
---

# 高级映射

## 一、多表关联概述

### 1.1 关联关系

| 关系类型 | 说明 | 示例 |
|---------|------|------|
| **一对一** | 一个A对应一个B | 用户 - 身份证 |
| **一对多** | 一个A对应多个B | 部门 - 员工 |
| **多对一** | 多个A对应一个B | 员工 - 部门 |
| **多对多** | 多个A对应多个B | 学生 - 课程 |

### 1.2 MyBatis映射元素

| 元素 | 说明 |
|------|------|
| `<association>` | 一对一映射 |
| `<collection>` | 一对多映射 |

---

## 二、一对一映射

### 2.1 场景：用户-身份证

**数据库表：**
```sql
CREATE TABLE user (
    id BIGINT PRIMARY KEY,
    username VARCHAR(50),
    card_id BIGINT
);

CREATE TABLE id_card (
    id BIGINT PRIMARY KEY,
    card_number VARCHAR(18),
    address VARCHAR(200)
);
```

### 2.2 实体类

```java
@Data
public class User {
    private Long id;
    private String username;
    private IdCard idCard;  // 一对一关联
}

@Data
public class IdCard {
    private Long id;
    private String cardNumber;
    private String address;
}
```

### 2.3 方式一：嵌套查询

**UserMapper.xml：**
```xml
<resultMap id="userWithCard" type="User">
    <id property="id" column="id"/>
    <result property="username" column="username"/>
    <!-- 一对一关联 -->
    <association property="idCard" 
                 column="card_id" 
                 javaType="IdCard"
                 select="selectCardById"/>
</resultMap>

<select id="selectById" resultMap="userWithCard">
    SELECT * FROM user WHERE id = #{id}
</select>

<select id="selectCardById" resultType="IdCard">
    SELECT * FROM id_card WHERE id = #{id}
</select>
```

**特点：**
- 执行两次SQL
- 支持延迟加载
- 查询分离

### 2.4 方式二：嵌套结果（推荐）

```xml
<resultMap id="userWithCard" type="User">
    <id property="id" column="id"/>
    <result property="username" column="username"/>
    <!-- 一对一关联 -->
    <association property="idCard" javaType="IdCard">
        <id property="id" column="card_id"/>
        <result property="cardNumber" column="card_number"/>
        <result property="address" column="address"/>
    </association>
</resultMap>

<select id="selectById" resultMap="userWithCard">
    SELECT u.*, c.id as card_id, c.card_number, c.address
    FROM user u
    LEFT JOIN id_card c ON u.card_id = c.id
    WHERE u.id = #{id}
</select>
```

**特点：**
- 执行一次SQL
- 性能好
- 不支持延迟加载

---

## 三、一对多映射

### 3.1 场景：部门-员工

**数据库表：**
```sql
CREATE TABLE department (
    id BIGINT PRIMARY KEY,
    dept_name VARCHAR(50)
);

CREATE TABLE employee (
    id BIGINT PRIMARY KEY,
    emp_name VARCHAR(50),
    dept_id BIGINT
);
```

### 3.2 实体类

```java
@Data
public class Department {
    private Long id;
    private String deptName;
    private List<Employee> employees;  // 一对多关联
}

@Data
public class Employee {
    private Long id;
    private String empName;
    private Long deptId;
}
```

### 3.3 方式一：嵌套查询

```xml
<resultMap id="deptWithEmps" type="Department">
    <id property="id" column="id"/>
    <result property="deptName" column="dept_name"/>
    <!-- 一对多关联 -->
    <collection property="employees" 
                column="id" 
                ofType="Employee"
                select="selectEmpsByDeptId"/>
</resultMap>

<select id="selectById" resultMap="deptWithEmps">
    SELECT * FROM department WHERE id = #{id}
</select>

<select id="selectEmpsByDeptId" resultType="Employee">
    SELECT * FROM employee WHERE dept_id = #{id}
</select>
```

### 3.4 方式二：嵌套结果（推荐）

```xml
<resultMap id="deptWithEmps" type="Department">
    <id property="id" column="id"/>
    <result property="deptName" column="dept_name"/>
    <!-- 一对多关联 -->
    <collection property="employees" ofType="Employee">
        <id property="id" column="emp_id"/>
        <result property="empName" column="emp_name"/>
        <result property="deptId" column="dept_id"/>
    </collection>
</resultMap>

<select id="selectById" resultMap="deptWithEmps">
    SELECT d.*, e.id as emp_id, e.emp_name, e.dept_id
    FROM department d
    LEFT JOIN employee e ON d.id = e.dept_id
    WHERE d.id = #{id}
</select>
```

---

## 四、多对多映射

### 4.1 场景：学生-课程

**数据库表：**
```sql
CREATE TABLE student (
    id BIGINT PRIMARY KEY,
    student_name VARCHAR(50)
);

CREATE TABLE course (
    id BIGINT PRIMARY KEY,
    course_name VARCHAR(50)
);

-- 中间表
CREATE TABLE student_course (
    student_id BIGINT,
    course_id BIGINT,
    PRIMARY KEY (student_id, course_id)
);
```

### 4.2 实体类

```java
@Data
public class Student {
    private Long id;
    private String studentName;
    private List<Course> courses;  // 多对多关联
}

@Data
public class Course {
    private Long id;
    private String courseName;
}
```

### 4.3 映射配置

```xml
<resultMap id="studentWithCourses" type="Student">
    <id property="id" column="id"/>
    <result property="studentName" column="student_name"/>
    <!-- 多对多关联 -->
    <collection property="courses" ofType="Course">
        <id property="id" column="course_id"/>
        <result property="courseName" column="course_name"/>
    </collection>
</resultMap>

<select id="selectById" resultMap="studentWithCourses">
    SELECT s.*, c.id as course_id, c.course_name
    FROM student s
    LEFT JOIN student_course sc ON s.id = sc.student_id
    LEFT JOIN course c ON sc.course_id = c.id
    WHERE s.id = #{id}
</select>
```

---

## 五、延迟加载

### 5.1 什么是延迟加载？

**延迟加载（Lazy Loading）**：查询主对象时，不立即查询关联对象，在使用时才查询。

**优点：**
- 减少数据库访问
- 提高性能
- 按需加载

### 5.2 全局配置

```xml
<settings>
    <!-- 开启延迟加载 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 按需加载 -->
    <setting name="aggressiveLazyLoading" value="false"/>
</settings>
```

### 5.3 使用延迟加载

**必须使用嵌套查询：**
```xml
<resultMap id="userWithCard" type="User">
    <id property="id" column="id"/>
    <result property="username" column="username"/>
    <!-- 延迟加载 -->
    <association property="idCard" 
                 column="card_id" 
                 select="selectCardById"
                 fetchType="lazy"/>  <!-- 延迟加载 -->
</resultMap>

<select id="selectById" resultMap="userWithCard">
    SELECT * FROM user WHERE id = #{id}
</select>

<select id="selectCardById" resultType="IdCard">
    SELECT * FROM id_card WHERE id = #{id}
</select>
```

### 5.4 fetchType属性

| 值 | 说明 |
|----|------|
| lazy | 延迟加载 |
| eager | 立即加载 |

**优先级：** 方法级 > 全局配置

---

## 六、嵌套查询 vs 嵌套结果

### 6.1 对比

| 特性 | 嵌套查询 | 嵌套结果 |
|------|---------|---------|
| **SQL次数** | 多次（N+1问题） | 一次 |
| **延迟加载** | 支持 | 不支持 |
| **性能** | 较差 | 较好 |
| **推荐度** | 不推荐 | 推荐 |

### 6.2 N+1问题

**嵌套查询：**
```
查询10个部门，每个部门查询员工
SQL执行次数：1（查部门）+ 10（查员工）= 11次
```

**嵌套结果：**
```
一次JOIN查询
SQL执行次数：1次
```

---

## 七、实战案例

### 7.1 复杂查询

**场景：** 查询用户，包含部门、角色信息

**实体类：**
```java
@Data
public class User {
    private Long id;
    private String username;
    private Department department;  // 多对一
    private List<Role> roles;       // 多对多
}

@Data
public class Department {
    private Long id;
    private String deptName;
}

@Data
public class Role {
    private Long id;
    private String roleName;
}
```

**映射配置：**
```xml
<resultMap id="userWithAll" type="User">
    <id property="id" column="id"/>
    <result property="username" column="username"/>
    
    <!-- 多对一：部门 -->
    <association property="department" javaType="Department">
        <id property="id" column="dept_id"/>
        <result property="deptName" column="dept_name"/>
    </association>
    
    <!-- 多对多：角色 -->
    <collection property="roles" ofType="Role">
        <id property="id" column="role_id"/>
        <result property="roleName" column="role_name"/>
    </collection>
</resultMap>

<select id="selectById" resultMap="userWithAll">
    SELECT 
        u.*, 
        d.id as dept_id, d.dept_name,
        r.id as role_id, r.role_name
    FROM user u
    LEFT JOIN department d ON u.dept_id = d.id
    LEFT JOIN user_role ur ON u.id = ur.user_id
    LEFT JOIN role r ON ur.role_id = r.id
    WHERE u.id = #{id}
</select>
```

---

## 八、总结

✅ **本章学习内容：**
- 一对一映射（association）
- 一对多映射（collection）
- 多对多映射
- 延迟加载
- 嵌套查询 vs 嵌套结果

✅ **核心要点：**
- 一对一使用 association
- 一对多使用 collection
- 推荐使用嵌套结果（性能好）
- 嵌套查询支持延迟加载

**下一章预告：** 我们将学习 MyBatis 缓存机制。
