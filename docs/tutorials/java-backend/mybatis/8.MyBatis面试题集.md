---
title: MyBatis面试题集
---

# MyBatis面试题集

## 一、基础概念

### 1. 什么是MyBatis？

**答：**

MyBatis 是一款优秀的持久层框架，支持自定义 SQL、存储过程以及高级映射。

**核心特点：**
- 半自动 ORM 框架
- SQL 与代码分离
- 支持动态 SQL
- 简化 JDBC 操作
- 灵活的结果映射

---

### 2. MyBatis和Hibernate的区别？

**答：**

| 特性 | MyBatis | Hibernate |
|------|---------|-----------|
| **类型** | 半自动 ORM | 全自动 ORM |
| **SQL控制** | 完全控制 | 自动生成 |
| **学习曲线** | 平缓 | 陡峭 |
| **性能优化** | 容易 | 困难 |
| **复杂查询** | 擅长 | 较弱 |
| **适用场景** | 复杂业务 | 简单CRUD |

**选择建议：**
- 需要 SQL 优化、复杂查询 → MyBatis
- 快速开发、简单 CRUD → Hibernate

---

### 3. MyBatis的执行流程？

**答：**

```
1. 读取配置文件（mybatis-config.xml）
   ↓
2. 创建 SqlSessionFactory
   ↓
3. 创建 SqlSession
   ↓
4. 获取 Mapper 接口代理对象
   ↓
5. 执行 SQL（通过 Mapper XML）
   ↓
6. Executor 执行 SQL
   ↓
7. StatementHandler 处理 SQL
   ↓
8. ParameterHandler 设置参数
   ↓
9. ResultSetHandler 处理结果
   ↓
10. 返回结果
```

---

## 二、配置相关

### 4. #{}和${}的区别？

**答：**

| 特性 | #{} | ${} |
|------|-----|-----|
| **处理方式** | 预编译（占位符） | 字符串拼接 |
| **SQL注入** | 防止 | 可能 |
| **引号** | 自动添加 | 不添加 |
| **性能** | 好（有缓存） | 一般 |
| **使用场景** | 参数值 | 列名、表名 |

**示例：**
```xml
<!-- #{} 推荐 -->
SELECT * FROM user WHERE id = #{id}
<!-- 生成：SELECT * FROM user WHERE id = ? -->

<!-- ${} 慎用 -->
SELECT * FROM user ORDER BY ${column}
<!-- 生成：SELECT * FROM user ORDER BY username -->
```

**使用建议：**
- 99% 的情况使用 #{}
- 动态列名、表名使用 ${}

---

### 5. resultType和resultMap的区别？

**答：**

**resultType：**
- 简单映射
- 自动映射（需开启驼峰）
- 适用于单表查询
```xml
<select id="selectById" resultType="User">
    SELECT * FROM user WHERE id = #{id}
</select>
```

**resultMap：**
- 复杂映射
- 手动配置
- 适用于多表关联
```xml
<resultMap id="userResultMap" type="User">
    <id property="id" column="id"/>
    <result property="username" column="username"/>
    <association property="department" javaType="Department">
        <id property="id" column="dept_id"/>
        <result property="name" column="dept_name"/>
    </association>
</resultMap>
```

---

### 6. MyBatis如何获取自增主键？

**答：**

**方式一：useGeneratedKeys（推荐）**
```xml
<insert id="insert" useGeneratedKeys="true" keyProperty="id">
    INSERT INTO user (username, email) VALUES (#{username}, #{email})
</insert>
```

**方式二：selectKey**
```xml
<insert id="insert">
    <selectKey keyProperty="id" resultType="long" order="AFTER">
        SELECT LAST_INSERT_ID()
    </selectKey>
    INSERT INTO user (username, email) VALUES (#{username}, #{email})
</insert>
```

**使用：**
```java
User user = new User();
user.setUsername("张三");
userMapper.insert(user);
System.out.println("生成的ID：" + user.getId());
```

---

## 三、动态SQL

### 7. MyBatis的动态SQL有哪些？

**答：**

| 元素 | 说明 | 示例 |
|------|------|------|
| if | 条件判断 | `<if test="username != null">` |
| choose | 多分支 | `<choose><when><otherwise>` |
| where | 动态WHERE | `<where>` |
| set | 动态SET | `<set>` |
| trim | 自定义截取 | `<trim>` |
| foreach | 循环 | `<foreach>` |
| bind | 变量绑定 | `<bind>` |

**示例：**
```xml
<select id="selectByCondition" resultType="User">
    SELECT * FROM user
    <where>
        <if test="username != null">
            AND username LIKE #{username}
        </if>
        <if test="age != null">
            AND age = #{age}
        </if>
    </where>
</select>
```

---

### 8. foreach如何使用？

**答：**

**IN 查询：**
```xml
<select id="selectByIds" resultType="User">
    SELECT * FROM user WHERE id IN
    <foreach collection="ids" item="id" open="(" close=")" separator=",">
        #{id}
    </foreach>
</select>
```

**批量插入：**
```xml
<insert id="insertBatch">
    INSERT INTO user (username, email) VALUES
    <foreach collection="list" item="user" separator=",">
        (#{user.username}, #{user.email})
    </foreach>
</insert>
```

**属性说明：**
- `collection`：集合名称（list、array、ids）
- `item`：元素变量名
- `open`：开始字符
- `close`：结束字符
- `separator`：分隔符

---

## 四、缓存机制

### 9. MyBatis的缓存机制？

**答：**

**一级缓存（默认开启）：**
- SqlSession 级别
- 同一个 SqlSession 内有效
- 存储在内存（HashMap）
- SqlSession 关闭失效

**二级缓存（需要配置）：**
- Mapper 级别
- 同一个 Mapper 的所有 SqlSession 共享
- 需要手动开启
- 实体类实现 Serializable

**查询顺序：**
```
二级缓存 → 一级缓存 → 数据库
```

---

### 10. 一级缓存什么时候失效？

**答：**

**失效场景：**
1. **不同的 SqlSession**
2. **同一个 SqlSession，不同的查询条件**
3. **执行了增删改操作**
4. **手动清空缓存（clearCache）**

**示例：**
```java
SqlSession session = SqlSessionUtil.getSqlSession();
UserMapper mapper = session.getMapper(UserMapper.class);

User user1 = mapper.selectById(1L);  // 查数据库

// 执行更新，缓存失效
mapper.update(new User());

User user2 = mapper.selectById(1L);  // 再次查数据库

session.close();
```

---

## 五、高级特性

### 11. MyBatis如何实现一对一关联？

**答：**

**方式一：嵌套查询**
```xml
<resultMap id="userWithCard" type="User">
    <id property="id" column="id"/>
    <result property="username" column="username"/>
    <association property="idCard" column="card_id" 
                 select="selectCardById"/>
</resultMap>

<select id="selectById" resultMap="userWithCard">
    SELECT * FROM user WHERE id = #{id}
</select>

<select id="selectCardById" resultType="IdCard">
    SELECT * FROM id_card WHERE id = #{id}
</select>
```

**方式二：嵌套结果（推荐）**
```xml
<resultMap id="userWithCard" type="User">
    <id property="id" column="id"/>
    <result property="username" column="username"/>
    <association property="idCard" javaType="IdCard">
        <id property="id" column="card_id"/>
        <result property="cardNumber" column="card_number"/>
    </association>
</resultMap>

<select id="selectById" resultMap="userWithCard">
    SELECT u.*, c.id as card_id, c.card_number
    FROM user u
    LEFT JOIN id_card c ON u.card_id = c.id
    WHERE u.id = #{id}
</select>
```

---

### 12. MyBatis如何实现一对多关联？

**答：**

**使用 collection：**
```xml
<resultMap id="deptWithEmps" type="Department">
    <id property="id" column="id"/>
    <result property="deptName" column="dept_name"/>
    <collection property="employees" ofType="Employee">
        <id property="id" column="emp_id"/>
        <result property="empName" column="emp_name"/>
    </collection>
</resultMap>

<select id="selectById" resultMap="deptWithEmps">
    SELECT d.*, e.id as emp_id, e.emp_name
    FROM department d
    LEFT JOIN employee e ON d.id = e.dept_id
    WHERE d.id = #{id}
</select>
```

---

### 13. 什么是延迟加载？如何开启？

**答：**

**延迟加载：** 查询主对象时，不立即查询关联对象，在使用时才查询。

**开启：**
```xml
<!-- 全局配置 -->
<settings>
    <setting name="lazyLoadingEnabled" value="true"/>
    <setting name="aggressiveLazyLoading" value="false"/>
</settings>

<!-- Mapper 配置 -->
<association property="idCard" column="card_id" 
             select="selectCardById"
             fetchType="lazy"/>
```

**注意：** 只有嵌套查询支持延迟加载。

---

## 六、实战经验

### 14. MyBatis如何防止SQL注入？

**答：**

**1. 使用 #{} 预编译**
```xml
<!-- ✅ 推荐 -->
SELECT * FROM user WHERE id = #{id}

<!-- ❌ 不推荐 -->
SELECT * FROM user WHERE id = ${id}
```

**2. 参数验证**
```java
if (id == null || id <= 0) {
    throw new IllegalArgumentException("ID不合法");
}
```

**3. 白名单校验**
```java
// 动态排序时，使用白名单
List<String> allowedColumns = Arrays.asList("id", "username", "create_time");
if (!allowedColumns.contains(orderBy)) {
    throw new IllegalArgumentException("非法的排序字段");
}
```

---

### 15. MyBatis的N+1问题？

**答：**

**问题：** 嵌套查询会导致多次查询数据库。

**示例：**
```
查询10个部门，每个部门查询员工
SQL 执行次数：1（查部门）+ 10（查员工）= 11次
```

**解决方案：**
1. **使用嵌套结果（推荐）**
```xml
<!-- 一次JOIN查询 -->
<select id="selectById" resultMap="deptWithEmps">
    SELECT d.*, e.*
    FROM department d
    LEFT JOIN employee e ON d.id = e.dept_id
    WHERE d.id = #{id}
</select>
```

2. **开启延迟加载**
```xml
<settings>
    <setting name="lazyLoadingEnabled" value="true"/>
</settings>
```

---

### 16. MyBatis如何批量插入？

**答：**

**方式一：foreach**
```xml
<insert id="insertBatch">
    INSERT INTO user (username, email) VALUES
    <foreach collection="list" item="user" separator=",">
        (#{user.username}, #{user.email})
    </foreach>
</insert>
```

**方式二：ExecutorType.BATCH**
```java
SqlSession session = sqlSessionFactory.openSession(ExecutorType.BATCH);
UserMapper mapper = session.getMapper(UserMapper.class);

for (User user : users) {
    mapper.insert(user);
}

session.commit();
session.close();
```

---

## 七、综合题

### 17. MyBatis的核心组件？

**答：**

| 组件 | 说明 |
|------|------|
| SqlSessionFactoryBuilder | 构建 SqlSessionFactory |
| SqlSessionFactory | 创建 SqlSession 的工厂 |
| SqlSession | 执行 SQL 的会话 |
| Executor | 执行器，执行 SQL |
| StatementHandler | 语句处理器 |
| ParameterHandler | 参数处理器 |
| ResultSetHandler | 结果处理器 |
| Mapper | SQL 映射器接口 |

---

### 18. SqlSession是线程安全的吗？

**答：**

**不是线程安全的。**

**原因：**
- SqlSession 包含了状态
- 一级缓存存储在 SqlSession 中

**使用建议：**
- SqlSession 应该是方法级别的
- 使用后及时关闭
- 不要在全局或单例中使用

**正确使用：**
```java
try (SqlSession session = sqlSessionFactory.openSession()) {
    UserMapper mapper = session.getMapper(UserMapper.class);
    // 执行SQL
}
```

---

### 19. MyBatis插件的原理？

**答：**

**原理：** 使用动态代理，拦截 Executor、StatementHandler、ParameterHandler、ResultSetHandler 的方法。

**可拦截的对象和方法：**
- Executor (update, query, commit, rollback)
- ParameterHandler (getParameterObject, setParameters)
- ResultSetHandler (handleResultSets, handleOutputParameters)
- StatementHandler (prepare, parameterize, batch, update, query)

**自定义插件：**
```java
@Intercepts({
    @Signature(type = Executor.class, method = "query", 
               args = {MappedStatement.class, Object.class, 
                      RowBounds.class, ResultHandler.class})
})
public class MyPlugin implements Interceptor {
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        // 前置处理
        Object result = invocation.proceed();
        // 后置处理
        return result;
    }
}
```

---

### 20. MyBatis如何整合Spring？

**答：**

**添加依赖：**
```xml
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
</dependency>
```

**配置：**
```yaml
mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.example.entity
  configuration:
    map-underscore-to-camel-case: true
```

**使用：**
```java
@Service
public class UserService {
    
    @Autowired
    private UserMapper userMapper;
    
    public User findById(Long id) {
        return userMapper.selectById(id);
    }
}
```

---

## 八、总结

### 高频考点

✅ **必须掌握：**
- MyBatis 执行流程
- #{} vs ${}
- resultType vs resultMap
- 动态 SQL（if、where、foreach）
- 一级缓存 vs 二级缓存
- 一对一、一对多映射

✅ **加分项：**
- N+1 问题解决
- SQL 注入防止
- 插件原理
- 批量操作
- 性能优化

### 面试技巧

1. **先说原理，再举例子**
2. **画图说明执行流程**
3. **对比 MyBatis 和 Hibernate**
4. **结合项目经验**
5. **说明性能优化方案**

---

**恭喜你完成 MyBatis 学习！🎉**
