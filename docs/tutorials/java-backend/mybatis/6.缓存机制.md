---
title: 缓存机制
---

# 缓存机制

## 一、缓存概述

### 1.1 什么是缓存？

**缓存**：将数据存储在内存中，减少数据库访问次数，提高查询性能。

**MyBatis 缓存层级：**
- **一级缓存**：SqlSession 级别（默认开启）
- **二级缓存**：Mapper 级别（需要配置）

### 1.2 缓存作用

- ✅ 减少数据库访问
- ✅ 提高查询性能
- ✅ 降低数据库压力

---

## 二、一级缓存

### 2.1 一级缓存特点

| 特性 | 说明 |
|------|------|
| **级别** | SqlSession 级别 |
| **作用域** | 同一个 SqlSession |
| **默认** | 默认开启 |
| **存储** | 存储在内存（HashMap） |
| **失效** | SqlSession 关闭或清空 |

### 2.2 一级缓存工作流程

```
1. 第一次查询 ID=1
   ↓
2. 查询数据库
   ↓
3. 结果放入一级缓存
   ↓
4. 第二次查询 ID=1
   ↓
5. 直接从缓存获取（不查数据库）
```

### 2.3 一级缓存示例

```java
@Test
public void testFirstCache() {
    SqlSession session = SqlSessionUtil.getSqlSession();
    UserMapper mapper = session.getMapper(UserMapper.class);
    
    // 第一次查询
    User user1 = mapper.selectById(1L);
    System.out.println("第一次查询：" + user1);
    
    // 第二次查询（从缓存获取，不查数据库）
    User user2 = mapper.selectById(1L);
    System.out.println("第二次查询：" + user2);
    
    System.out.println(user1 == user2);  // true（同一个对象）
    
    session.close();
}
```

**输出：**
```
执行SQL：SELECT * FROM user WHERE id = 1
第一次查询：User(id=1, username=张三)
第二次查询：User(id=1, username=张三)
true
```

### 2.4 一级缓存失效场景

**场景1：不同的 SqlSession**
```java
SqlSession session1 = SqlSessionUtil.getSqlSession();
User user1 = session1.getMapper(UserMapper.class).selectById(1L);
session1.close();

SqlSession session2 = SqlSessionUtil.getSqlSession();
User user2 = session2.getMapper(UserMapper.class).selectById(1L);  // 查数据库
session2.close();
```

**场景2：同一个 SqlSession，不同的查询条件**
```java
SqlSession session = SqlSessionUtil.getSqlSession();
UserMapper mapper = session.getMapper(UserMapper.class);

User user1 = mapper.selectById(1L);  // 查数据库
User user2 = mapper.selectById(2L);  // 查数据库（不同ID）

session.close();
```

**场景3：执行了增删改操作**
```java
SqlSession session = SqlSessionUtil.getSqlSession();
UserMapper mapper = session.getMapper(UserMapper.class);

User user1 = mapper.selectById(1L);  // 查数据库

// 执行更新操作，缓存失效
mapper.update(new User());

User user2 = mapper.selectById(1L);  // 再次查数据库

session.close();
```

**场景4：手动清空缓存**
```java
SqlSession session = SqlSessionUtil.getSqlSession();
UserMapper mapper = session.getMapper(UserMapper.class);

User user1 = mapper.selectById(1L);  // 查数据库

// 清空缓存
session.clearCache();

User user2 = mapper.selectById(1L);  // 再次查数据库

session.close();
```

---

## 三、二级缓存

### 3.1 二级缓存特点

| 特性 | 说明 |
|------|------|
| **级别** | Mapper 级别 |
| **作用域** | 同一个 Mapper 的所有 SqlSession |
| **默认** | 需要手动开启 |
| **存储** | 序列化到硬盘或内存 |
| **失效** | 执行增删改操作 |

### 3.2 开启二级缓存

**1. 全局配置（mybatis-config.xml）**
```xml
<settings>
    <setting name="cacheEnabled" value="true"/>
</settings>
```

**2. Mapper XML 配置**
```xml
<mapper namespace="com.example.mapper.UserMapper">
    <!-- 开启二级缓存 -->
    <cache/>
    
    <select id="selectById" resultType="User">
        SELECT * FROM user WHERE id = #{id}
    </select>
</mapper>
```

**3. 实体类实现 Serializable**
```java
public class User implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private Long id;
    private String username;
    // ...
}
```

### 3.3 cache 标签属性

```xml
<cache
    eviction="LRU"          <!-- 缓存策略 -->
    flushInterval="60000"   <!-- 刷新间隔（毫秒） -->
    size="1024"             <!-- 缓存大小 -->
    readOnly="false"/>      <!-- 是否只读 -->
```

**eviction 缓存策略：**
- `LRU`（默认）- 最近最少使用
- `FIFO` - 先进先出
- `SOFT` - 软引用
- `WEAK` - 弱引用

### 3.4 二级缓存示例

```java
@Test
public void testSecondCache() {
    // 第一个 SqlSession
    SqlSession session1 = SqlSessionUtil.getSqlSession();
    User user1 = session1.getMapper(UserMapper.class).selectById(1L);
    System.out.println("第一次查询：" + user1);
    session1.close();  // 必须关闭，数据才会写入二级缓存
    
    // 第二个 SqlSession
    SqlSession session2 = SqlSessionUtil.getSqlSession();
    User user2 = session2.getMapper(UserMapper.class).selectById(1L);
    System.out.println("第二次查询：" + user2);  // 从二级缓存获取
    session2.close();
}
```

**输出：**
```
执行SQL：SELECT * FROM user WHERE id = 1
第一次查询：User(id=1, username=张三)
第二次查询：User(id=1, username=张三)  // 没有执行SQL
```

### 3.5 二级缓存失效场景

**场景1：执行了增删改操作**
```java
SqlSession session1 = SqlSessionUtil.getSqlSession();
session1.getMapper(UserMapper.class).selectById(1L);  // 查数据库
session1.close();

SqlSession session2 = SqlSessionUtil.getSqlSession();
session2.getMapper(UserMapper.class).update(new User());  // 更新操作
session2.commit();
session2.close();

SqlSession session3 = SqlSessionUtil.getSqlSession();
session3.getMapper(UserMapper.class).selectById(1L);  // 再次查数据库
session3.close();
```

**场景2：不同的 Mapper**
```java
// UserMapper 和 OrderMapper 是不同的 Mapper
// 各自有独立的二级缓存
```

---

## 四、缓存查询顺序

### 4.1 查询顺序

```
1. 先查二级缓存（Mapper 级别）
   ↓
2. 再查一级缓存（SqlSession 级别）
   ↓
3. 查询数据库
   ↓
4. 结果放入一级缓存
   ↓
5. SqlSession 关闭后，放入二级缓存
```

### 4.2 流程图

```
用户查询
   ↓
二级缓存有？ → 是 → 返回结果
   ↓ 否
一级缓存有？ → 是 → 返回结果
   ↓ 否
查询数据库
   ↓
放入一级缓存
   ↓
返回结果
   ↓
SqlSession关闭
   ↓
放入二级缓存
```

---

## 五、整合第三方缓存（Redis）

### 5.1 添加依赖

```xml
<dependency>
    <groupId>org.mybatis.caches</groupId>
    <artifactId>mybatis-redis</artifactId>
    <version>1.0.0-beta2</version>
</dependency>
```

### 5.2 配置 Redis

**redis.properties：**
```properties
redis.host=localhost
redis.port=6379
redis.connectionTimeout=5000
redis.password=
redis.database=0
```

### 5.3 Mapper 配置

```xml
<mapper namespace="com.example.mapper.UserMapper">
    <!-- 使用 Redis 缓存 -->
    <cache type="org.mybatis.caches.redis.RedisCache"/>
    
    <select id="selectById" resultType="User">
        SELECT * FROM user WHERE id = #{id}
    </select>
</mapper>
```

---

## 六、缓存使用建议

### 6.1 适用场景

**适合使用缓存：**
- ✅ 查询频繁
- ✅ 数据更新少
- ✅ 数据一致性要求不高
- ✅ 查询结果固定

**不适合使用缓存：**
- ❌ 实时性要求高
- ❌ 数据频繁更新
- ❌ 多表关联复杂

### 6.2 最佳实践

**1. 一级缓存**
```
默认开启，无需配置
注意 SqlSession 生命周期
```

**2. 二级缓存**
```
根据业务场景决定是否开启
实体类必须实现 Serializable
```

**3. 分布式环境**
```
不要使用 MyBatis 二级缓存
使用 Redis 等分布式缓存
```

**4. 缓存穿透**
```
使用布隆过滤器
缓存空值
```

---

## 七、总结

✅ **本章学习内容：**
- 一级缓存（SqlSession 级别）
- 二级缓存（Mapper 级别）
- 缓存失效场景
- 缓存查询顺序
- 整合 Redis
- 缓存使用建议

✅ **核心要点：**
- 一级缓存默认开启，SqlSession 级别
- 二级缓存需要配置，Mapper 级别
- 先查二级缓存，再查一级缓存，最后查数据库
- 分布式环境使用 Redis

**下一章预告：** 我们将学习 MyBatis 注解开发。
