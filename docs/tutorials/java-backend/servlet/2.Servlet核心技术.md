---
title: Servlet核心技术
---

# Servlet核心技术

## 一、HttpServletRequest

### 1.1 获取请求行信息

```java
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
    // 请求方式
    String method = req.getMethod(); // GET
    
    // 请求 URI
    String uri = req.getRequestURI(); // /servlet-demo/hello
    
    // 请求 URL
    StringBuffer url = req.getRequestURL(); // http://localhost:8080/servlet-demo/hello
    
    // 协议版本
    String protocol = req.getProtocol(); // HTTP/1.1
    
    // 上下文路径
    String contextPath = req.getContextPath(); // /servlet-demo
}
```

### 1.2 获取请求头

```java
// 获取指定请求头
String userAgent = req.getHeader("User-Agent");
String referer = req.getHeader("Referer");

// 获取所有请求头名称
Enumeration<String> headerNames = req.getHeaderNames();
while (headerNames.hasMoreElements()) {
    String name = headerNames.nextElement();
    String value = req.getHeader(name);
    System.out.println(name + ": " + value);
}
```

### 1.3 获取请求参数

```java
// 获取单个参数
String username = req.getParameter("username");

// 获取多个同名参数
String[] hobbies = req.getParameterValues("hobby");

// 获取所有参数
Map<String, String[]> paramMap = req.getParameterMap();
for (String key : paramMap.keySet()) {
    String[] values = paramMap.get(key);
    System.out.println(key + ": " + Arrays.toString(values));
}
```

### 1.4 域对象操作

```java
// 存储数据
req.setAttribute("user", new User("张三", 20));

// 获取数据
User user = (User) req.getAttribute("user");

// 删除数据
req.removeAttribute("user");
```

---

## 二、HttpServletResponse

### 2.1 设置响应行

```java
// 设置状态码
resp.setStatus(200); // 成功
resp.setStatus(404); // 未找到
resp.setStatus(500); // 服务器错误
```

### 2.2 设置响应头

```java
// 设置内容类型和编码
resp.setContentType("text/html;charset=UTF-8");

// 设置缓存
resp.setHeader("Cache-Control", "no-cache");

// 定时刷新
resp.setHeader("Refresh", "3;url=/index.jsp"); // 3秒后跳转
```

### 2.3 设置响应体

```java
// 获取字符输出流
PrintWriter out = resp.getWriter();
out.println("<h1>Hello</h1>");

// 获取字节输出流（用于下载文件）
ServletOutputStream sos = resp.getOutputStream();
```

---

## 三、请求转发 vs 重定向

### 3.1 请求转发（Forward）

**特点：**
- 服务器内部跳转
- 浏览器地址栏不变
- 只有一次请求
- 可以共享 request 数据
- 只能跳转到当前应用内部资源

**使用：**
```java
@WebServlet("/forwardA")
public class ForwardAServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) 
            throws ServletException, IOException {
        
        // 设置共享数据
        req.setAttribute("message", "来自 A 的消息");
        
        // 请求转发到 B
        req.getRequestDispatcher("/forwardB").forward(req, resp);
    }
}

@WebServlet("/forwardB")
public class ForwardBServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) 
            throws ServletException, IOException {
        
        // 获取共享数据
        String message = (String) req.getAttribute("message");
        resp.getWriter().println("收到消息：" + message);
    }
}
```

### 3.2 重定向（Redirect）

**特点：**
- 浏览器重新发起请求
- 浏览器地址栏改变
- 两次请求
- 不能共享 request 数据
- 可以跳转到任何资源

**使用：**
```java
@WebServlet("/redirectA")
public class RedirectAServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) 
            throws ServletException, IOException {
        
        // 重定向到 B（需要加上下文路径）
        resp.sendRedirect(req.getContextPath() + "/redirectB");
        
        // 重定向到外部网站
        resp.sendRedirect("https://www.baidu.com");
    }
}
```

### 3.3 对比总结

| 特性 | 请求转发 | 重定向 |
|------|---------|--------|
| 地址栏 | 不变 | 改变 |
| 请求次数 | 1次 | 2次 |
| 数据共享 | 可以 | 不可以 |
| 跳转范围 | 内部资源 | 任何资源 |
| 代码 | `request.getRequestDispatcher().forward()` | `response.sendRedirect()` |

---

## 四、中文乱码问题

### 4.1 POST 请求乱码

**问题：**
```java
String username = req.getParameter("username");
// username 是乱码
```

**解决：**
```java
// 在获取参数之前设置编码
req.setCharacterEncoding("UTF-8");
String username = req.getParameter("username");
```

### 4.2 GET 请求乱码

**Tomcat 8+ 已解决，无需处理。**

**Tomcat 7 及以下：**
```java
String username = req.getParameter("username");
// 转码
username = new String(username.getBytes("ISO-8859-1"), "UTF-8");
```

### 4.3 响应乱码

```java
// 方式1：分别设置
resp.setCharacterEncoding("UTF-8");
resp.setHeader("Content-Type", "text/html;charset=UTF-8");

// 方式2：一次设置（推荐）
resp.setContentType("text/html;charset=UTF-8");
```

---

## 五、文件上传下载

### 5.1 文件上传

**1. 添加依赖**
```xml
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.4</version>
</dependency>
```

**2. 上传表单**
```html
<form action="/upload" method="post" enctype="multipart/form-data">
    <input type="file" name="photo">
    <button type="submit">上传</button>
</form>
```

**3. Servlet 处理**
```java
@WebServlet("/upload")
@MultipartConfig // 必须添加
public class UploadServlet extends HttpServlet {
    
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) 
            throws ServletException, IOException {
        
        // 获取上传的文件
        Part part = req.getPart("photo");
        
        // 获取文件名
        String fileName = part.getSubmittedFileName();
        
        // 保存路径
        String savePath = getServletContext().getRealPath("/uploads");
        File dir = new File(savePath);
        if (!dir.exists()) {
            dir.mkdirs();
        }
        
        // 保存文件
        part.write(savePath + File.separator + fileName);
        
        resp.getWriter().println("上传成功！");
    }
}
```

### 5.2 文件下载

```java
@WebServlet("/download")
public class DownloadServlet extends HttpServlet {
    
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) 
            throws ServletException, IOException {
        
        // 文件路径
        String fileName = "test.jpg";
        String filePath = getServletContext().getRealPath("/files/" + fileName);
        
        // 设置响应头
        resp.setHeader("Content-Disposition", "attachment;filename=" + fileName);
        resp.setContentType("application/octet-stream");
        
        // 读取文件并输出
        try (FileInputStream fis = new FileInputStream(filePath);
             ServletOutputStream sos = resp.getOutputStream()) {
            
            byte[] buffer = new byte[1024];
            int len;
            while ((len = fis.read(buffer)) != -1) {
                sos.write(buffer, 0, len);
            }
        }
    }
}
```

---

## 六、过滤器（Filter）

### 6.1 Filter 概述

**作用：** 对请求和响应进行预处理和后处理。

**应用场景：**
- 统一设置编码
- 权限验证
- 日志记录
- 性能监控

### 6.2 创建 Filter

```java
@WebFilter("/*") // 拦截所有请求
public class EncodingFilter implements Filter {
    
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("Filter 初始化");
    }
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                         FilterChain chain) throws IOException, ServletException {
        
        // 前置处理
        System.out.println("请求到达");
        request.setCharacterEncoding("UTF-8");
        response.setCharacterEncoding("UTF-8");
        
        // 放行（继续执行下一个过滤器或目标资源）
        chain.doFilter(request, response);
        
        // 后置处理
        System.out.println("响应返回");
    }
    
    @Override
    public void destroy() {
        System.out.println("Filter 销毁");
    }
}
```

### 6.3 Filter 生命周期

```
1. 创建：服务器启动时创建 Filter
2. 初始化：调用 init() 方法
3. 拦截：每次请求调用 doFilter()
4. 销毁：服务器关闭时调用 destroy()
```

### 6.4 Filter 链

**多个Filter执行顺序：**
```
Filter1 → Filter2 → Servlet → Filter2 → Filter1

按照 @WebFilter 的注解顺序或 web.xml 配置顺序执行
```

**示例：**
```java
@WebFilter("/*")
@WebInitParam(name = "order", value = "1")
public class Filter1 implements Filter {
    public void doFilter(...) {
        System.out.println("Filter1 前置");
        chain.doFilter(request, response);
        System.out.println("Filter1 后置");
    }
}

@WebFilter("/*")
@WebInitParam(name = "order", value = "2")
public class Filter2 implements Filter {
    public void doFilter(...) {
        System.out.println("Filter2 前置");
        chain.doFilter(request, response);
        System.out.println("Filter2 后置");
    }
}

// 输出：
// Filter1 前置
// Filter2 前置
// Servlet 执行
// Filter2 后置
// Filter1 后置
```

---

## 七、监听器（Listener）

### 7.1 Listener 概述

**作用：** 监听 Web 应用中的事件。

**监听器类型：**
1. ServletContext 监听器
2. HttpSession 监听器
3. ServletRequest 监听器

### 7.2 ServletContext 监听器

```java
@WebListener
public class AppListener implements ServletContextListener {
    
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        System.out.println("应用启动");
        // 初始化操作
    }
    
    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        System.out.println("应用销毁");
        // 清理资源
    }
}
```

### 7.3 HttpSession 监听器

```java
@WebListener
public class SessionListener implements HttpSessionListener {
    
    @Override
    public void sessionCreated(HttpSessionEvent se) {
        System.out.println("Session 创建：" + se.getSession().getId());
    }
    
    @Override
    public void sessionDestroyed(HttpSessionEvent se) {
        System.out.println("Session 销毁：" + se.getSession().getId());
    }
}
```

### 7.4 在线统计示例

```java
@WebListener
public class OnlineCountListener implements HttpSessionListener {
    
    @Override
    public void sessionCreated(HttpSessionEvent se) {
        ServletContext context = se.getSession().getServletContext();
        Integer count = (Integer) context.getAttribute("onlineCount");
        if (count == null) {
            count = 0;
        }
        count++;
        context.setAttribute("onlineCount", count);
        System.out.println("用户上线，当前在线：" + count);
    }
    
    @Override
    public void sessionDestroyed(HttpSessionEvent se) {
        ServletContext context = se.getSession().getServletContext();
        Integer count = (Integer) context.getAttribute("onlineCount");
        count--;
        context.setAttribute("onlineCount", count);
        System.out.println("用户下线，当前在线：" + count);
    }
}
```

---

## 八、总结

✅ **本章学习内容：**
- HttpServletRequest 和 HttpServletResponse API
- 请求转发与重定向
- 中文乱码问题解决
- 文件上传下载
- 过滤器（Filter）
- 监听器（Listener）

✅ **核心要点：**
- 掌握请求响应对象的常用方法
- 理解转发和重定向的区别
- 掌握过滤器和监听器的使用
- 了解 Servlet 三大组件

**下一章预告：** 我们将学习 JSP 技术。
