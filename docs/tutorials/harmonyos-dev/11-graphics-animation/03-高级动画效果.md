---
title: 高级动画效果
date: 2025-01-22
---

# 高级动画效果

> 实现复杂的动画效果

## 🎬 组合动画

### 序列动画

```typescript
@Entry
@Component
struct SequenceAnimation {
  @State scale: number = 1
  @State opacity: number = 1
  @State rotate: number = 0
  
  async runSequence() {
    // 步骤1：放大
    animateTo({ duration: 500 }, () => {
      this.scale = 1.5
    })
    await this.delay(500)
    
    // 步骤2：淡出
    animateTo({ duration: 500 }, () => {
      this.opacity = 0.3
    })
    await this.delay(500)
    
    // 步骤3：旋转
    animateTo({ duration: 500 }, () => {
      this.rotate = 360
    })
    await this.delay(500)
    
    // 重置
    animateTo({ duration: 500 }, () => {
      this.scale = 1
      this.opacity = 1
      this.rotate = 0
    })
  }
  
  delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms))
  }
  
  build() {
    Column() {
      Column()
        .width(100)
        .height(100)
        .backgroundColor(Color.Blue)
        .scale({ x: this.scale, y: this.scale })
        .opacity(this.opacity)
        .rotate({ angle: this.rotate })
      
      Button('开始序列动画')
        .margin({ top: 100 })
        .onClick(() => {
          this.runSequence()
        })
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
  }
}
```

### 并行动画

```typescript
@Entry
@Component
struct ParallelAnimation {
  @State x: number = 0
  @State y: number = 0
  @State rotate: number = 0
  @State scale: number = 1
  
  runParallel() {
    animateTo({
      duration: 1000,
      curve: Curve.EaseInOut
    }, () => {
      this.x = 100
      this.y = 100
      this.rotate = 360
      this.scale = 1.5
    })
  }
  
  build() {
    Column() {
      Column()
        .width(80)
        .height(80)
        .backgroundColor(Color.Red)
        .translate({ x: this.x, y: this.y })
        .rotate({ angle: this.rotate })
        .scale({ x: this.scale, y: this.scale })
      
      Button('并行动画')
        .margin({ top: 200 })
        .onClick(() => {
          this.runParallel()
        })
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
  }
}
```

## 🖐️ 手势动画

### 拖拽动画

```typescript
@Entry
@Component
struct DragAnimation {
  @State offsetX: number = 0
  @State offsetY: number = 0
  
  build() {
    Column() {
      Column()
        .width(100)
        .height(100)
        .backgroundColor(Color.Blue)
        .translate({ x: this.offsetX, y: this.offsetY })
        .gesture(
          PanGesture()
            .onActionUpdate((event: GestureEvent) => {
              this.offsetX = event.offsetX
              this.offsetY = event.offsetY
            })
            .onActionEnd(() => {
              // 回弹动画
              animateTo({
                duration: 500,
                curve: Curve.Spring
              }, () => {
                this.offsetX = 0
                this.offsetY = 0
              })
            })
        )
      
      Text('拖拽方块，松手回弹')
        .margin({ top: 200 })
        .fontSize(16)
        .fontColor(Color.Gray)
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
  }
}
```

### 捏合缩放

```typescript
@Entry
@Component
struct PinchAnimation {
  @State scale: number = 1
  
  build() {
    Column() {
      Image($r('app.media.image'))
        .width(200)
        .height(200)
        .scale({ x: this.scale, y: this.scale })
        .gesture(
          PinchGesture()
            .onActionUpdate((event: GestureEvent) => {
              this.scale = event.scale
            })
            .onActionEnd(() => {
              // 限制缩放范围
              animateTo({ duration: 300 }, () => {
                if (this.scale < 0.5) {
                  this.scale = 0.5
                } else if (this.scale > 3) {
                  this.scale = 3
                }
              })
            })
        )
      
      Text(`缩放: ${this.scale.toFixed(2)}x`)
        .margin({ top: 20 })
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
  }
}
```

## 🌊 物理动画

### 弹簧动画

```typescript
@Entry
@Component
struct SpringAnimation {
  @State offset: number = 0
  
  bounce() {
    animateTo({
      duration: 800,
      curve: Curve.Spring,
      iterations: 1
    }, () => {
      this.offset = this.offset === 0 ? 200 : 0
    })
  }
  
  build() {
    Column() {
      Column()
        .width(60)
        .height(60)
        .backgroundColor(Color.Red)
        .borderRadius(30)
        .translate({ y: this.offset })
      
      Button('弹跳')
        .margin({ top: 300 })
        .onClick(() => {
          this.bounce()
        })
    }
    .width('100%')
    .height('100%')
    .padding({ top: 100 })
  }
}
```

## 🎯 实战案例：加载动画

```typescript
@Entry
@Component
struct LoadingAnimation {
  @State rotate: number = 0
  @State isLoading: boolean = false
  private timer: number = -1
  
  startLoading() {
    this.isLoading = true
    this.timer = setInterval(() => {
      animateTo({
        duration: 800,
        curve: Curve.Linear
      }, () => {
        this.rotate += 360
      })
    }, 800)
  }
  
  stopLoading() {
    this.isLoading = false
    clearInterval(this.timer)
    this.rotate = 0
  }
  
  build() {
    Column({ space: 30 }) {
      // 加载图标
      LoadIcon()
        .width(60)
        .height(60)
        .rotate({ angle: this.rotate })
        .visibility(this.isLoading ? Visibility.Visible : Visibility.Hidden)
      
      Text(this.isLoading ? '加载中...' : '已完成')
        .fontSize(18)
      
      Row({ space: 10 }) {
        Button('开始加载')
          .onClick(() => {
            this.startLoading()
          })
        
        Button('停止')
          .onClick(() => {
            this.stopLoading()
          })
      }
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
  }
}

@Component
struct LoadIcon {
  build() {
    Stack() {
      ForEach([0, 45, 90, 135, 180, 225, 270, 315], (angle: number, index: number) => {
        Column()
          .width(4)
          .height(15)
          .backgroundColor(Color.Blue)
          .borderRadius(2)
          .opacity(0.3 + (index * 0.1))
          .rotate({ angle: angle })
          .translate({ y: -20 })
      })
    }
    .width(60)
    .height(60)
  }
}
```

## 💡 最佳实践

### 1. 性能优化

```typescript
// ✅ 使用硬件加速属性
.translate()
.scale()
.rotate()
.opacity()

// ✅ 避免动画期间重新布局
// ❌ 不要在动画中修改 width/height
```

### 2. 动画流畅度

```typescript
// ✅ 60fps 动画持续时间
const duration = Math.ceil(distance / 60) * 16.67

// ✅ 使用合适的缓动函数
curve: Curve.EaseInOut  // 自然过渡
```

### 3. 动画取消

```typescript
private animationId: number = -1

startAnimation() {
  if (this.animationId >= 0) {
    // 取消之前的动画
    cancelAnimationFrame(this.animationId)
  }
  
  this.animationId = requestAnimationFrame(() => {
    // 动画逻辑
  })
}
```

## 📚 参考资源

- [动画概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-animation-overview-0000001820880269-V5)
- [手势事件](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/ts-gesture-settings-0000001815767612-V5)

---

**第11章完成！** 继续学习 → [第12章：多媒体增强](../12-multimedia-next/)
