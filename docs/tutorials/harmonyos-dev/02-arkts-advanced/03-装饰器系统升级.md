---
title: 装饰器系统升级
date: 2025-01-22
---

# 装饰器系统升级

> 掌握 HarmonyOS NEXT 的核心特性

## 📌 装饰器概述

装饰器是 ArkTS 的核心特性，用于声明组件、状态和行为。

### 装饰器分类

```typescript
装饰器体系
├─ 组件装饰器
│   ├─ @Component（定义组件）
│   ├─ @Entry（入口组件）
│   └─ @Reusable（可复用组件）
├─ 状态装饰器
│   ├─ @State（内部状态）
│   ├─ @Prop（单向传递）
│   ├─ @Link（双向绑定）
│   ├─ @Provide/@Consume（跨组件共享）
│   └─ @ObservedV2/@Trace（V2 版本）⭐ 新增
└─ 其他装饰器
    ├─ @Watch（监听变化）
    ├─ @Concurrent（并发任务）
    └─ @Builder（构建函数）
```

## 🆕 V2 状态管理装饰器

### @ObservedV2 和 @Trace

```typescript
// 新版本（HarmonyOS NEXT）
@ObservedV2
class Person {
  @Trace name: string = ''      // 细粒度监听
  @Trace age: number = 0
  city: string = ''              // 不监听
}

@Entry
@Component
struct PersonPage {
  @Local person: Person = new Person()
  
  build() {
    Column() {
      Text(`姓名: ${this.person.name}`)
      Text(`年龄: ${this.person.age}`)
      
      Button('修改姓名')
        .onClick(() => {
          this.person.name = '张三'  // UI 自动更新
        })
      
      Button('修改城市')
        .onClick(() => {
          this.person.city = '北京'  // UI 不更新（未监听）
        })
    }
  }
}
```

### 对比旧版本

```typescript
// 旧版本（HarmonyOS 4.0）
@Observed
class Person {
  name: string = ''
  age: number = 0
}

// 问题：整个对象都会被监听，性能差
```

## 🎯 核心装饰器详解

### @Component - 组件装饰器

```typescript
@Component
struct CustomButton {
  @Prop text: string = '按钮'
  @Prop onClick: () => void
  
  build() {
    Button(this.text)
      .onClick(this.onClick)
      .backgroundColor(Color.Blue)
  }
}

// 使用
@Entry
@Component
struct Index {
  build() {
    CustomButton({
      text: '点击我',
      onClick: () => console.log('Clicked')
    })
  }
}
```

### @State - 内部状态

```typescript
@Entry
@Component
struct Counter {
  @State count: number = 0
  @State message: string = 'Hello'
  @State isVisible: boolean = true
  
  build() {
    Column() {
      if (this.isVisible) {
        Text(this.message)
        Text(`Count: ${this.count}`)
      }
      
      Button('增加')
        .onClick(() => {
          this.count++           // UI 自动更新
        })
      
      Button('切换显示')
        .onClick(() => {
          this.isVisible = !this.isVisible
        })
    }
  }
}
```

### @Prop - 单向数据流

```typescript
@Component
struct ChildComponent {
  @Prop title: string = ''
  @Prop count: number = 0
  
  build() {
    Column() {
      Text(this.title)
      Text(`Count: ${this.count}`)
      
      Button('尝试修改')
        .onClick(() => {
          // ❌ 编译错误：@Prop 是只读的
          // this.count++
        })
    }
  }
}

@Entry
@Component
struct ParentComponent {
  @State parentCount: number = 0
  
  build() {
    Column() {
      Text(`父组件: ${this.parentCount}`)
      
      ChildComponent({
        title: '子组件',
        count: this.parentCount
      })
      
      Button('父组件修改')
        .onClick(() => {
          this.parentCount++  // 子组件会更新
        })
    }
  }
}
```

### @Link - 双向绑定

```typescript
@Component
struct ChildComponent {
  @Link value: number  // 双向绑定
  
  build() {
    Column() {
      Text(`子组件: ${this.value}`)
      
      Button('子组件修改')
        .onClick(() => {
          this.value++  // 父组件也会更新
        })
    }
  }
}

@Entry
@Component
struct ParentComponent {
  @State count: number = 0
  
  build() {
    Column() {
      Text(`父组件: ${this.count}`)
      
      // 使用 $count 传递引用
      ChildComponent({ value: $count })
      
      Button('父组件修改')
        .onClick(() => {
          this.count++  // 子组件也会更新
        })
    }
  }
}
```

### @Provide / @Consume - 跨组件共享

```typescript
@Entry
@Component
struct GrandParent {
  @Provide('theme') theme: string = 'light'
  
  build() {
    Column() {
      Parent()
      
      Button('切换主题')
        .onClick(() => {
          this.theme = this.theme === 'light' ? 'dark' : 'light'
        })
    }
  }
}

@Component
struct Parent {
  build() {
    Child()  // 中间组件不需要传递
  }
}

@Component
struct Child {
  @Consume('theme') theme: string  // 直接消费祖先组件的状态
  
  build() {
    Text(`当前主题: ${this.theme}`)
      .backgroundColor(this.theme === 'light' ? Color.White : Color.Black)
  }
}
```

## ⚡ 高级装饰器

### @Watch - 监听变化

```typescript
@Entry
@Component
struct WatchExample {
  @State @Watch('onCountChange') count: number = 0
  @State message: string = ''
  
  onCountChange() {
    this.message = `Count changed to ${this.count}`
    console.log('Count:', this.count)
  }
  
  build() {
    Column() {
      Text(this.message)
      Button(`Count: ${this.count}`)
        .onClick(() => this.count++)
    }
  }
}
```

### @Builder - 自定义构建函数

```typescript
@Entry
@Component
struct BuilderExample {
  @State selected: number = 0
  
  @Builder
  TabBuilder(index: number, name: string) {
    Column() {
      Text(name)
        .fontColor(this.selected === index ? Color.Blue : Color.Gray)
    }
    .onClick(() => {
      this.selected = index
    })
  }
  
  build() {
    Column() {
      Row() {
        this.TabBuilder(0, '首页')
        this.TabBuilder(1, '消息')
        this.TabBuilder(2, '我的')
      }
      
      if (this.selected === 0) {
        Text('首页内容')
      } else if (this.selected === 1) {
        Text('消息内容')
      } else {
        Text('我的内容')
      }
    }
  }
}
```

### @Concurrent - 并发任务

```typescript
import taskpool from '@ohos.taskpool'

@Concurrent
function heavyComputation(data: number[]): number {
  // 耗时计算
  return data.reduce((sum, num) => sum + num, 0)
}

@Entry
@Component
struct ConcurrentExample {
  @State result: number = 0
  
  async compute() {
    const data = Array.from({ length: 10000 }, (_, i) => i)
    
    // 在后台线程执行
    const task = new taskpool.Task(heavyComputation, data)
    this.result = await taskpool.execute(task)
  }
  
  build() {
    Column() {
      Text(`Result: ${this.result}`)
      Button('计算')
        .onClick(() => this.compute())
    }
  }
}
```

## 📚 最佳实践

### 1. 合理使用状态装饰器

```typescript
// ✅ 好的实践
@Entry
@Component
struct GoodPractice {
  @State activeTab: number = 0        // 需要响应式
  private readonly title: string = '标题'  // 不需要响应式
  
  build() {
    Column() {
      Text(this.title)
      Tabs({ index: this.activeTab })
    }
  }
}

// ❌ 避免
@Entry
@Component
struct BadPractice {
  @State title: string = '标题'  // 不需要 @State
}
```

### 2. 使用 V2 装饰器提升性能

```typescript
// ✅ 推荐：使用 @ObservedV2 和 @Trace
@ObservedV2
class User {
  @Trace name: string = ''
  @Trace age: number = 0
  address: string = ''  // 不需要监听
}

// ❌ 避免：使用 @Observed
@Observed
class User {
  name: string = ''
  age: number = 0
}
```

### 3. 避免过度使用 @Link

```typescript
// ✅ 只在需要双向绑定时使用 @Link
@Component
struct Input {
  @Link text: string
  
  build() {
    TextInput({ text: this.text })
      .onChange((value) => {
        this.text = value
      })
  }
}

// ❌ 不需要双向绑定时使用 @Prop
@Component
struct Display {
  @Prop text: string
  
  build() {
    Text(this.text)
  }
}
```

## 📚 参考资源

- [状态管理（V2试用版）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-new-observedv2-and-trace-0000001820999489-V5)

---

**下一节** → [并发与异步增强](04-并发与异步增强.md)
