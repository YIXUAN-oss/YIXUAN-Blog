---
title: 并发与异步增强
date: 2025-01-22
---

# 并发与异步增强

> 掌握 HarmonyOS NEXT 的并发编程

## 🔄 Promise 与 async/await

### 基础用法

```typescript
// Promise 基础
function fetchData(): Promise<string> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('数据加载完成')
    }, 1000)
  })
}

// async/await
async function loadData() {
  try {
    const data = await fetchData()
    console.log(data)
  } catch (error) {
    console.error('加载失败:', error)
  }
}
```

### 并行执行

```typescript
// 并行执行多个异步操作
async function loadAll() {
  const [user, orders, products] = await Promise.all([
    fetchUser(),
    fetchOrders(),
    fetchProducts()
  ])
  
  return { user, orders, products }
}

// Promise.race - 取最快的
async function quickFetch() {
  const result = await Promise.race([
    fetchFromCache(),
    fetchFromNetwork()
  ])
  return result
}
```

## ⚡ TaskPool 任务池

### 基本使用

```typescript
import taskpool from '@ohos.taskpool'

// 定义并发任务
@Concurrent
function heavyComputation(numbers: number[]): number {
  return numbers.reduce((sum, num) => sum + num, 0)
}

// 执行任务
async function compute() {
  const data = Array.from({ length: 10000 }, (_, i) => i)
  
  const task = new taskpool.Task(heavyComputation, data)
  const result = await taskpool.execute(task)
  
  console.log('计算结果:', result)
}
```

### 任务组

```typescript
// 批量执行任务
async function batchProcess() {
  const tasks = [
    new taskpool.Task(processImage, image1),
    new taskpool.Task(processImage, image2),
    new taskpool.Task(processImage, image3)
  ]
  
  const group = new taskpool.TaskGroup()
  tasks.forEach(task => group.addTask(task))
  
  const results = await group.execute()
  console.log('处理完成:', results)
}
```

## 👷 Worker 并发

### 创建 Worker

```typescript
// 主线程
import worker from '@ohos.worker'

const workerInstance = new worker.ThreadWorker('entry/ets/workers/MyWorker.ets')

// 发送消息
workerInstance.postMessage({ type: 'start', data: [1, 2, 3] })

// 接收消息
workerInstance.onmessage = (e) => {
  console.log('Worker 返回:', e.data)
}

// Worker 线程 (MyWorker.ets)
import worker from '@ohos.worker'

const parentPort = worker.workerPort

parentPort.onmessage = (e) => {
  const { type, data } = e.data
  
  if (type === 'start') {
    const result = processData(data)
    parentPort.postMessage({ result })
  }
}

function processData(data: number[]): number {
  return data.reduce((sum, num) => sum + num, 0)
}
```

## 💡 最佳实践

### 1. 选择合适的并发方式

```typescript
// TaskPool - 短时任务
@Concurrent
function quickTask(data: number): number {
  return data * 2
}

// Worker - 长时任务
// 在 Worker.ets 中处理耗时操作
```

### 2. 错误处理

```typescript
async function safeExecute() {
  try {
    const task = new taskpool.Task(compute, data)
    const result = await taskpool.execute(task)
    return result
  } catch (error) {
    console.error('任务执行失败:', error)
    return null
  }
}
```

### 3. 避免阻塞主线程

```typescript
// ✅ 耗时操作放到后台
async function processLargeData(data: number[]) {
  const task = new taskpool.Task(heavyProcess, data)
  return await taskpool.execute(task)
}

// ❌ 避免在主线程执行
function badProcess(data: number[]) {
  for (let i = 0; i < 1000000; i++) {
    // 阻塞主线程
  }
}
```

## 📚 参考资源

- [TaskPool 任务池](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/js-apis-taskpool-0000001820880665-V5)
- [Worker 工作线程](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/js-apis-worker-0000001821000441-V5)

---

**下一节** → [类型安全最佳实践](05-类型安全最佳实践.md)
