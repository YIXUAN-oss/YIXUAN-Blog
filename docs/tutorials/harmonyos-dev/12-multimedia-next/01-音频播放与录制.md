---
title: 音频播放与录制
date: 2025-01-22
---

# 音频播放与录制

> 实现音频播放和录制功能

## 🎵 音频播放

### AVPlayer 播放音频

```typescript
import { media } from '@kit.MediaKit'
import { BusinessError } from '@kit.BasicServicesKit'

@Entry
@Component
struct AudioPlayer {
  private avPlayer: media.AVPlayer | undefined
  @State isPlaying: boolean = false
  @State duration: number = 0
  @State currentTime: number = 0
  
  async aboutToAppear() {
    await this.initPlayer()
  }
  
  async initPlayer() {
    try {
      this.avPlayer = await media.createAVPlayer()
      
      // 监听状态变化
      this.avPlayer.on('stateChange', (state) => {
        console.log('状态:', state)
      })
      
      // 监听时长
      this.avPlayer.on('durationUpdate', (duration) => {
        this.duration = duration
      })
      
      // 监听播放进度
      this.avPlayer.on('timeUpdate', (time) => {
        this.currentTime = time
      })
      
      // 设置音频源
      this.avPlayer.url = 'https://example.com/audio.mp3'
      // 或本地文件
      // this.avPlayer.fdSrc = { fd: fileFd }
      
    } catch (err) {
      console.error('初始化失败:', err)
    }
  }
  
  async play() {
    if (this.avPlayer) {
      await this.avPlayer.play()
      this.isPlaying = true
    }
  }
  
  async pause() {
    if (this.avPlayer) {
      await this.avPlayer.pause()
      this.isPlaying = false
    }
  }
  
  async stop() {
    if (this.avPlayer) {
      await this.avPlayer.stop()
      this.isPlaying = false
      this.currentTime = 0
    }
  }
  
  async seek(time: number) {
    if (this.avPlayer) {
      await this.avPlayer.seek(time)
    }
  }
  
  formatTime(ms: number): string {
    const seconds = Math.floor(ms / 1000)
    const min = Math.floor(seconds / 60)
    const sec = seconds % 60
    return `${min}:${sec.toString().padStart(2, '0')}`
  }
  
  build() {
    Column({ space: 20 }) {
      Text('音频播放器')
        .fontSize(24)
        .fontWeight(FontWeight.Bold)
      
      // 进度条
      Row() {
        Text(this.formatTime(this.currentTime))
          .fontSize(14)
        
        Slider({
          value: this.currentTime,
          min: 0,
          max: this.duration,
          step: 1000
        })
        .layoutWeight(1)
        .onChange((value) => {
          this.seek(value)
        })
        
        Text(this.formatTime(this.duration))
          .fontSize(14)
      }
      .width('100%')
      
      // 控制按钮
      Row({ space: 20 }) {
        Button('播放')
          .onClick(() => {
            this.play()
          })
          .enabled(!this.isPlaying)
        
        Button('暂停')
          .onClick(() => {
            this.pause()
          })
          .enabled(this.isPlaying)
        
        Button('停止')
          .onClick(() => {
            this.stop()
          })
      }
    }
    .width('100%')
    .padding(20)
  }
  
  aboutToDisappear() {
    if (this.avPlayer) {
      this.avPlayer.release()
    }
  }
}
```

## 🎤 音频录制

### AVRecorder 录音

```typescript
import { media } from '@kit.MediaKit'
import { fileIo } from '@kit.CoreFileKit'

@Entry
@Component
struct AudioRecorder {
  private avRecorder: media.AVRecorder | undefined
  @State isRecording: boolean = false
  @State recordTime: number = 0
  private timer: number = -1
  
  async aboutToAppear() {
    await this.initRecorder()
  }
  
  async initRecorder() {
    try {
      this.avRecorder = await media.createAVRecorder()
      
      // 监听状态
      this.avRecorder.on('stateChange', (state) => {
        console.log('录制状态:', state)
      })
      
      // 监听错误
      this.avRecorder.on('error', (err) => {
        console.error('录制错误:', err)
      })
      
    } catch (err) {
      console.error('初始化录制器失败:', err)
    }
  }
  
  async startRecord() {
    if (!this.avRecorder) return
    
    try {
      // 配置录音参数
      const config: media.AVRecorderConfig = {
        audioSourceType: media.AudioSourceType.AUDIO_SOURCE_TYPE_MIC,
        profile: {
          audioBitrate: 48000,
          audioChannels: 2,
          audioCodec: media.CodecMimeType.AUDIO_AAC,
          audioSampleRate: 48000,
          fileFormat: media.ContainerFormatType.CFT_MPEG_4A
        },
        url: 'fd://' + await this.getFd(),
        rotation: 0
      }
      
      await this.avRecorder.prepare(config)
      await this.avRecorder.start()
      
      this.isRecording = true
      this.startTimer()
      
    } catch (err) {
      console.error('开始录制失败:', err)
    }
  }
  
  async stopRecord() {
    if (!this.avRecorder) return
    
    try {
      await this.avRecorder.stop()
      await this.avRecorder.release()
      
      this.isRecording = false
      this.stopTimer()
      this.recordTime = 0
      
      // 重新初始化
      await this.initRecorder()
      
    } catch (err) {
      console.error('停止录制失败:', err)
    }
  }
  
  async getFd(): Promise<number> {
    const context = getContext(this)
    const filesDir = context.filesDir
    const filePath = filesDir + '/recording.m4a'
    
    const file = fileIo.openSync(filePath, fileIo.OpenMode.CREATE | fileIo.OpenMode.READ_WRITE)
    return file.fd
  }
  
  startTimer() {
    this.timer = setInterval(() => {
      this.recordTime++
    }, 1000)
  }
  
  stopTimer() {
    if (this.timer >= 0) {
      clearInterval(this.timer)
      this.timer = -1
    }
  }
  
  formatTime(seconds: number): string {
    const min = Math.floor(seconds / 60)
    const sec = seconds % 60
    return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`
  }
  
  build() {
    Column({ space: 30 }) {
      Text('音频录制')
        .fontSize(24)
        .fontWeight(FontWeight.Bold)
      
      // 录制状态
      Column({ space: 10 }) {
        Text(this.isRecording ? '录制中...' : '未录制')
          .fontSize(18)
          .fontColor(this.isRecording ? Color.Red : Color.Gray)
        
        Text(this.formatTime(this.recordTime))
          .fontSize(48)
          .fontWeight(FontWeight.Bold)
      }
      
      // 控制按钮
      Row({ space: 20 }) {
        Button('开始录制')
          .width(120)
          .onClick(() => {
            this.startRecord()
          })
          .enabled(!this.isRecording)
        
        Button('停止录制')
          .width(120)
          .backgroundColor(Color.Red)
          .onClick(() => {
            this.stopRecord()
          })
          .enabled(this.isRecording)
      }
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
  }
  
  aboutToDisappear() {
    this.stopTimer()
    if (this.avRecorder) {
      this.avRecorder.release()
    }
  }
}
```

## 🎼 音频焦点管理

### 处理音频焦点

```typescript
import { audio } from '@kit.AudioKit'

class AudioFocusManager {
  private audioManager: audio.AudioManager
  private interruptMode: audio.InterruptMode = audio.InterruptMode.SHARE_MODE
  
  constructor() {
    this.audioManager = audio.getAudioManager()
  }
  
  // 请求音频焦点
  async requestFocus() {
    try {
      await this.audioManager.requestAudioFocus({
        streamUsage: audio.StreamUsage.STREAM_USAGE_MEDIA,
        interruptMode: this.interruptMode
      })
      console.log('获取音频焦点成功')
    } catch (err) {
      console.error('请求音频焦点失败:', err)
    }
  }
  
  // 释放音频焦点
  async abandonFocus() {
    try {
      await this.audioManager.abandonAudioFocus({
        streamUsage: audio.StreamUsage.STREAM_USAGE_MEDIA
      })
      console.log('释放音频焦点成功')
    } catch (err) {
      console.error('释放音频焦点失败:', err)
    }
  }
  
  // 监听音频中断
  onAudioInterrupt(callback: (interruptEvent: audio.InterruptEvent) => void) {
    this.audioManager.on('audioInterrupt', callback)
  }
}

// 使用
@Entry
@Component
struct AudioFocusDemo {
  private focusManager: AudioFocusManager = new AudioFocusManager()
  
  aboutToAppear() {
    // 请求焦点
    this.focusManager.requestFocus()
    
    // 监听中断
    this.focusManager.onAudioInterrupt((event) => {
      if (event.forceType === audio.InterruptForceType.INTERRUPT_FORCE) {
        // 强制中断，暂停播放
        console.log('被强制中断')
      }
    })
  }
  
  aboutToDisappear() {
    this.focusManager.abandonFocus()
  }
  
  build() {
    Column() {
      Text('音频焦点管理')
    }
  }
}
```

## 💡 最佳实践

### 1. 资源管理

```typescript
// ✅ 及时释放资源
aboutToDisappear() {
  if (this.avPlayer) {
    this.avPlayer.release()
  }
}
```

### 2. 错误处理

```typescript
try {
  await this.avPlayer.play()
} catch (err) {
  const error = err as BusinessError
  if (error.code === 5400102) {
    console.error('播放操作不允许')
  }
}
```

### 3. 权限申请

```json5
// module.json5
{
  "requestPermissions": [
    {
      "name": "ohos.permission.MICROPHONE",
      "reason": "用于录音",
      "usedScene": {
        "when": "inuse"
      }
    }
  ]
}
```

## 📚 参考资源

- [音频播放](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/audio-playback-overview-0000001820880689-V5)
- [音频录制](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/audio-recording-overview-0000001774280838-V5)
- [AVPlayer API](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/js-apis-media-0000001821000377-V5)

---

**下一节** → [视频播放与处理](02-视频播放与处理.md)
