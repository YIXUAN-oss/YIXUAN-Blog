---
title: 自定义组件最佳实践
date: 2025-01-22
---

# 自定义组件最佳实践

> 编写高质量、可复用的组件

## 🎯 组件设计原则

### 1. 单一职责

```typescript
// ✅ 好的设计 - 每个组件只做一件事
@Component
export struct UserAvatar {
  @Prop url: string
  @Prop size: number = 50
  
  build() {
    Image(this.url)
      .width(this.size)
      .height(this.size)
      .borderRadius(this.size / 2)
  }
}

@Component
export struct UserName {
  @Prop name: string
  
  build() {
    Text(this.name)
      .fontSize(16)
      .fontWeight(FontWeight.Bold)
  }
}
```

### 2. 组件复用

```typescript
@Component
export struct Button {
  @Prop text: string
  @Prop type: 'primary' | 'default' = 'default'
  @Prop onClick: () => void
  
  build() {
    Button(this.text)
      .backgroundColor(this.type === 'primary' ? Color.Blue : Color.Gray)
      .onClick(this.onClick)
  }
}
```

### 3. Props 验证

```typescript
@Component
export struct Card {
  @Prop title: string = ''  // 提供默认值
  @Prop @Require content: string  // 必填属性
  
  build() {
    Column() {
      if (this.title) {
        Text(this.title)
      }
      Text(this.content)
    }
  }
}
```

## 🔄 组件通信

### 父子通信

```typescript
// 父组件
@Entry
@Component
struct Parent {
  @State count: number = 0
  
  build() {
    Column() {
      Child({
        value: this.count,
        onUpdate: (newValue) => {
          this.count = newValue
        }
      })
    }
  }
}

// 子组件
@Component
struct Child {
  @Prop value: number
  @Prop onUpdate: (value: number) => void
  
  build() {
    Button(`Count: ${this.value}`)
      .onClick(() => {
        this.onUpdate(this.value + 1)
      })
  }
}
```

### 跨组件通信

```typescript
// 使用 @Provide/@Consume
@Entry
@Component
struct Root {
  @Provide('theme') theme: string = 'light'
  
  build() {
    Column() {
      MiddleComponent()
    }
  }
}

@Component
struct MiddleComponent {
  build() {
    DeepComponent()
  }
}

@Component
struct DeepComponent {
  @Consume('theme') theme: string
  
  build() {
    Text(`Theme: ${this.theme}`)
  }
}
```

## ⚡ 性能优化

### 1. 使用 @Reusable

```typescript
@Reusable
@Component
struct ListItem {
  @Prop data: ItemData
  
  aboutToReuse(params: Record<string, Object>) {
    this.data = params.data as ItemData
  }
  
  build() {
    Row() {
      Text(this.data.title)
    }
  }
}
```

### 2. 避免过度渲染

```typescript
// ✅ 只在需要时更新
@State items: Item[] = []

updateItem(index: number, newData: Item) {
  this.items[index] = newData
  this.items = [...this.items]  // 触发更新
}
```

## 💡 最佳实践总结

1. ✅ 保持组件简单和专注
2. ✅ 提供清晰的 Props 接口
3. ✅ 使用 TypeScript 类型
4. ✅ 注重性能优化
5. ✅ 编写可复用的组件

## 📚 参考资源

- [自定义组件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-create-custom-components-0000001473537046-V3)

---

**第3章完成！** 继续学习 → [第4章：状态管理 NEXT](../04-state-management-next/)
