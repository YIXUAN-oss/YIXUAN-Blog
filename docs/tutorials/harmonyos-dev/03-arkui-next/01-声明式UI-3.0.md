---
title: 声明式 UI 3.0
date: 2025-01-22
---

# 声明式 UI 3.0

> 用代码描述界面，让 UI 开发更简单

## 🎨 什么是声明式 UI

### 声明式 vs 命令式

**命令式 UI（传统方式）：**
```java
// Android 命令式
TextView textView = new TextView(context);
textView.setText("Hello");
textView.setTextSize(16);
textView.setTextColor(Color.BLACK);
layout.addView(textView);
```

**声明式 UI（ArkUI NEXT）：**
```typescript
// HarmonyOS NEXT 声明式
Text('Hello')
  .fontSize(16)
  .fontColor(Color.Black)
```

### 核心特点

| 特性 | 说明 |
|------|------|
| **组件化** | 一切皆组件 |
| **状态驱动** | UI = f(state) |
| **响应式** | 状态变化自动更新 UI |
| **声明式** | 描述"是什么"而非"怎么做" |

## 🏗️ ArkUI 3.0 架构

```
┌─────────────────────────────┐
│     ArkTS Component          │ 开发层
├─────────────────────────────┤
│     ArkUI Framework          │ 框架层
├─────────────────────────────┤
│     Rendering Engine         │ 渲染引擎
├─────────────────────────────┤
│     Graphics Engine          │ 图形引擎
└─────────────────────────────┘
```

## 📦 基础组件

### 1. 文本组件 - Text

```typescript
@Entry
@Component
struct TextExample {
  build() {
    Column() {
      // 基础文本
      Text('基础文本')
      
      // 样式文本
      Text('样式文本')
        .fontSize(20)
        .fontColor(Color.Blue)
        .fontWeight(FontWeight.Bold)
        .fontStyle(FontStyle.Italic)
      
      // 多行文本
      Text('这是一段很长的文本，会自动换行显示多行内容')
        .width('80%')
        .maxLines(2)
        .textOverflow({ overflow: TextOverflow.Ellipsis })
      
      // 富文本
      Text() {
        Span('Hello ')
          .fontColor(Color.Red)
        Span('World')
          .fontColor(Color.Blue)
          .fontSize(24)
      }
    }
    .width('100%')
    .height('100%')
    .padding(20)
  }
}
```

### 2. 按钮组件 - Button

```typescript
@Entry
@Component
struct ButtonExample {
  @State counter: number = 0
  
  build() {
    Column({ space: 20 }) {
      // 文本按钮
      Button('文本按钮')
        .type(ButtonType.Normal)
        .onClick(() => {
          this.counter++
        })
      
      // 胶囊按钮
      Button('胶囊按钮')
        .type(ButtonType.Capsule)
        .backgroundColor(Color.Blue)
      
      // 圆形按钮
      Button('+')
        .type(ButtonType.Circle)
        .width(60)
        .height(60)
      
      // 自定义按钮
      Button() {
        Row({ space: 8 }) {
          Image($r('app.media.icon'))
            .width(24)
            .height(24)
          Text('自定义按钮')
        }
      }
      .width(200)
      
      Text(`点击次数: ${this.counter}`)
    }
    .width('100%')
    .height('100%')
    .padding(20)
  }
}
```

### 3. 图片组件 - Image

```typescript
@Entry
@Component
struct ImageExample {
  build() {
    Column({ space: 20 }) {
      // 本地资源
      Image($r('app.media.icon'))
        .width(100)
        .height(100)
      
      // 网络图片
      Image('https://example.com/image.jpg')
        .width(200)
        .height(200)
        .objectFit(ImageFit.Cover)
      
      // 圆形图片
      Image($r('app.media.avatar'))
        .width(80)
        .height(80)
        .borderRadius(40)
      
      // 带占位图
      Image($r('app.media.photo'))
        .alt($r('app.media.placeholder'))
        .onComplete(() => {
          console.log('图片加载完成')
        })
        .onError(() => {
          console.log('图片加载失败')
        })
    }
    .width('100%')
    .padding(20)
  }
}
```

### 4. 输入框 - TextInput

```typescript
@Entry
@Component
struct TextInputExample {
  @State username: string = ''
  @State password: string = ''
  
  build() {
    Column({ space: 20 }) {
      // 普通输入框
      TextInput({ placeholder: '请输入用户名' })
        .onChange((value: string) => {
          this.username = value
        })
      
      // 密码输入框
      TextInput({ placeholder: '请输入密码' })
        .type(InputType.Password)
        .onChange((value: string) => {
          this.password = value
        })
      
      // 数字输入框
      TextInput({ placeholder: '请输入手机号' })
        .type(InputType.Number)
        .maxLength(11)
      
      // 多行输入框
      TextArea({ placeholder: '请输入内容' })
        .height(100)
      
      Button('提交')
        .onClick(() => {
          console.log('用户名:', this.username)
          console.log('密码:', this.password)
        })
    }
    .width('100%')
    .padding(20)
  }
}
```

## 📐 布局组件

### 1. Column - 垂直布局

```typescript
Column({ space: 10 }) {  // 子组件间距
  Text('Item 1')
  Text('Item 2')
  Text('Item 3')
}
.width('100%')
.height(200)
.justifyContent(FlexAlign.Center)      // 垂直对齐
.alignItems(HorizontalAlign.Center)     // 水平对齐
```

### 2. Row - 水平布局

```typescript
Row({ space: 10 }) {
  Text('Left')
  Text('Center')
  Text('Right')
}
.width('100%')
.height(60)
.justifyContent(FlexAlign.SpaceBetween)  // 水平对齐
.alignItems(VerticalAlign.Center)        // 垂直对齐
```

### 3. Flex - 弹性布局

```typescript
Flex({ 
  direction: FlexDirection.Row,
  wrap: FlexWrap.Wrap,
  justifyContent: FlexAlign.SpaceBetween,
  alignItems: ItemAlign.Center
}) {
  Text('Item 1').flexGrow(1)
  Text('Item 2').flexGrow(2)
  Text('Item 3').flexShrink(1)
}
```

### 4. Stack - 层叠布局

```typescript
Stack({ alignContent: Alignment.Bottom }) {
  Image($r('app.media.background'))
    .width('100%')
    .height('100%')
  
  Text('标题')
    .fontSize(24)
    .fontColor(Color.White)
    .padding(20)
}
.width('100%')
.height(300)
```

## 🎯 状态管理

### @State - 组件内部状态

```typescript
@Entry
@Component
struct Counter {
  @State count: number = 0
  
  build() {
    Column() {
      Text(`Count: ${this.count}`)
        .fontSize(24)
      
      Button('增加')
        .onClick(() => {
          this.count++  // UI 自动更新
        })
    }
  }
}
```

### @Prop - 单向数据流

```typescript
@Component
struct ChildComponent {
  @Prop message: string = ''  // 从父组件接收
  
  build() {
    Text(this.message)
  }
}

@Entry
@Component
struct ParentComponent {
  @State parentMessage: string = 'Hello'
  
  build() {
    Column() {
      ChildComponent({ message: this.parentMessage })
      
      Button('改变消息')
        .onClick(() => {
          this.parentMessage = 'World'
        })
    }
  }
}
```

### @Link - 双向绑定

```typescript
@Component
struct ChildComponent {
  @Link value: number  // 双向绑定
  
  build() {
    Button(`子组件: ${this.value}`)
      .onClick(() => {
        this.value++  // 修改会同步到父组件
      })
  }
}

@Entry
@Component
struct ParentComponent {
  @State count: number = 0
  
  build() {
    Column() {
      Text(`父组件: ${this.count}`)
      ChildComponent({ value: $count })  // $ 表示双向绑定
    }
  }
}
```

## 🔄 条件渲染

### if/else

```typescript
@Entry
@Component
struct ConditionalRender {
  @State isLoggedIn: boolean = false
  
  build() {
    Column() {
      if (this.isLoggedIn) {
        Text('欢迎回来!')
        Button('退出登录')
          .onClick(() => {
            this.isLoggedIn = false
          })
      } else {
        Text('请先登录')
        Button('登录')
          .onClick(() => {
            this.isLoggedIn = true
          })
      }
    }
  }
}
```

## 🔁 列表渲染

### ForEach

```typescript
@Entry
@Component
struct ListRender {
  @State items: string[] = ['Item 1', 'Item 2', 'Item 3']
  
  build() {
    Column() {
      ForEach(this.items, (item: string, index: number) => {
        Row() {
          Text(`${index + 1}. ${item}`)
        }
        .width('100%')
        .padding(10)
        .backgroundColor(Color.White)
        .margin({ bottom: 10 })
      }, (item: string) => item)  // key 生成函数
    }
    .width('100%')
    .padding(20)
  }
}
```

### LazyForEach - 懒加载

```typescript
class BasicDataSource implements IDataSource {
  private listeners: DataChangeListener[] = []
  private data: string[] = []
  
  public totalCount(): number {
    return this.data.length
  }
  
  public getData(index: number): string {
    return this.data[index]
  }
  
  registerDataChangeListener(listener: DataChangeListener): void {
    this.listeners.push(listener)
  }
  
  unregisterDataChangeListener(listener: DataChangeListener): void {
    const pos = this.listeners.indexOf(listener)
    if (pos >= 0) {
      this.listeners.splice(pos, 1)
    }
  }
}

@Entry
@Component
struct LazyList {
  private data: BasicDataSource = new BasicDataSource()
  
  build() {
    List() {
      LazyForEach(this.data, (item: string) => {
        ListItem() {
          Text(item)
        }
      }, item => item)
    }
  }
}
```

## 🎨 组件样式

### 通用样式

```typescript
Text('样式示例')
  .width(200)                    // 宽度
  .height(60)                    // 高度
  .backgroundColor(Color.Blue)   // 背景色
  .borderRadius(10)              // 圆角
  .padding(10)                   // 内边距
  .margin(20)                    // 外边距
  .opacity(0.8)                  // 透明度
  .shadow({                      // 阴影
    radius: 10,
    color: Color.Gray,
    offsetX: 5,
    offsetY: 5
  })
```

### 响应式样式

```typescript
@Entry
@Component
struct ResponsiveStyle {
  @State fontSize: number = 16
  
  build() {
    Column() {
      Text('响应式文本')
        .fontSize(this.fontSize)
      
      Button('增大字体')
        .onClick(() => {
          this.fontSize += 2
        })
    }
  }
}
```

## 📚 最佳实践

### 1. 组件拆分

```typescript
// ✅ 好的实践 - 单一职责
@Component
struct UserAvatar {
  @Prop avatarUrl: string
  
  build() {
    Image(this.avatarUrl)
      .width(50)
      .height(50)
      .borderRadius(25)
  }
}

@Component
struct UserInfo {
  @Prop name: string
  @Prop email: string
  
  build() {
    Column() {
      Text(this.name)
      Text(this.email)
    }
  }
}
```

### 2. 避免过度嵌套

```typescript
// ❌ 避免
Column() {
  Row() {
    Column() {
      Row() {
        Text('深层嵌套')
      }
    }
  }
}

// ✅ 推荐 - 提取组件
@Component
struct Content {
  build() {
    Text('清晰结构')
  }
}
```

### 3. 合理使用状态

```typescript
// ✅ 只在需要响应式的地方使用 @State
@Entry
@Component
struct GoodPractice {
  @State activeTab: number = 0  // 需要响应式
  private readonly title: string = '标题'  // 不需要响应式
  
  build() {
    Column() {
      Text(this.title)
      Tabs({ index: this.activeTab })
    }
  }
}
```

## 📚 参考资源

- [ArkUI 概述](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkui-overview-0000001820999645-V5)
- [组件参考](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/ts-universal-events-click-0000001774279954-V5)

---

**下一节** → [组件系统重构](02-组件系统重构.md)
