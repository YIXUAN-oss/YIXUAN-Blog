---
title: 数据加密与存储
date: 2025-01-22
---

# 数据加密与存储

> 保护敏感数据安全

## 🔐 数据加密

### HUKS 密钥管理

```typescript
import { huks } from '@kit.UniversalKeystoreKit'

class EncryptionService {
  private keyAlias: string = 'user_data_key'
  
  // 生成密钥
  async generateKey() {
    const properties: huks.HuksOptions = {
      properties: [
        {
          tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
          value: huks.HuksKeyAlg.HUKS_ALG_AES
        },
        {
          tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,
          value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256
        },
        {
          tag: huks.HuksTag.HUKS_TAG_PURPOSE,
          value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT |
                 huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
        }
      ]
    }
    
    try {
      await huks.generateKeyItem(this.keyAlias, properties)
      console.log('密钥生成成功')
    } catch (err) {
      console.error('密钥生成失败:', err)
    }
  }
  
  // 加密数据
  async encrypt(plainText: string): Promise<string> {
    const textEncoder = new util.TextEncoder()
    const plainData = textEncoder.encodeInto(plainText)
    
    const encryptOptions: huks.HuksOptions = {
      properties: [
        {
          tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
          value: huks.HuksKeyAlg.HUKS_ALG_AES
        },
        {
          tag: huks.HuksTag.HUKS_TAG_PURPOSE,
          value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT
        },
        {
          tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
          value: huks.HuksTagBlockMode.HUKS_TAG_BLOCK_MODE_CBC
        },
        {
          tag: huks.HuksTag.HUKS_TAG_PADDING,
          value: huks.HuksKeyPadding.HUKS_PADDING_PKCS7
        }
      ],
      inData: plainData
    }
    
    try {
      const handle = await huks.initSession(this.keyAlias, encryptOptions)
      const encrypted = await huks.finishSession(handle, encryptOptions)
      
      return this.arrayBufferToBase64(encrypted.outData!)
    } catch (err) {
      console.error('加密失败:', err)
      throw err
    }
  }
  
  // 解密数据
  async decrypt(encryptedText: string): Promise<string> {
    const encryptedData = this.base64ToArrayBuffer(encryptedText)
    
    const decryptOptions: huks.HuksOptions = {
      properties: [
        {
          tag: huks.HuksTag.HUKS_TAG_ALGORITHM,
          value: huks.HuksKeyAlg.HUKS_ALG_AES
        },
        {
          tag: huks.HuksTag.HUKS_TAG_PURPOSE,
          value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT
        },
        {
          tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,
          value: huks.HuksTagBlockMode.HUKS_TAG_BLOCK_MODE_CBC
        },
        {
          tag: huks.HuksTag.HUKS_TAG_PADDING,
          value: huks.HuksKeyPadding.HUKS_PADDING_PKCS7
        }
      ],
      inData: encryptedData
    }
    
    try {
      const handle = await huks.initSession(this.keyAlias, decryptOptions)
      const decrypted = await huks.finishSession(handle, decryptOptions)
      
      const textDecoder = new util.TextDecoder()
      return textDecoder.decodeWithStream(decrypted.outData!)
    } catch (err) {
      console.error('解密失败:', err)
      throw err
    }
  }
  
  // 删除密钥
  async deleteKey() {
    try {
      await huks.deleteKeyItem(this.keyAlias, {})
      console.log('密钥删除成功')
    } catch (err) {
      console.error('密钥删除失败:', err)
    }
  }
  
  private arrayBufferToBase64(buffer: ArrayBuffer): string {
    const bytes = new Uint8Array(buffer)
    let binary = ''
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i])
    }
    return btoa(binary)
  }
  
  private base64ToArrayBuffer(base64: string): ArrayBuffer {
    const binary = atob(base64)
    const bytes = new Uint8Array(binary.length)
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i)
    }
    return bytes.buffer
  }
}
```

## 🔒 安全存储

### 加密存储用户数据

```typescript
import { preferences } from '@kit.ArkData'

class SecureStorage {
  private prefs: preferences.Preferences | null = null
  private encryptionService: EncryptionService = new EncryptionService()
  
  async init(context: Context) {
    this.prefs = await preferences.getPreferences(context, 'secure_storage')
    await this.encryptionService.generateKey()
  }
  
  // 安全保存数据
  async secureSet(key: string, value: string) {
    if (!this.prefs) return
    
    try {
      // 加密数据
      const encrypted = await this.encryptionService.encrypt(value)
      
      // 存储
      await this.prefs.put(key, encrypted)
      await this.prefs.flush()
      
      console.log('数据安全保存成功')
    } catch (err) {
      console.error('安全保存失败:', err)
    }
  }
  
  // 安全读取数据
  async secureGet(key: string): Promise<string | null> {
    if (!this.prefs) return null
    
    try {
      // 读取加密数据
      const encrypted = await this.prefs.get(key, '') as string
      
      if (!encrypted) {
        return null
      }
      
      // 解密
      const decrypted = await this.encryptionService.decrypt(encrypted)
      return decrypted
    } catch (err) {
      console.error('安全读取失败:', err)
      return null
    }
  }
  
  // 删除数据
  async secureDelete(key: string) {
    if (!this.prefs) return
    
    try {
      await this.prefs.delete(key)
      await this.prefs.flush()
    } catch (err) {
      console.error('删除失败:', err)
    }
  }
}
```

## 🎯 实战案例：用户凭证管理

```typescript
@Entry
@Component
struct LoginPage {
  private secureStorage: SecureStorage = new SecureStorage()
  @State username: string = ''
  @State password: string = ''
  @State rememberMe: boolean = false
  
  async aboutToAppear() {
    await this.secureStorage.init(getContext(this))
    await this.loadSavedCredentials()
  }
  
  async loadSavedCredentials() {
    try {
      const savedUsername = await this.secureStorage.secureGet('username')
      const savedPassword = await this.secureStorage.secureGet('password')
      
      if (savedUsername && savedPassword) {
        this.username = savedUsername
        this.password = savedPassword
        this.rememberMe = true
      }
    } catch (err) {
      console.error('加载凭证失败:', err)
    }
  }
  
  async login() {
    if (!this.username || !this.password) {
      promptAction.showToast({ message: '请输入用户名和密码' })
      return
    }
    
    try {
      // 调用登录API
      const success = await this.performLogin(this.username, this.password)
      
      if (success) {
        // 保存凭证
        if (this.rememberMe) {
          await this.secureStorage.secureSet('username', this.username)
          await this.secureStorage.secureSet('password', this.password)
        } else {
          // 清除保存的凭证
          await this.secureStorage.secureDelete('username')
          await this.secureStorage.secureDelete('password')
        }
        
        // 跳转到首页
        router.replaceUrl({ url: 'pages/Home' })
      } else {
        promptAction.showToast({ message: '登录失败' })
      }
    } catch (err) {
      console.error('登录错误:', err)
    }
  }
  
  async performLogin(username: string, password: string): Promise<boolean> {
    // 实际的登录逻辑
    return true
  }
  
  build() {
    Column({ space: 20 }) {
      Text('登录')
        .fontSize(32)
        .fontWeight(FontWeight.Bold)
      
      TextInput({ placeholder: '用户名' })
        .type(InputType.Normal)
        .onChange((value) => {
          this.username = value
        })
      
      TextInput({ placeholder: '密码' })
        .type(InputType.Password)
        .onChange((value) => {
          this.password = value
        })
      
      Row() {
        Checkbox()
          .select(this.rememberMe)
          .onChange((checked) => {
            this.rememberMe = checked
          })
        
        Text('记住密码')
          .fontSize(14)
      }
      
      Button('登录')
        .width('100%')
        .onClick(() => {
          this.login()
        })
    }
    .width('80%')
    .padding(20)
  }
}
```

## 💡 最佳实践

### 1. 敏感数据加密

```typescript
// ✅ 加密存储敏感数据
await secureStorage.secureSet('token', authToken)
await secureStorage.secureSet('password', userPassword)

// ❌ 避免明文存储
await prefs.put('token', authToken)  // 不安全
```

### 2. 密钥管理

```typescript
// ✅ 使用 HUKS 管理密钥
const keyAlias = 'app_master_key'
await huks.generateKeyItem(keyAlias, options)

// ❌ 避免硬编码密钥
const KEY = 'hardcoded_key_123'  // 不安全
```

### 3. 数据清理

```typescript
// ✅ 用户登出时清理敏感数据
async logout() {
  await secureStorage.secureDelete('token')
  await secureStorage.secureDelete('userInfo')
  router.replaceUrl({ url: 'pages/Login' })
}
```

## 📚 参考资源

- [通用密钥库](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/huks-guidelines-0000001821000685-V5)
- [数据安全](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/data-security-protection-0000001774121022-V5)

---

**下一节** → [生物识别](03-生物识别.md)
