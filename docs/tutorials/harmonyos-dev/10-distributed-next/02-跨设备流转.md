---
title: 跨设备流转
date: 2025-01-22
---

# 跨设备流转

> 实现应用跨设备无缝迁移

## 🔄 流转概述

### 什么是流转

应用从一个设备迁移到另一个设备，保持状态和数据的连续性。

```
流转场景
├─ 手机 → 平板（看视频换大屏）
├─ 平板 → 手机（外出继续使用）
├─ 手机 → PC（办公更高效）
└─ PC → 手机（随时随地）
```

## 🎯 UIAbility 迁移

### 配置迁移能力

```json5
// module.json5
{
  "abilities": [
    {
      "name": "MainAbility",
      "continuable": true  // 启用流转能力
    }
  ]
}
```

### 实现迁移接口

```typescript
import UIAbility from '@ohos.app.ability.UIAbility'
import AbilityConstant from '@ohos.app.ability.AbilityConstant'

export default class MainAbility extends UIAbility {
  // 保存状态（迁移前）
  onContinue(wantParam: Record<string, Object>): AbilityConstant.OnContinueResult {
    console.log('准备迁移')
    
    // 保存应用状态
    wantParam['currentPage'] = 'DetailPage'
    wantParam['scrollPosition'] = 120
    wantParam['videoProgress'] = 58.5
    wantParam['formData'] = JSON.stringify({
      username: 'Alice',
      content: '未完成的输入'
    })
    
    // 返回同意迁移
    return AbilityConstant.OnContinueResult.AGREE
  }
  
  // 恢复状态（迁移后）
  onCreate(want, launchParam) {
    if (launchParam.launchReason === AbilityConstant.LaunchReason.CONTINUATION) {
      console.log('从其他设备迁移而来')
      
      // 恢复状态
      const currentPage = want.parameters?.currentPage
      const scrollPosition = want.parameters?.scrollPosition
      const videoProgress = want.parameters?.videoProgress
      const formData = JSON.parse(want.parameters?.formData || '{}')
      
      // 应用状态
      AppStorage.SetOrCreate('currentPage', currentPage)
      AppStorage.SetOrCreate('scrollPosition', scrollPosition)
      AppStorage.SetOrCreate('videoProgress', videoProgress)
      AppStorage.SetOrCreate('formData', formData)
    }
  }
}
```

## 📦 数据迁移

### 迁移用户数据

```typescript
export default class VideoPlayerAbility extends UIAbility {
  private player: VideoPlayer
  
  onContinue(wantParam) {
    // 获取当前播放状态
    const currentTime = this.player.getCurrentTime()
    const duration = this.player.getDuration()
    const videoUrl = this.player.getVideoUrl()
    
    // 保存到迁移参数
    wantParam['videoUrl'] = videoUrl
    wantParam['currentTime'] = currentTime
    wantParam['duration'] = duration
    wantParam['isPlaying'] = this.player.isPlaying()
    
    return AbilityConstant.OnContinueResult.AGREE
  }
  
  onCreate(want, launchParam) {
    if (launchParam.launchReason === AbilityConstant.LaunchReason.CONTINUATION) {
      // 恢复播放器
      const videoUrl = want.parameters?.videoUrl
      const currentTime = want.parameters?.currentTime
      
      this.player.load(videoUrl)
      this.player.seekTo(currentTime)
      
      if (want.parameters?.isPlaying) {
        this.player.play()
      }
    }
  }
}
```

### 迁移大数据

```typescript
import distributedKVStore from '@ohos.data.distributedKVStore'

class DataMigrationHelper {
  private kvStore: distributedKVStore.SingleKVStore
  
  async init() {
    const kvManager = distributedKVStore.createKVManager({
      context: context,
      bundleName: 'com.example.app'
    })
    
    this.kvStore = await kvManager.getKVStore('migrationStore', {
      createIfMissing: true,
      autoSync: true
    })
  }
  
  // 保存数据到分布式存储
  async saveForMigration(data: any) {
    const key = 'migration_data'
    await this.kvStore.put(key, JSON.stringify(data))
  }
  
  // 从分布式存储读取
  async loadFromMigration(): Promise<any> {
    const key = 'migration_data'
    const value = await this.kvStore.get(key)
    return JSON.parse(value)
  }
}

// 使用
export default class DocumentEditorAbility extends UIAbility {
  private migrationHelper: DataMigrationHelper
  
  async onContinue(wantParam) {
    // 保存大量数据到分布式存储
    await this.migrationHelper.saveForMigration({
      document: this.currentDocument,
      editHistory: this.editHistory,
      cursorPosition: this.cursorPosition
    })
    
    // 只传递数据标识
    wantParam['dataKey'] = 'migration_data'
    
    return AbilityConstant.OnContinueResult.AGREE
  }
  
  async onCreate(want, launchParam) {
    if (launchParam.launchReason === AbilityConstant.LaunchReason.CONTINUATION) {
      // 从分布式存储恢复数据
      const data = await this.migrationHelper.loadFromMigration()
      
      this.currentDocument = data.document
      this.editHistory = data.editHistory
      this.cursorPosition = data.cursorPosition
    }
  }
}
```

## 🎮 实战案例：视频播放器流转

```typescript
@Entry
@Component
struct VideoPlayer {
  @StorageLink('videoUrl') videoUrl: string = ''
  @StorageLink('currentTime') currentTime: number = 0
  @StorageLink('isPlaying') isPlaying: boolean = false
  
  private videoController: VideoController = new VideoController()
  
  aboutToAppear() {
    // 如果是迁移过来的，恢复播放状态
    if (this.videoUrl && this.currentTime > 0) {
      this.videoController.setCurrentTime(this.currentTime)
      
      if (this.isPlaying) {
        this.videoController.start()
      }
    }
  }
  
  build() {
    Column() {
      Video({
        src: this.videoUrl,
        controller: this.videoController
      })
      .width('100%')
      .height(300)
      .onUpdate((event) => {
        // 实时更新播放进度
        this.currentTime = event.time
      })
      
      Row({ space: 20 }) {
        Button(this.isPlaying ? '暂停' : '播放')
          .onClick(() => {
            if (this.isPlaying) {
              this.videoController.pause()
            } else {
              this.videoController.start()
            }
            this.isPlaying = !this.isPlaying
          })
        
        Text(`${this.formatTime(this.currentTime)}`)
      }
      .margin({ top: 20 })
    }
    .padding(20)
  }
  
  formatTime(seconds: number): string {
    const min = Math.floor(seconds / 60)
    const sec = Math.floor(seconds % 60)
    return `${min}:${sec.toString().padStart(2, '0')}`
  }
}

// Ability
export default class VideoPlayerAbility extends UIAbility {
  onContinue(wantParam) {
    // 获取当前状态
    const videoUrl = AppStorage.Get('videoUrl')
    const currentTime = AppStorage.Get('currentTime')
    const isPlaying = AppStorage.Get('isPlaying')
    
    // 保存到迁移参数
    wantParam['videoUrl'] = videoUrl
    wantParam['currentTime'] = currentTime
    wantParam['isPlaying'] = isPlaying
    
    return AbilityConstant.OnContinueResult.AGREE
  }
  
  onCreate(want, launchParam) {
    if (launchParam.launchReason === AbilityConstant.LaunchReason.CONTINUATION) {
      // 恢复状态
      AppStorage.SetOrCreate('videoUrl', want.parameters?.videoUrl)
      AppStorage.SetOrCreate('currentTime', want.parameters?.currentTime)
      AppStorage.SetOrCreate('isPlaying', want.parameters?.isPlaying)
    }
    
    super.onCreate(want, launchParam)
  }
}
```

## 💡 最佳实践

### 1. 只迁移必要数据

```typescript
// ✅ 只保存关键状态
wantParam['videoId'] = this.videoId
wantParam['progress'] = this.progress

// ❌ 避免保存大数据
// wantParam['videoData'] = this.videoBuffer  // 太大
```

### 2. 使用分布式存储

```typescript
// 大数据放分布式存储
await kvStore.put('largeData', data)

// 只传递引用
wantParam['dataKey'] = 'largeData'
```

### 3. 处理迁移失败

```typescript
onContinue(wantParam) {
  try {
    // 保存状态
    wantParam['data'] = this.getData()
    return AbilityConstant.OnContinueResult.AGREE
  } catch (err) {
    console.error('迁移准备失败:', err)
    return AbilityConstant.OnContinueResult.REJECT
  }
}
```

## 📚 参考资源

- [跨端迁移](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/hop-cross-device-migration-0000001821000453-V5)

---

**下一节** → [分布式组件](03-分布式组件.md)
