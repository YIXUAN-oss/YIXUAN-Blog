---
title: 装饰器
---

# 装饰器

> 掌握Python装饰器的使用，编写更优雅的代码

## 📚 学习目标

- 理解装饰器的概念和原理
- 掌握函数装饰器的使用
- 学会创建带参数的装饰器
- 掌握类装饰器

## 1. 装饰器基础

### 1.1 什么是装饰器

```python
# 装饰器：在不修改原函数代码的情况下，为函数添加新功能
def timer(func):
    """计时装饰器"""
    import time
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f'{func.__name__} 耗时: {end - start:.4f}秒')
        return result
    return wrapper

# 使用装饰器
@timer
def slow_function():
    import time
    time.sleep(1)
    print('函数执行完成')

slow_function()
```

### 1.2 装饰器原理

```python
# @timer 等价于
def slow_function():
    pass

slow_function = timer(slow_function)
```

## 2. 常用装饰器模式

### 2.1 日志装饰器

```python
def logger(func):
    """日志装饰器"""
    def wrapper(*args, **kwargs):
        print(f'调用函数: {func.__name__}')
        print(f'参数: args={args}, kwargs={kwargs}')
        result = func(*args, **kwargs)
        print(f'返回值: {result}')
        return result
    return wrapper

@logger
def add(a, b):
    return a + b

add(3, 5)
```

### 2.2 缓存装饰器

```python
def cache(func):
    """简单的缓存装饰器"""
    cached_results = {}
    
    def wrapper(*args):
        if args in cached_results:
            print(f'从缓存获取: {args}')
            return cached_results[args]
        
        result = func(*args)
        cached_results[args] = result
        return result
    
    return wrapper

@cache
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(10))
```

### 2.3 验证装饰器

```python
def validate_input(func):
    """输入验证装饰器"""
    def wrapper(x, y):
        if not isinstance(x, (int, float)):
            raise TypeError('x 必须是数字')
        if not isinstance(y, (int, float)):
            raise TypeError('y 必须是数字')
        if y == 0:
            raise ValueError('除数不能为零')
        return func(x, y)
    return wrapper

@validate_input
def divide(x, y):
    return x / y

print(divide(10, 2))  # 5.0
```

## 3. 带参数的装饰器

### 3.1 基本语法

```python
def repeat(times):
    """重复执行装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f'Hello, {name}!')

greet('Python')
```

### 3.2 权限检查装饰器

```python
def require_auth(role):
    """权限检查装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            user_role = kwargs.get('role', 'guest')
            if user_role != role:
                raise PermissionError(f'需要 {role} 权限')
            return func(*args, **kwargs)
        return wrapper
    return decorator

@require_auth('admin')
def delete_user(user_id, role='guest'):
    print(f'删除用户: {user_id}')

delete_user(123, role='admin')  # 成功
```

## 4. 类装饰器

### 4.1 使用类作为装饰器

```python
class Counter:
    """计数装饰器"""
    
    def __init__(self, func):
        self.func = func
        self.count = 0
    
    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f'调用次数: {self.count}')
        return self.func(*args, **kwargs)

@Counter
def say_hello():
    print('Hello!')

say_hello()  # 调用次数: 1
say_hello()  # 调用次数: 2
```

### 4.2 装饰类

```python
def singleton(cls):
    """单例装饰器"""
    instances = {}
    
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    
    return get_instance

@singleton
class Database:
    def __init__(self):
        print('初始化数据库连接')

db1 = Database()  # 初始化数据库连接
db2 = Database()  # 不会再次初始化
print(db1 is db2)  # True
```

## 5. functools 模块

### 5.1 wraps 装饰器

```python
from functools import wraps

def my_decorator(func):
    @wraps(func)  # 保留原函数的元信息
    def wrapper(*args, **kwargs):
        print('装饰器执行')
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def example():
    """这是一个示例函数"""
    pass

print(example.__name__)  # example
print(example.__doc__)   # 这是一个示例函数
```

### 5.2 lru_cache 缓存

```python
from functools import lru_cache

@lru_cache(maxsize=128)
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(100))  # 快速计算
print(fibonacci.cache_info())  # 查看缓存信息
```

## 6. 多个装饰器

```python
def decorator1(func):
    print('装饰器1')
    def wrapper(*args, **kwargs):
        print('执行装饰器1')
        return func(*args, **kwargs)
    return wrapper

def decorator2(func):
    print('装饰器2')
    def wrapper(*args, **kwargs):
        print('执行装饰器2')
        return func(*args, **kwargs)
    return wrapper

@decorator1
@decorator2
def my_function():
    print('原始函数')

my_function()
# 输出顺序：装饰器2 -> 装饰器1 -> 执行装饰器1 -> 执行装饰器2 -> 原始函数
```

## 7. 实战案例

### 案例1：性能监控

```python
import time
from functools import wraps

def performance_monitor(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        start_memory = get_memory_usage()
        
        result = func(*args, **kwargs)
        
        end_time = time.time()
        end_memory = get_memory_usage()
        
        print(f'函数: {func.__name__}')
        print(f'耗时: {end_time - start_time:.4f}秒')
        print(f'内存: {end_memory - start_memory:.2f}MB')
        
        return result
    return wrapper
```

### 案例2：重试机制

```python
import time
from functools import wraps

def retry(max_tries=3, delay=1):
    """重试装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_tries):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_tries - 1:
                        raise
                    print(f'第 {attempt + 1} 次尝试失败，{delay}秒后重试...')
                    time.sleep(delay)
        return wrapper
    return decorator

@retry(max_tries=3, delay=2)
def unstable_function():
    import random
    if random.random() < 0.7:
        raise Exception('随机失败')
    return '成功'
```

## 📝 练习题

1. 创建一个速率限制装饰器
2. 实现一个参数类型检查装饰器
3. 编写一个异常处理装饰器

---

**下一节：** [上下文管理器](04-上下文管理器.md)
