---
title: 上下文管理器
---

# 上下文管理器

> 掌握Python上下文管理器，优雅地管理资源

## 📚 学习目标

- 理解上下文管理器的概念
- 掌握 with 语句的使用
- 学会创建自定义上下文管理器
- 掌握 contextlib 模块

## 1. 上下文管理器基础

### 1.1 with 语句

```python
# 不使用 with
file = open('test.txt', 'r')
try:
    content = file.read()
finally:
    file.close()

# 使用 with（推荐）
with open('test.txt', 'r', encoding='utf-8') as file:
    content = file.read()
# 自动关闭文件
```

### 1.2 工作原理

```python
# with 语句会自动调用：
# 1. __enter__() - 进入时
# 2. __exit__()  - 退出时

class MyContext:
    def __enter__(self):
        print('进入上下文')
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print('退出上下文')
        return False  # 不抑制异常

with MyContext() as ctx:
    print('执行代码')
```

## 2. 自定义上下文管理器

### 2.1 类方式实现

```python
class DatabaseConnection:
    """数据库连接管理器"""
    
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.connection = None
    
    def __enter__(self):
        print(f'连接数据库: {self.host}:{self.port}')
        self.connection = self._connect()
        return self.connection
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.connection:
            self.connection.close()
            print('关闭数据库连接')
        
        if exc_type is not None:
            print(f'发生异常: {exc_type.__name__}: {exc_val}')
        
        return False  # 不抑制异常
    
    def _connect(self):
        # 模拟连接
        return {'connected': True}

# 使用
with DatabaseConnection('localhost', 3306) as conn:
    print(f'使用连接: {conn}')
```

### 2.2 文件写入管理器

```python
class FileWriter:
    """文件写入管理器"""
    
    def __init__(self, filename):
        self.filename = filename
        self.file = None
    
    def __enter__(self):
        self.file = open(self.filename, 'w', encoding='utf-8')
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()
        return False

with FileWriter('output.txt') as f:
    f.write('Hello, World!')
```

## 3. contextlib 模块

### 3.1 contextmanager 装饰器

```python
from contextlib import contextmanager

@contextmanager
def file_manager(filename, mode):
    """文件管理器"""
    file = open(filename, mode, encoding='utf-8')
    try:
        yield file  # yield 前面是 __enter__
    finally:
        file.close()  # finally 是 __exit__

# 使用
with file_manager('test.txt', 'w') as f:
    f.write('使用 contextmanager')
```

### 3.2 数据库事务管理

```python
from contextlib import contextmanager

@contextmanager
def transaction(connection):
    """数据库事务管理器"""
    cursor = connection.cursor()
    try:
        yield cursor
        connection.commit()  # 提交事务
        print('事务提交成功')
    except Exception as e:
        connection.rollback()  # 回滚事务
        print(f'事务回滚: {e}')
        raise
    finally:
        cursor.close()

# 使用
with transaction(db_connection) as cursor:
    cursor.execute('INSERT INTO users VALUES (...)')
    cursor.execute('UPDATE accounts SET ...')
```

### 3.3 计时器

```python
from contextlib import contextmanager
import time

@contextmanager
def timer(name):
    """计时上下文管理器"""
    start = time.time()
    yield
    end = time.time()
    print(f'{name} 耗时: {end - start:.4f}秒')

# 使用
with timer('数据处理'):
    # 执行耗时操作
    sum([i**2 for i in range(1000000)])
```

## 4. 嵌套上下文管理器

### 4.1 多个 with 语句

```python
# 方式1：嵌套
with open('input.txt', 'r') as in_file:
    with open('output.txt', 'w') as out_file:
        out_file.write(in_file.read())

# 方式2：一行（Python 3.1+）
with open('input.txt', 'r') as in_file, \
     open('output.txt', 'w') as out_file:
    out_file.write(in_file.read())
```

### 4.2 ExitStack

```python
from contextlib import ExitStack

def process_files(filenames):
    """同时处理多个文件"""
    with ExitStack() as stack:
        files = [stack.enter_context(open(fname, 'r')) 
                 for fname in filenames]
        
        for f in files:
            print(f.read())

process_files(['file1.txt', 'file2.txt', 'file3.txt'])
```

## 5. 实战案例

### 案例1：临时目录

```python
import os
import tempfile
from contextlib import contextmanager

@contextmanager
def temporary_directory():
    """临时目录管理器"""
    temp_dir = tempfile.mkdtemp()
    print(f'创建临时目录: {temp_dir}')
    try:
        yield temp_dir
    finally:
        import shutil
        shutil.rmtree(temp_dir)
        print(f'删除临时目录: {temp_dir}')

# 使用
with temporary_directory() as temp_dir:
    # 在临时目录中工作
    file_path = os.path.join(temp_dir, 'temp.txt')
    with open(file_path, 'w') as f:
        f.write('临时数据')
```

### 案例2：状态切换

```python
from contextlib import contextmanager

@contextmanager
def change_dir(path):
    """临时切换目录"""
    old_dir = os.getcwd()
    os.chdir(path)
    try:
        yield
    finally:
        os.chdir(old_dir)

# 使用
print(f'当前目录: {os.getcwd()}')
with change_dir('/tmp'):
    print(f'临时目录: {os.getcwd()}')
print(f'恢复目录: {os.getcwd()}')
```

### 案例3：资源锁

```python
import threading
from contextlib import contextmanager

@contextmanager
def acquire_lock(lock):
    """锁管理器"""
    lock.acquire()
    print('获取锁')
    try:
        yield
    finally:
        lock.release()
        print('释放锁')

# 使用
lock = threading.Lock()
with acquire_lock(lock):
    # 执行需要同步的代码
    print('执行同步操作')
```

## 6. 异常处理

### 6.1 抑制异常

```python
class SuppressError:
    """抑制特定异常"""
    
    def __init__(self, *exceptions):
        self.exceptions = exceptions
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is not None:
            if issubclass(exc_type, self.exceptions):
                print(f'抑制异常: {exc_type.__name__}')
                return True  # 抑制异常
        return False

# 使用
with SuppressError(ValueError, TypeError):
    int('abc')  # 异常被抑制
    print('继续执行')
```

### 6.2 suppress 上下文管理器

```python
from contextlib import suppress

# 忽略特定异常
with suppress(FileNotFoundError):
    os.remove('nonexistent_file.txt')

# 等价于
try:
    os.remove('nonexistent_file.txt')
except FileNotFoundError:
    pass
```

## 7. 最佳实践

```python
# ✅ 使用 with 管理资源
with open('file.txt', 'r') as f:
    content = f.read()

# ✅ 使用 contextmanager 简化代码
from contextlib import contextmanager

@contextmanager
def managed_resource():
    resource = acquire_resource()
    try:
        yield resource
    finally:
        release_resource(resource)

# ✅ 异常处理
with open('file.txt', 'r') as f:
    try:
        content = f.read()
    except Exception as e:
        print(f'读取失败: {e}')
```

## 📝 练习题

1. 创建一个计时上下文管理器
2. 实现一个数据库连接池管理器
3. 编写一个临时环境变量管理器

---

**下一节：** [正则表达式](05-正则表达式.md)
