# 异常处理

## 一、异常的概念

### 1. 什么是异常？

异常是程序运行过程中发生的错误，会导致程序中断执行。

**常见异常类型：**
- `ZeroDivisionError`：除零错误
- `TypeError`：类型错误
- `ValueError`：值错误
- `IndexError`：索引错误
- `KeyError`：键错误
- `FileNotFoundError`：文件未找到错误
- `AttributeError`：属性错误

### 2. 异常示例

```python
# ZeroDivisionError
result = 10 / 0  # ZeroDivisionError: division by zero

# TypeError
result = "hello" + 5  # TypeError: can only concatenate str (not "int") to str

# ValueError
num = int("abc")  # ValueError: invalid literal for int()

# IndexError
my_list = [1, 2, 3]
print(my_list[10])  # IndexError: list index out of range

# KeyError
my_dict = {"name": "张三"}
print(my_dict["age"])  # KeyError: 'age'
```

---

## 二、异常处理

### 1. try-except基本语法

```python
try:
    # 可能发生异常的代码
    可能出错的代码
except 异常类型:
    # 异常处理代码
    处理异常的代码
```

### 2. 捕获单个异常

```python
try:
    num = int(input("请输入一个数字："))
    result = 10 / num
    print(f"结果是：{result}")
except ZeroDivisionError:
    print("错误：不能除以0")
```

### 3. 捕获多个异常

```python
try:
    num = int(input("请输入一个数字："))
    result = 10 / num
    print(f"结果是：{result}")
except ZeroDivisionError:
    print("错误：不能除以0")
except ValueError:
    print("错误：请输入有效的数字")
```

### 4. 捕获多个异常（简化写法）

```python
try:
    num = int(input("请输入一个数字："))
    result = 10 / num
    print(f"结果是：{result}")
except (ZeroDivisionError, ValueError) as e:
    print(f"发生错误：{e}")
```

### 5. 捕获所有异常

```python
try:
    # 可能出错的代码
    num = int(input("请输入一个数字："))
    result = 10 / num
except Exception as e:
    print(f"发生错误：{e}")
```

**注意：** 不建议捕获所有异常，应该明确指定要捕获的异常类型。

---

## 三、try-except-else-finally

### 1. else子句

如果没有发生异常，执行else子句。

```python
try:
    num = int(input("请输入一个数字："))
    result = 10 / num
except ZeroDivisionError:
    print("错误：不能除以0")
except ValueError:
    print("错误：请输入有效的数字")
else:
    print(f"结果是：{result}")
    print("计算成功！")
```

### 2. finally子句

无论是否发生异常，都会执行finally子句。

```python
try:
    f = open("test.txt", "r")
    content = f.read()
    print(content)
except FileNotFoundError:
    print("文件不存在")
finally:
    print("清理资源")
    # f.close()  # 确保文件被关闭
```

### 3. 完整结构

```python
try:
    # 可能出错的代码
    num = int(input("请输入一个数字："))
    result = 10 / num
except ZeroDivisionError:
    print("错误：不能除以0")
except ValueError:
    print("错误：请输入有效的数字")
else:
    print(f"结果是：{result}")
finally:
    print("程序执行完毕")
```

---

## 四、抛出异常

### 1. raise语句

使用`raise`语句主动抛出异常。

```python
def divide(x, y):
    if y == 0:
        raise ZeroDivisionError("除数不能为0")
    return x / y

try:
    result = divide(10, 0)
except ZeroDivisionError as e:
    print(f"错误：{e}")
```

### 2. 重新抛出异常

```python
try:
    num = int(input("请输入一个数字："))
    result = 10 / num
except ZeroDivisionError:
    print("捕获到除零错误")
    raise  # 重新抛出异常
```

---

## 五、自定义异常

### 1. 创建自定义异常类

自定义异常类应该继承自`Exception`类。

```python
class AgeError(Exception):
    """年龄错误异常"""
    
    def __init__(self, age, message="年龄必须在0-150之间"):
        self.age = age
        self.message = message
        super().__init__(self.message)
    
    def __str__(self):
        return f"{self.message}，您输入的年龄是：{self.age}"

# 使用自定义异常
def set_age(age):
    if age < 0 or age > 150:
        raise AgeError(age)
    print(f"年龄设置成功：{age}")

try:
    set_age(200)
except AgeError as e:
    print(f"错误：{e}")
```

### 2. 自定义异常的应用

```python
class InsufficientFundsError(Exception):
    """余额不足异常"""
    
    def __init__(self, balance, amount):
        self.balance = balance
        self.amount = amount
        super().__init__(f"余额不足！当前余额：{balance}，需要：{amount}")

class BankAccount:
    def __init__(self, balance):
        self.balance = balance
    
    def withdraw(self, amount):
        """取款"""
        if amount > self.balance:
            raise InsufficientFundsError(self.balance, amount)
        self.balance -= amount
        print(f"取款成功！当前余额：{self.balance}")

# 测试
account = BankAccount(1000)

try:
    account.withdraw(500)   # 成功
    account.withdraw(800)   # 失败
except InsufficientFundsError as e:
    print(f"错误：{e}")
```

---

## 六、异常链

### 1. 异常的上下文

使用`from`关键字保留原始异常信息。

```python
def process_data(data):
    try:
        result = int(data)
        return result
    except ValueError as e:
        raise TypeError("数据类型错误") from e

try:
    process_data("abc")
except TypeError as e:
    print(f"错误：{e}")
    print(f"原因：{e.__cause__}")
```

### 2. 异常的传播

```python
def func1():
    return 10 / 0

def func2():
    func1()

def func3():
    func2()

try:
    func3()
except ZeroDivisionError:
    print("捕获到除零错误")
    import traceback
    traceback.print_exc()  # 打印完整的异常堆栈
```

---

## 七、上下文管理器

### 1. with语句

`with`语句可以自动管理资源，确保资源被正确释放。

```python
# 传统方式
try:
    f = open("test.txt", "r")
    content = f.read()
    print(content)
finally:
    f.close()

# 使用with语句（推荐）
with open("test.txt", "r") as f:
    content = f.read()
    print(content)
# 文件会自动关闭
```

### 2. 自定义上下文管理器

```python
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        """进入with语句时调用"""
        print(f"打开文件：{self.filename}")
        self.file = open(self.filename, self.mode)
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出with语句时调用"""
        print(f"关闭文件：{self.filename}")
        if self.file:
            self.file.close()
        
        # 如果返回True，异常会被抑制
        # 如果返回False或None，异常会继续传播
        if exc_type is not None:
            print(f"发生异常：{exc_type.__name__}: {exc_val}")
        return False

# 使用
with FileManager("test.txt", "w") as f:
    f.write("Hello, Python!")
```

### 3. contextlib模块

```python
from contextlib import contextmanager

@contextmanager
def file_manager(filename, mode):
    """上下文管理器装饰器"""
    try:
        f = open(filename, mode)
        yield f
    finally:
        f.close()

# 使用
with file_manager("test.txt", "w") as f:
    f.write("Hello, Python!")
```

---

## 八、断言（assert）

### 1. 断言的使用

断言用于调试，检查条件是否为真。

```python
def divide(x, y):
    assert y != 0, "除数不能为0"
    return x / y

# 测试
print(divide(10, 2))  # 5.0
# print(divide(10, 0))  # AssertionError: 除数不能为0
```

### 2. 断言 vs 异常处理

- **断言**：用于调试，检查不应该发生的情况
- **异常处理**：用于处理可能发生的错误

```python
# 使用断言（开发阶段）
def calculate_average(numbers):
    assert len(numbers) > 0, "列表不能为空"
    return sum(numbers) / len(numbers)

# 使用异常处理（生产环境）
def calculate_average_safe(numbers):
    if len(numbers) == 0:
        raise ValueError("列表不能为空")
    return sum(numbers) / len(numbers)
```

---

## 九、实战案例

### 案例1：安全的文件读取

```python
def read_file_safe(filename):
    """安全地读取文件"""
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            return f.read()
    except FileNotFoundError:
        print(f"错误：文件 {filename} 不存在")
        return None
    except PermissionError:
        print(f"错误：没有权限读取文件 {filename}")
        return None
    except Exception as e:
        print(f"错误：读取文件时发生未知错误：{e}")
        return None

# 测试
content = read_file_safe("test.txt")
if content:
    print(content)
```

### 案例2：用户输入验证

```python
def get_positive_integer(prompt):
    """获取正整数输入"""
    while True:
        try:
            value = int(input(prompt))
            if value <= 0:
                raise ValueError("必须输入正整数")
            return value
        except ValueError as e:
            print(f"输入错误：{e}，请重新输入")

# 使用
age = get_positive_integer("请输入年龄：")
print(f"您的年龄是：{age}")
```

### 案例3：数据验证器

```python
class ValidationError(Exception):
    """验证错误"""
    pass

class Validator:
    """数据验证器"""
    
    @staticmethod
    def validate_email(email):
        """验证邮箱"""
        if '@' not in email:
            raise ValidationError("邮箱格式错误：缺少@符号")
        if '.' not in email.split('@')[1]:
            raise ValidationError("邮箱格式错误：域名格式不正确")
        return True
    
    @staticmethod
    def validate_phone(phone):
        """验证手机号"""
        if not phone.isdigit():
            raise ValidationError("手机号格式错误：只能包含数字")
        if len(phone) != 11:
            raise ValidationError("手机号格式错误：必须是11位")
        return True
    
    @staticmethod
    def validate_age(age):
        """验证年龄"""
        if not isinstance(age, int):
            raise ValidationError("年龄必须是整数")
        if age < 0 or age > 150:
            raise ValidationError("年龄必须在0-150之间")
        return True

# 使用
try:
    Validator.validate_email("test@example.com")
    print("邮箱验证通过")
    
    Validator.validate_phone("13800138000")
    print("手机号验证通过")
    
    Validator.validate_age(25)
    print("年龄验证通过")
    
    # 测试错误情况
    Validator.validate_email("invalid-email")
except ValidationError as e:
    print(f"验证失败：{e}")
```

### 案例4：重试机制

```python
import time

class MaxRetryError(Exception):
    """最大重试次数错误"""
    pass

def retry(max_attempts=3, delay=1):
    """重试装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            for attempt in range(1, max_attempts + 1):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    print(f"第{attempt}次尝试失败：{e}")
                    if attempt == max_attempts:
                        raise MaxRetryError(f"达到最大重试次数{max_attempts}")
                    time.sleep(delay)
        return wrapper
    return decorator

@retry(max_attempts=3, delay=2)
def unstable_function():
    """不稳定的函数（模拟）"""
    import random
    if random.random() < 0.7:
        raise Exception("随机错误")
    return "成功"

# 测试
try:
    result = unstable_function()
    print(result)
except MaxRetryError as e:
    print(f"错误：{e}")
```

---

## 十、异常处理最佳实践

### 1. 明确捕获异常

```python
# ❌ 不推荐：捕获所有异常
try:
    result = some_function()
except:
    pass

# ✅ 推荐：明确指定异常类型
try:
    result = some_function()
except ValueError as e:
    print(f"值错误：{e}")
except TypeError as e:
    print(f"类型错误：{e}")
```

### 2. 不要忽略异常

```python
# ❌ 不推荐：忽略异常
try:
    result = some_function()
except Exception:
    pass

# ✅ 推荐：记录异常信息
try:
    result = some_function()
except Exception as e:
    print(f"发生错误：{e}")
    # 或者使用日志记录
    # logging.error(f"发生错误：{e}")
```

### 3. 异常信息要有意义

```python
# ❌ 不推荐：信息不明确
if age < 0:
    raise ValueError("错误")

# ✅ 推荐：提供详细信息
if age < 0:
    raise ValueError(f"年龄不能为负数，您输入的是：{age}")
```

### 4. 使用finally清理资源

```python
# ✅ 推荐：确保资源被释放
f = None
try:
    f = open("file.txt", "r")
    content = f.read()
except FileNotFoundError:
    print("文件不存在")
finally:
    if f:
        f.close()

# 更好的方式：使用with语句
with open("file.txt", "r") as f:
    content = f.read()
```

---

## 十一、知识点总结

### ✅ 核心要点

1. **异常处理**：try-except-else-finally结构
2. **异常类型**：常见异常及其含义
3. **抛出异常**：raise语句
4. **自定义异常**：继承Exception类
5. **上下文管理器**：with语句和__enter__/__exit__
6. **断言**：assert语句用于调试

### 📝 面试重点

- try-except-else-finally的执行顺序
- 如何自定义异常
- with语句的原理
- 异常链的概念
- 断言和异常处理的区别
- 异常处理的最佳实践

---

## 十二、常见异常类型总结

| 异常类型 | 说明 | 示例 |
|---------|------|------|
| Exception | 所有异常的基类 | - |
| AttributeError | 属性错误 | obj.nonexistent |
| IOError | 输入输出错误 | 文件操作失败 |
| IndexError | 索引错误 | list[100] |
| KeyError | 键错误 | dict['nonexistent'] |
| NameError | 名称错误 | 使用未定义的变量 |
| TypeError | 类型错误 | "str" + 5 |
| ValueError | 值错误 | int("abc") |
| ZeroDivisionError | 除零错误 | 10 / 0 |
| FileNotFoundError | 文件未找到 | open('nonexistent.txt') |
| ImportError | 导入错误 | import nonexistent |
| RuntimeError | 运行时错误 | 一般运行时错误 |

---

**上一章：** [模块与包](05-模块与包.md)  
**下一章：** [第03章-进阶编程](../第03章-进阶编程/01-文件操作.md) →
