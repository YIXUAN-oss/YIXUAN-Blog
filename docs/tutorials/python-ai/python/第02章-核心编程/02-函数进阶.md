# 函数进阶

## 一、函数作为参数传递

### 1. 基本概念

在Python中，函数是一等公民（First-Class Object），可以作为参数传递给其他函数。

```python
def test_func(compute):
    result = compute(1, 2)
    print(result)

def add(x, y):
    return x + y

def multiply(x, y):
    return x * y

# 传递不同的函数
test_func(add)       # 3
test_func(multiply)  # 2
```

**应用场景：** 传递计算逻辑，而非数据。

---

## 二、Lambda匿名函数

### 1. Lambda语法

```python
lambda 参数列表: 表达式
```

- `lambda`是关键字，表示定义匿名函数
- 参数列表：形式参数，可以有多个，用逗号分隔
- 表达式：函数体，只能写一行代码，无法写多行

### 2. 基本使用

```python
# 普通函数
def add(x, y):
    return x + y

# Lambda函数
add_lambda = lambda x, y: x + y

print(add(1, 2))        # 3
print(add_lambda(1, 2)) # 3
```

### 3. Lambda作为参数

```python
def test_func(compute):
    result = compute(1, 2)
    print(result)

# 使用lambda
test_func(lambda x, y: x + y)  # 3
test_func(lambda x, y: x * y)  # 2
test_func(lambda x, y: x ** y) # 1
```

### 4. Lambda的应用

#### 配合sorted()排序

```python
# 按字符串长度排序
words = ['python', 'java', 'c', 'javascript']
sorted_words = sorted(words, key=lambda x: len(x))
print(sorted_words)  # ['c', 'java', 'python', 'javascript']

# 按字典的值排序
students = [
    {'name': '张三', 'score': 85},
    {'name': '李四', 'score': 92},
    {'name': '王五', 'score': 78}
]
sorted_students = sorted(students, key=lambda x: x['score'], reverse=True)
for student in sorted_students:
    print(f"{student['name']}: {student['score']}")
```

#### 配合filter()过滤

```python
# 过滤偶数
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)  # [2, 4, 6, 8, 10]
```

#### 配合map()映射

```python
# 计算平方
numbers = [1, 2, 3, 4, 5]
squares = list(map(lambda x: x ** 2, numbers))
print(squares)  # [1, 4, 9, 16, 25]
```

---

## 三、递归函数

### 1. 什么是递归？

递归是指函数自己调用自己的编程技巧。

**递归的两个要素：**
1. 递归出口（终止条件）
2. 递归调用（自己调用自己）

### 2. 递归示例

#### 示例1：计算阶乘

```python
def factorial(n):
    """
    计算n的阶乘
    n! = n * (n-1) * (n-2) * ... * 1
    """
    # 递归出口
    if n == 1:
        return 1
    
    # 递归调用
    return n * factorial(n - 1)

print(factorial(5))  # 120 (5*4*3*2*1)
```

#### 示例2：斐波那契数列

```python
def fibonacci(n):
    """
    计算斐波那契数列第n项
    F(n) = F(n-1) + F(n-2)
    F(1) = F(2) = 1
    """
    # 递归出口
    if n == 1 or n == 2:
        return 1
    
    # 递归调用
    return fibonacci(n - 1) + fibonacci(n - 2)

# 输出前10项
for i in range(1, 11):
    print(fibonacci(i), end=' ')
# 输出：1 1 2 3 5 8 13 21 34 55
```

### 3. 递归的优缺点

**优点：**
- 代码简洁，易于理解
- 适合处理树形结构、分治问题

**缺点：**
- 可能导致栈溢出
- 性能较差（重复计算）

**优化方案：** 使用记忆化（缓存）或改用迭代

```python
# 使用缓存优化斐波那契
def fibonacci_cache(n, cache={}):
    if n in cache:
        return cache[n]
    
    if n == 1 or n == 2:
        return 1
    
    cache[n] = fibonacci_cache(n - 1, cache) + fibonacci_cache(n - 2, cache)
    return cache[n]

print(fibonacci_cache(100))  # 很快得出结果
```

---

## 四、闭包（Closure）

### 1. 什么是闭包？

闭包是指内层函数引用了外层函数的变量，即使外层函数已经执行完毕，内层函数仍然可以访问这些变量。

### 2. 闭包的定义

```python
def outer(x):
    def inner(y):
        return x + y
    return inner

# 创建闭包
add_5 = outer(5)
add_10 = outer(10)

print(add_5(3))   # 8  (5 + 3)
print(add_10(3))  # 13 (10 + 3)
```

### 3. 闭包的应用

#### 示例1：计数器

```python
def counter():
    count = 0
    
    def increment():
        nonlocal count  # 声明使用外层变量
        count += 1
        return count
    
    return increment

# 创建两个独立的计数器
counter1 = counter()
counter2 = counter()

print(counter1())  # 1
print(counter1())  # 2
print(counter2())  # 1
print(counter1())  # 3
```

#### 示例2：函数工厂

```python
def make_multiplier(n):
    """创建一个乘法函数"""
    def multiplier(x):
        return x * n
    return multiplier

# 创建不同的乘法函数
times_2 = make_multiplier(2)
times_3 = make_multiplier(3)
times_5 = make_multiplier(5)

print(times_2(10))  # 20
print(times_3(10))  # 30
print(times_5(10))  # 50
```

---

## 五、装饰器（Decorator）

### 1. 什么是装饰器？

装饰器是一种特殊的函数，用于在不修改原函数代码的情况下，为函数添加额外的功能。

### 2. 装饰器的基本语法

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        # 在函数执行前做些什么
        print("函数执行前")
        result = func(*args, **kwargs)
        # 在函数执行后做些什么
        print("函数执行后")
        return result
    return wrapper

# 使用装饰器
@decorator
def say_hello():
    print("Hello!")

say_hello()
# 输出：
# 函数执行前
# Hello!
# 函数执行后
```

### 3. 装饰器的应用

#### 示例1：计时装饰器

```python
import time

def timer(func):
    """计算函数执行时间"""
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"函数 {func.__name__} 执行时间：{end_time - start_time:.4f}秒")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(2)
    print("函数执行完毕")

slow_function()
# 输出：
# 函数执行完毕
# 函数 slow_function 执行时间：2.0001秒
```

#### 示例2：日志装饰器

```python
def log(func):
    """记录函数调用日志"""
    def wrapper(*args, **kwargs):
        print(f"调用函数：{func.__name__}")
        print(f"参数：args={args}, kwargs={kwargs}")
        result = func(*args, **kwargs)
        print(f"返回值：{result}")
        return result
    return wrapper

@log
def add(x, y):
    return x + y

add(3, 5)
# 输出：
# 调用函数：add
# 参数：args=(3, 5), kwargs={}
# 返回值：8
```

#### 示例3：权限验证装饰器

```python
def require_auth(func):
    """权限验证装饰器"""
    def wrapper(*args, **kwargs):
        # 假设从某处获取用户登录状态
        is_logged_in = True
        
        if is_logged_in:
            return func(*args, **kwargs)
        else:
            print("请先登录！")
            return None
    return wrapper

@require_auth
def view_profile():
    print("查看个人资料")

view_profile()  # 查看个人资料
```

### 4. 带参数的装饰器

```python
def repeat(times):
    """重复执行装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def say_hello():
    print("Hello!")

say_hello()
# 输出：
# Hello!
# Hello!
# Hello!
```

### 5. 多个装饰器叠加

```python
def decorator1(func):
    def wrapper(*args, **kwargs):
        print("装饰器1")
        return func(*args, **kwargs)
    return wrapper

def decorator2(func):
    def wrapper(*args, **kwargs):
        print("装饰器2")
        return func(*args, **kwargs)
    return wrapper

@decorator1
@decorator2
def test():
    print("原函数")

test()
# 输出：
# 装饰器1
# 装饰器2
# 原函数
```

---

## 六、内置高阶函数

### 1. map()函数

对序列中的每个元素应用函数。

```python
# 计算平方
numbers = [1, 2, 3, 4, 5]
squares = list(map(lambda x: x ** 2, numbers))
print(squares)  # [1, 4, 9, 16, 25]

# 字符串转大写
words = ['hello', 'world', 'python']
upper_words = list(map(str.upper, words))
print(upper_words)  # ['HELLO', 'WORLD', 'PYTHON']
```

### 2. filter()函数

过滤序列中的元素。

```python
# 过滤偶数
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)  # [2, 4, 6, 8, 10]

# 过滤空字符串
words = ['hello', '', 'world', '', 'python']
non_empty = list(filter(None, words))
print(non_empty)  # ['hello', 'world', 'python']
```

### 3. reduce()函数

对序列中的元素进行累积操作。

```python
from functools import reduce

# 计算累加和
numbers = [1, 2, 3, 4, 5]
total = reduce(lambda x, y: x + y, numbers)
print(total)  # 15

# 计算累乘积
product = reduce(lambda x, y: x * y, numbers)
print(product)  # 120
```

---

## 七、实战练习

### 练习1：实现缓存装饰器

```python
def cache(func):
    """缓存装饰器"""
    cached_results = {}
    
    def wrapper(*args):
        if args in cached_results:
            print(f"从缓存中获取结果：{args}")
            return cached_results[args]
        
        result = func(*args)
        cached_results[args] = result
        return result
    
    return wrapper

@cache
def fibonacci(n):
    if n <= 2:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(10))  # 55
print(fibonacci(10))  # 从缓存中获取
```

### 练习2：实现重试装饰器

```python
import time

def retry(max_attempts=3, delay=1):
    """重试装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    print(f"第{attempt + 1}次尝试失败：{e}")
                    if attempt < max_attempts - 1:
                        time.sleep(delay)
                    else:
                        print("达到最大重试次数")
                        raise
        return wrapper
    return decorator

@retry(max_attempts=3, delay=2)
def unstable_function():
    import random
    if random.random() < 0.7:
        raise Exception("随机错误")
    return "成功"

# unstable_function()
```

---

## 八、知识点总结

### ✅ 核心要点

1. **Lambda函数**：匿名函数，适合简单的一行表达式
2. **递归**：函数调用自己，需要有递归出口
3. **闭包**：内层函数引用外层函数的变量
4. **装饰器**：在不修改原函数的情况下添加功能
5. **高阶函数**：map、filter、reduce

### 📝 面试重点

- Lambda函数的使用场景
- 递归的优缺点及优化方法
- 闭包的概念和应用
- 装饰器的原理和实现
- nonlocal关键字的作用

---

**上一章：** [函数基础](01-函数基础.md)  
**下一章：** [面向对象初级](03-面向对象初级.md) →
