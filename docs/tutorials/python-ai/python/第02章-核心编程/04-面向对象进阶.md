# 面向对象进阶

## 一、继承（Inheritance）

### 1. 什么是继承？

继承是面向对象编程的重要特性，允许一个类（子类）继承另一个类（父类）的属性和方法。

**优点：**
- 代码复用
- 建立类之间的层次关系
- 提高代码的可维护性

### 2. 单继承

```python
class Animal:
    """动物类（父类）"""
    
    def __init__(self, name):
        self.name = name
    
    def eat(self):
        print(f"{self.name}正在吃东西")
    
    def sleep(self):
        print(f"{self.name}正在睡觉")

class Dog(Animal):
    """狗类（子类）"""
    
    def bark(self):
        print(f"{self.name}正在汪汪叫")

class Cat(Animal):
    """猫类（子类）"""
    
    def meow(self):
        print(f"{self.name}正在喵喵叫")

# 创建对象
dog = Dog("旺财")
cat = Cat("咪咪")

# 调用继承的方法
dog.eat()   # 旺财正在吃东西
dog.sleep() # 旺财正在睡觉
dog.bark()  # 旺财正在汪汪叫

cat.eat()   # 咪咪正在吃东西
cat.meow()  # 咪咪正在喵喵叫
```

### 3. 方法重写（Override）

子类可以重写父类的方法。

```python
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        print(f"{self.name}发出声音")

class Dog(Animal):
    def speak(self):
        """重写父类方法"""
        print(f"{self.name}汪汪叫")

class Cat(Animal):
    def speak(self):
        """重写父类方法"""
        print(f"{self.name}喵喵叫")

# 测试
dog = Dog("旺财")
cat = Cat("咪咪")

dog.speak()  # 旺财汪汪叫
cat.speak()  # 咪咪喵喵叫
```

### 4. super()函数

使用`super()`调用父类的方法。

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def introduce(self):
        print(f"我是{self.name}，今年{self.age}岁")

class Student(Person):
    def __init__(self, name, age, student_id):
        # 调用父类的__init__方法
        super().__init__(name, age)
        self.student_id = student_id
    
    def introduce(self):
        # 调用父类的introduce方法
        super().introduce()
        print(f"我的学号是{self.student_id}")

# 测试
student = Student("张三", 18, "2024001")
student.introduce()
# 输出：
# 我是张三，今年18岁
# 我的学号是2024001
```

### 5. 多继承

Python支持多继承，一个类可以继承多个父类。

```python
class Father:
    def __init__(self):
        self.father_name = "父亲"
    
    def father_method(self):
        print("这是父亲的方法")

class Mother:
    def __init__(self):
        self.mother_name = "母亲"
    
    def mother_method(self):
        print("这是母亲的方法")

class Child(Father, Mother):
    def __init__(self):
        Father.__init__(self)
        Mother.__init__(self)
        self.child_name = "孩子"
    
    def child_method(self):
        print("这是孩子的方法")

# 测试
child = Child()
child.father_method()  # 这是父亲的方法
child.mother_method()  # 这是母亲的方法
child.child_method()   # 这是孩子的方法
```

### 6. 方法解析顺序（MRO）

多继承时，Python使用C3线性化算法确定方法解析顺序。

```python
class A:
    def method(self):
        print("A的方法")

class B(A):
    def method(self):
        print("B的方法")

class C(A):
    def method(self):
        print("C的方法")

class D(B, C):
    pass

# 查看MRO
print(D.__mro__)
# (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)

d = D()
d.method()  # B的方法（按照MRO顺序）
```

---

## 二、多态（Polymorphism）

### 1. 什么是多态？

多态是指同一个方法在不同对象上有不同的表现形式。

```python
class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "汪汪汪"

class Cat(Animal):
    def speak(self):
        return "喵喵喵"

class Duck(Animal):
    def speak(self):
        return "嘎嘎嘎"

# 多态的体现
def make_animal_speak(animal):
    """让动物发出声音"""
    print(animal.speak())

# 同一个函数，不同的对象，不同的结果
dog = Dog()
cat = Cat()
duck = Duck()

make_animal_speak(dog)   # 汪汪汪
make_animal_speak(cat)   # 喵喵喵
make_animal_speak(duck)  # 嘎嘎嘎
```

### 2. 鸭子类型（Duck Typing）

Python是动态类型语言，不需要显式继承，只要有相同的方法就可以。

```python
class Dog:
    def speak(self):
        return "汪汪汪"

class Robot:
    def speak(self):
        return "我是机器人"

# 不需要继承同一个父类
def make_speak(obj):
    print(obj.speak())

dog = Dog()
robot = Robot()

make_speak(dog)    # 汪汪汪
make_speak(robot)  # 我是机器人
```

---

## 三、封装（Encapsulation）

### 1. 私有属性和方法

使用双下划线`__`定义私有成员。

```python
class BankAccount:
    def __init__(self, owner, balance):
        self.owner = owner
        self.__balance = balance  # 私有属性
    
    def __check_balance(self):
        """私有方法"""
        return self.__balance > 0
    
    def deposit(self, amount):
        """存款"""
        if amount > 0:
            self.__balance += amount
            return True
        return False
    
    def withdraw(self, amount):
        """取款"""
        if self.__check_balance() and amount <= self.__balance:
            self.__balance -= amount
            return True
        return False
    
    def get_balance(self):
        """获取余额"""
        return self.__balance

# 测试
account = BankAccount("张三", 1000)
print(account.get_balance())  # 1000

# 无法直接访问私有属性
# print(account.__balance)  # AttributeError

account.deposit(500)
print(account.get_balance())  # 1500
```

### 2. 属性装饰器（@property）

使用`@property`将方法转换为属性。

```python
class Person:
    def __init__(self, name, age):
        self._name = name
        self._age = age
    
    @property
    def name(self):
        """获取姓名"""
        return self._name
    
    @name.setter
    def name(self, value):
        """设置姓名"""
        if isinstance(value, str):
            self._name = value
        else:
            raise ValueError("姓名必须是字符串")
    
    @property
    def age(self):
        """获取年龄"""
        return self._age
    
    @age.setter
    def age(self, value):
        """设置年龄"""
        if 0 < value < 150:
            self._age = value
        else:
            raise ValueError("年龄必须在0-150之间")

# 测试
person = Person("张三", 18)

# 像访问属性一样使用
print(person.name)  # 张三
print(person.age)   # 18

# 像设置属性一样使用
person.name = "李四"
person.age = 20

print(person.name)  # 李四
print(person.age)   # 20
```

---

## 四、常用魔术方法

### 1. 运算符重载

#### `__add__()` - 加法运算符

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        """重载+运算符"""
        return Point(self.x + other.x, self.y + other.y)
    
    def __str__(self):
        return f"Point({self.x}, {self.y})"

p1 = Point(1, 2)
p2 = Point(3, 4)
p3 = p1 + p2  # 调用__add__方法
print(p3)  # Point(4, 6)
```

#### 其他运算符

```python
class Number:
    def __init__(self, value):
        self.value = value
    
    def __add__(self, other):
        """加法：+"""
        return Number(self.value + other.value)
    
    def __sub__(self, other):
        """减法：-"""
        return Number(self.value - other.value)
    
    def __mul__(self, other):
        """乘法：*"""
        return Number(self.value * other.value)
    
    def __truediv__(self, other):
        """除法：/"""
        return Number(self.value / other.value)
    
    def __eq__(self, other):
        """等于：=="""
        return self.value == other.value
    
    def __lt__(self, other):
        """小于：<"""
        return self.value < other.value
    
    def __str__(self):
        return str(self.value)

# 测试
n1 = Number(10)
n2 = Number(5)

print(n1 + n2)  # 15
print(n1 - n2)  # 5
print(n1 * n2)  # 50
print(n1 / n2)  # 2.0
print(n1 == n2) # False
print(n1 > n2)  # True
```

### 2. 容器相关魔术方法

```python
class MyList:
    def __init__(self):
        self.items = []
    
    def __len__(self):
        """len()函数"""
        return len(self.items)
    
    def __getitem__(self, index):
        """索引访问：obj[index]"""
        return self.items[index]
    
    def __setitem__(self, index, value):
        """索引赋值：obj[index] = value"""
        self.items[index] = value
    
    def __delitem__(self, index):
        """删除元素：del obj[index]"""
        del self.items[index]
    
    def __contains__(self, item):
        """成员检查：item in obj"""
        return item in self.items
    
    def append(self, item):
        self.items.append(item)

# 测试
my_list = MyList()
my_list.append(1)
my_list.append(2)
my_list.append(3)

print(len(my_list))      # 3
print(my_list[0])        # 1
print(2 in my_list)      # True
my_list[0] = 10
print(my_list[0])        # 10
```

### 3. 上下文管理器

```python
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        """进入with语句时调用"""
        print("打开文件")
        self.file = open(self.filename, self.mode)
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出with语句时调用"""
        print("关闭文件")
        if self.file:
            self.file.close()
        return False

# 使用with语句
with FileManager('test.txt', 'w') as f:
    f.write('Hello, Python!')
# 自动调用__exit__方法关闭文件
```

### 4. 可调用对象

```python
class Multiplier:
    def __init__(self, factor):
        self.factor = factor
    
    def __call__(self, x):
        """使对象可以像函数一样调用"""
        return x * self.factor

# 创建对象
times_2 = Multiplier(2)
times_3 = Multiplier(3)

# 像函数一样调用
print(times_2(5))  # 10
print(times_3(5))  # 15
```

---

## 五、抽象类和接口

### 1. 抽象类

使用`abc`模块定义抽象类。

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    """抽象类"""
    
    def __init__(self, name):
        self.name = name
    
    @abstractmethod
    def speak(self):
        """抽象方法，子类必须实现"""
        pass
    
    @abstractmethod
    def move(self):
        """抽象方法"""
        pass

class Dog(Animal):
    def speak(self):
        return f"{self.name}汪汪叫"
    
    def move(self):
        return f"{self.name}在跑"

class Bird(Animal):
    def speak(self):
        return f"{self.name}叽叽叫"
    
    def move(self):
        return f"{self.name}在飞"

# 不能实例化抽象类
# animal = Animal("动物")  # TypeError

# 可以实例化子类
dog = Dog("旺财")
print(dog.speak())  # 旺财汪汪叫
print(dog.move())   # 旺财在跑
```

---

## 六、实战案例

### 案例1：图形类继承体系

```python
from abc import ABC, abstractmethod
import math

class Shape(ABC):
    """图形抽象类"""
    
    @abstractmethod
    def area(self):
        """计算面积"""
        pass
    
    @abstractmethod
    def perimeter(self):
        """计算周长"""
        pass

class Rectangle(Shape):
    """矩形"""
    
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)
    
    def __str__(self):
        return f"矩形(宽={self.width}, 高={self.height})"

class Circle(Shape):
    """圆形"""
    
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return math.pi * self.radius ** 2
    
    def perimeter(self):
        return 2 * math.pi * self.radius
    
    def __str__(self):
        return f"圆形(半径={self.radius})"

# 测试
shapes = [
    Rectangle(5, 3),
    Circle(4),
    Rectangle(10, 8)
]

for shape in shapes:
    print(shape)
    print(f"面积：{shape.area():.2f}")
    print(f"周长：{shape.perimeter():.2f}")
    print("---")
```

### 案例2：员工管理系统

```python
class Employee:
    """员工基类"""
    
    def __init__(self, name, employee_id):
        self.name = name
        self.employee_id = employee_id
    
    def get_salary(self):
        """获取工资（抽象方法）"""
        raise NotImplementedError("子类必须实现此方法")
    
    def __str__(self):
        return f"{self.name}({self.employee_id})"

class FullTimeEmployee(Employee):
    """全职员工"""
    
    def __init__(self, name, employee_id, monthly_salary):
        super().__init__(name, employee_id)
        self.monthly_salary = monthly_salary
    
    def get_salary(self):
        return self.monthly_salary

class PartTimeEmployee(Employee):
    """兼职员工"""
    
    def __init__(self, name, employee_id, hourly_rate, hours_worked):
        super().__init__(name, employee_id)
        self.hourly_rate = hourly_rate
        self.hours_worked = hours_worked
    
    def get_salary(self):
        return self.hourly_rate * self.hours_worked

class Manager(FullTimeEmployee):
    """经理"""
    
    def __init__(self, name, employee_id, monthly_salary, bonus):
        super().__init__(name, employee_id, monthly_salary)
        self.bonus = bonus
    
    def get_salary(self):
        return self.monthly_salary + self.bonus

# 测试
employees = [
    FullTimeEmployee("张三", "E001", 8000),
    PartTimeEmployee("李四", "E002", 50, 160),
    Manager("王五", "E003", 15000, 5000)
]

print("员工工资表：")
for emp in employees:
    print(f"{emp}：{emp.get_salary()}元")
```

---

## 七、知识点总结

### ✅ 核心要点

1. **继承**：代码复用，建立类层次关系
2. **多态**：同一方法在不同对象上的不同表现
3. **封装**：隐藏内部实现，提供公共接口
4. **魔术方法**：自定义对象行为
5. **抽象类**：定义接口规范

### 📝 面试重点

- 继承的优缺点
- 方法重写和super()的使用
- 多继承的MRO（方法解析顺序）
- 多态的实现原理
- @property装饰器的作用
- 常用魔术方法及其作用

---

**上一章：** [面向对象初级](03-面向对象初级.md)  
**下一章：** [模块与包](05-模块与包.md) →
