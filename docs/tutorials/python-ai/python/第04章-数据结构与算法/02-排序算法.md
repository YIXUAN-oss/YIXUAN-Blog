---
title: 排序算法
---

# 排序算法

> 掌握常见的排序算法及其实现

## 📚 学习目标

- 理解各种排序算法的原理
- 掌握排序算法的实现
- 了解算法的时间和空间复杂度
- 学会选择合适的排序算法

## 1. 冒泡排序

### 1.1 基本实现

```python
def bubble_sort(arr):
    """
    冒泡排序
    时间复杂度: O(n²)
    空间复杂度: O(1)
    """
    n = len(arr)
    
    for i in range(n):
        # 标记是否发生交换
        swapped = False
        
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        
        # 如果没有交换，说明已排序
        if not swapped:
            break
    
    return arr

# 测试
arr = [64, 34, 25, 12, 22, 11, 90]
print(bubble_sort(arr))
```

## 2. 选择排序

```python
def selection_sort(arr):
    """
    选择排序
    时间复杂度: O(n²)
    空间复杂度: O(1)
    """
    n = len(arr)
    
    for i in range(n):
        # 找到最小元素的索引
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # 交换
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# 测试
arr = [64, 25, 12, 22, 11]
print(selection_sort(arr))
```

## 3. 插入排序

```python
def insertion_sort(arr):
    """
    插入排序
    时间复杂度: O(n²)
    空间复杂度: O(1)
    """
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        
        # 将大于 key 的元素后移
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        arr[j + 1] = key
    
    return arr

# 测试
arr = [12, 11, 13, 5, 6]
print(insertion_sort(arr))
```

## 4. 快速排序

```python
def quick_sort(arr):
    """
    快速排序
    时间复杂度: 平均 O(n log n), 最坏 O(n²)
    空间复杂度: O(log n)
    """
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)

# 原地快速排序
def quick_sort_inplace(arr, low=0, high=None):
    if high is None:
        high = len(arr) - 1
    
    if low < high:
        pi = partition(arr, low, high)
        quick_sort_inplace(arr, low, pi - 1)
        quick_sort_inplace(arr, pi + 1, high)
    
    return arr

def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

# 测试
arr = [10, 7, 8, 9, 1, 5]
print(quick_sort(arr))
```

## 5. 归并排序

```python
def merge_sort(arr):
    """
    归并排序
    时间复杂度: O(n log n)
    空间复杂度: O(n)
    """
    if len(arr) <= 1:
        return arr
    
    # 分割
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    # 合并
    return merge(left, right)

def merge(left, right):
    """合并两个有序数组"""
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result

# 测试
arr = [38, 27, 43, 3, 9, 82, 10]
print(merge_sort(arr))
```

## 6. 堆排序

```python
def heap_sort(arr):
    """
    堆排序
    时间复杂度: O(n log n)
    空间复杂度: O(1)
    """
    n = len(arr)
    
    # 构建最大堆
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # 一个个提取元素
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    
    return arr

def heapify(arr, n, i):
    """调整堆"""
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

# 测试
arr = [12, 11, 13, 5, 6, 7]
print(heap_sort(arr))
```

## 7. 计数排序

```python
def counting_sort(arr):
    """
    计数排序（适用于整数且范围不大的情况）
    时间复杂度: O(n + k)
    空间复杂度: O(k)
    """
    if not arr:
        return arr
    
    # 找出最大值和最小值
    max_val = max(arr)
    min_val = min(arr)
    range_size = max_val - min_val + 1
    
    # 计数
    count = [0] * range_size
    for num in arr:
        count[num - min_val] += 1
    
    # 累加计数
    for i in range(1, range_size):
        count[i] += count[i - 1]
    
    # 构建结果数组
    result = [0] * len(arr)
    for num in reversed(arr):
        index = count[num - min_val] - 1
        result[index] = num
        count[num - min_val] -= 1
    
    return result

# 测试
arr = [4, 2, 2, 8, 3, 3, 1]
print(counting_sort(arr))
```

## 8. 算法性能对比

```python
import time
import random

def benchmark_sort(sort_func, arr, name):
    """测试排序算法性能"""
    arr_copy = arr.copy()
    start = time.time()
    sort_func(arr_copy)
    end = time.time()
    print(f'{name}: {end - start:.6f} 秒')

# 生成测试数据
test_data = [random.randint(1, 1000) for _ in range(1000)]

# 比较不同算法
print('排序算法性能比较 (1000个元素):')
benchmark_sort(bubble_sort, test_data, '冒泡排序')
benchmark_sort(selection_sort, test_data, '选择排序')
benchmark_sort(insertion_sort, test_data, '插入排序')
benchmark_sort(quick_sort, test_data, '快速排序')
benchmark_sort(merge_sort, test_data, '归并排序')
benchmark_sort(heap_sort, test_data, '堆排序')
benchmark_sort(sorted, test_data, 'Python内置')
```

## 9. 实战应用

### 9.1 Top K 问题

```python
import heapq

def find_kth_largest(nums, k):
    """找到第k大的元素"""
    return heapq.nlargest(k, nums)[-1]

def top_k_frequent(nums, k):
    """找到出现频率最高的k个元素"""
    from collections import Counter
    count = Counter(nums)
    return [item for item, _ in count.most_common(k)]

# 测试
nums = [1, 1, 1, 2, 2, 3]
print(top_k_frequent(nums, 2))  # [1, 2]
```

### 9.2 自定义排序

```python
# 按多个条件排序
students = [
    {'name': 'Alice', 'age': 25, 'score': 90},
    {'name': 'Bob', 'age': 23, 'score': 95},
    {'name': 'Charlie', 'age': 25, 'score': 85},
]

# 按年龄升序，分数降序
sorted_students = sorted(students, key=lambda x: (x['age'], -x['score']))
print(sorted_students)
```

## 📝 练习题

1. 实现荷兰国旗问题（三路快排）
2. 编写一个函数合并k个有序链表
3. 实现桶排序
4. 找出数组中第K大的元素

---

**下一节：** [搜索算法](03-搜索算法.md)
