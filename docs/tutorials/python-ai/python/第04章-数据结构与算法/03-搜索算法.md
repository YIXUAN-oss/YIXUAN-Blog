---
title: æœç´¢ç®—æ³•
---

# æœç´¢ç®—æ³•

> æŒæ¡å¸¸è§çš„æœç´¢ç®—æ³•

## ğŸ“š å­¦ä¹ ç›®æ ‡

- æŒæ¡çº¿æ€§æœç´¢å’ŒäºŒåˆ†æœç´¢
- ç†è§£æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰
- ç†è§£å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰
- å­¦ä¼šåº”ç”¨æœç´¢ç®—æ³•è§£å†³é—®é¢˜

## 1. çº¿æ€§æœç´¢

```python
def linear_search(arr, target):
    """
    çº¿æ€§æœç´¢
    æ—¶é—´å¤æ‚åº¦: O(n)
    """
    for i, num in enumerate(arr):
        if num == target:
            return i
    return -1

# æµ‹è¯•
arr = [3, 1, 4, 1, 5, 9, 2, 6]
print(linear_search(arr, 5))  # 4
```

## 2. äºŒåˆ†æœç´¢

```python
def binary_search(arr, target):
    """
    äºŒåˆ†æœç´¢ï¼ˆæ•°ç»„å¿…é¡»æœ‰åºï¼‰
    æ—¶é—´å¤æ‚åº¦: O(log n)
    """
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1

# é€’å½’ç‰ˆæœ¬
def binary_search_recursive(arr, target, left=0, right=None):
    if right is None:
        right = len(arr) - 1
    
    if left > right:
        return -1
    
    mid = (left + right) // 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)

# æµ‹è¯•
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(binary_search(arr, 5))  # 4
```

## 3. æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰

### 3.1 å›¾çš„DFS

```python
def dfs(graph, start, visited=None):
    """
    æ·±åº¦ä¼˜å…ˆæœç´¢
    """
    if visited is None:
        visited = set()
    
    visited.add(start)
    print(start, end=' ')
    
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    
    return visited

# æµ‹è¯•
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

dfs(graph, 'A')  # A B D E F C
```

### 3.2 è¿­ä»£ç‰ˆDFS

```python
def dfs_iterative(graph, start):
    """ä½¿ç”¨æ ˆå®ç°DFS"""
    visited = set()
    stack = [start]
    
    while stack:
        vertex = stack.pop()
        if vertex not in visited:
            visited.add(vertex)
            print(vertex, end=' ')
            
            # å°†æœªè®¿é—®çš„é‚»å±…å…¥æ ˆ
            for neighbor in reversed(graph[vertex]):
                if neighbor not in visited:
                    stack.append(neighbor)
    
    return visited

dfs_iterative(graph, 'A')
```

## 4. å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰

```python
from collections import deque

def bfs(graph, start):
    """
    å¹¿åº¦ä¼˜å…ˆæœç´¢
    """
    visited = set([start])
    queue = deque([start])
    
    while queue:
        vertex = queue.popleft()
        print(vertex, end=' ')
        
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return visited

# æµ‹è¯•
bfs(graph, 'A')  # A B C D E F
```

## 5. äºŒå‰æ ‘éå†

```python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def dfs_preorder(root):
    """å‰åºéå†ï¼ˆé€’å½’ï¼‰"""
    if not root:
        return
    print(root.val, end=' ')
    dfs_preorder(root.left)
    dfs_preorder(root.right)

def dfs_inorder(root):
    """ä¸­åºéå†ï¼ˆé€’å½’ï¼‰"""
    if not root:
        return
    dfs_inorder(root.left)
    print(root.val, end=' ')
    dfs_inorder(root.right)

def dfs_postorder(root):
    """ååºéå†ï¼ˆé€’å½’ï¼‰"""
    if not root:
        return
    dfs_postorder(root.left)
    dfs_postorder(root.right)
    print(root.val, end=' ')

def bfs_level_order(root):
    """å±‚åºéå†ï¼ˆBFSï¼‰"""
    if not root:
        return
    
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        print(node.val, end=' ')
        
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)

# æ„å»ºäºŒå‰æ ‘
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print('å‰åº:', end=' ')
dfs_preorder(root)  # 1 2 4 5 3
print('\nä¸­åº:', end=' ')
dfs_inorder(root)   # 4 2 5 1 3
print('\nååº:', end=' ')
dfs_postorder(root)  # 4 5 2 3 1
print('\nå±‚åº:', end=' ')
bfs_level_order(root)  # 1 2 3 4 5
```

## 6. å®æˆ˜åº”ç”¨

### 6.1 å²›å±¿æ•°é‡

```python
def num_islands(grid):
    """
    è®¡ç®—å²›å±¿æ•°é‡ï¼ˆDFSï¼‰
    """
    if not grid:
        return 0
    
    def dfs(i, j):
        if (i < 0 or i >= len(grid) or 
            j < 0 or j >= len(grid[0]) or 
            grid[i][j] == '0'):
            return
        
        grid[i][j] = '0'  # æ ‡è®°ä¸ºå·²è®¿é—®
        
        # è®¿é—®å››ä¸ªæ–¹å‘
        dfs(i + 1, j)
        dfs(i - 1, j)
        dfs(i, j + 1)
        dfs(i, j - 1)
    
    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                dfs(i, j)
                count += 1
    
    return count

# æµ‹è¯•
grid = [
    ['1', '1', '0', '0', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '1', '0', '0'],
    ['0', '0', '0', '1', '1']
]
print(num_islands(grid))  # 3
```

### 6.2 æœ€çŸ­è·¯å¾„ï¼ˆBFSï¼‰

```python
def shortest_path(graph, start, end):
    """
    ä½¿ç”¨BFSæ‰¾æœ€çŸ­è·¯å¾„
    """
    queue = deque([(start, [start])])
    visited = {start}
    
    while queue:
        vertex, path = queue.popleft()
        
        if vertex == end:
            return path
        
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    
    return None

# æµ‹è¯•
path = shortest_path(graph, 'A', 'F')
print(' -> '.join(path))  # A -> C -> F
```

### 6.3 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

```python
def max_depth(root):
    """è®¡ç®—äºŒå‰æ ‘æœ€å¤§æ·±åº¦ï¼ˆDFSï¼‰"""
    if not root:
        return 0
    return 1 + max(max_depth(root.left), max_depth(root.right))

# BFS ç‰ˆæœ¬
def max_depth_bfs(root):
    if not root:
        return 0
    
    queue = deque([(root, 1)])
    max_d = 0
    
    while queue:
        node, depth = queue.popleft()
        max_d = max(max_d, depth)
        
        if node.left:
            queue.append((node.left, depth + 1))
        if node.right:
            queue.append((node.right, depth + 1))
    
    return max_d

print(max_depth(root))  # 3
```

## ğŸ“ ç»ƒä¹ é¢˜

1. å®ç°äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†
2. åˆ¤æ–­äºŒå‰æ ‘æ˜¯å¦å¯¹ç§°
3. æ‰¾åˆ°å›¾ä¸­ä¸¤ç‚¹ä¹‹é—´çš„æ‰€æœ‰è·¯å¾„
4. å®ç°å•è¯æ¥é¾™é—®é¢˜

---

**ä¸‹ä¸€èŠ‚ï¼š** [åŠ¨æ€è§„åˆ’](04-åŠ¨æ€è§„åˆ’.md)
