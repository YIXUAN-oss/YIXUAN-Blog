---
title: 动态规划
---

# 动态规划

> 掌握动态规划思想，解决复杂问题

## 📚 学习目标

- 理解动态规划的核心思想
- 掌握状态定义和状态转移
- 学会识别动态规划问题
- 掌握常见的动态规划模式

## 1. 动态规划基础

### 1.1 斐波那契数列

```python
# 递归（效率低）
def fib_recursive(n):
    if n <= 1:
        return n
    return fib_recursive(n-1) + fib_recursive(n-2)

# 动态规划（自底向上）
def fib_dp(n):
    if n <= 1:
        return n
    
    dp = [0] * (n + 1)
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]

# 空间优化
def fib_optimized(n):
    if n <= 1:
        return n
    
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    
    return b

print(fib_dp(10))  # 55
```

## 2. 经典问题

### 2.1 爬楼梯

```python
def climb_stairs(n):
    """
    爬楼梯：每次可以爬1或2个台阶
    问有多少种方法爬到第n阶
    """
    if n <= 2:
        return n
    
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 2
    
    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]

print(climb_stairs(5))  # 8
```

### 2.2 硬币找零

```python
def coin_change(coins, amount):
    """
    硬币找零：找到组成amount的最少硬币数
    """
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1

coins = [1, 2, 5]
print(coin_change(coins, 11))  # 3 (5+5+1)
```

### 2.3 最长递增子序列

```python
def length_of_lis(nums):
    """
    最长递增子序列
    """
    if not nums:
        return 0
    
    n = len(nums)
    dp = [1] * n
    
    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    
    return max(dp)

nums = [10, 9, 2, 5, 3, 7, 101, 18]
print(length_of_lis(nums))  # 4 ([2,3,7,18])
```

## 3. 背包问题

### 3.1 0-1背包

```python
def knapsack_01(weights, values, capacity):
    """
    0-1背包：每个物品只能选一次
    """
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            if weights[i-1] <= w:
                # 选或不选当前物品
                dp[i][w] = max(
                    dp[i-1][w],  # 不选
                    dp[i-1][w - weights[i-1]] + values[i-1]  # 选
                )
            else:
                dp[i][w] = dp[i-1][w]
    
    return dp[n][capacity]

# 空间优化版本
def knapsack_01_optimized(weights, values, capacity):
    dp = [0] * (capacity + 1)
    
    for i in range(len(weights)):
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    
    return dp[capacity]

weights = [2, 3, 4, 5]
values = [3, 4, 5, 6]
capacity = 8
print(knapsack_01(weights, values, capacity))  # 10
```

### 3.2 完全背包

```python
def knapsack_complete(weights, values, capacity):
    """
    完全背包：每个物品可以选多次
    """
    dp = [0] * (capacity + 1)
    
    for i in range(len(weights)):
        for w in range(weights[i], capacity + 1):
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    
    return dp[capacity]

print(knapsack_complete(weights, values, capacity))
```

## 4. 字符串问题

### 4.1 最长公共子序列

```python
def longest_common_subsequence(text1, text2):
    """
    最长公共子序列 (LCS)
    """
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]

text1 = "abcde"
text2 = "ace"
print(longest_common_subsequence(text1, text2))  # 3
```

### 4.2 编辑距离

```python
def edit_distance(word1, word2):
    """
    编辑距离（Levenshtein距离）
    """
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # 初始化
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
    
    # 填表
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = min(
                    dp[i-1][j] + 1,    # 删除
                    dp[i][j-1] + 1,    # 插入
                    dp[i-1][j-1] + 1   # 替换
                )
    
    return dp[m][n]

word1 = "horse"
word2 = "ros"
print(edit_distance(word1, word2))  # 3
```

## 5. 路径问题

### 5.1 不同路径

```python
def unique_paths(m, n):
    """
    从左上角到右下角的不同路径数
    """
    dp = [[1] * n for _ in range(m)]
    
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    
    return dp[m-1][n-1]

# 空间优化
def unique_paths_optimized(m, n):
    dp = [1] * n
    
    for i in range(1, m):
        for j in range(1, n):
            dp[j] += dp[j-1]
    
    return dp[n-1]

print(unique_paths(3, 7))  # 28
```

### 5.2 最小路径和

```python
def min_path_sum(grid):
    """
    从左上角到右下角的最小路径和
    """
    m, n = len(grid), len(grid[0])
    dp = [[0] * n for _ in range(m)]
    
    dp[0][0] = grid[0][0]
    
    # 初始化第一行
    for j in range(1, n):
        dp[0][j] = dp[0][j-1] + grid[0][j]
    
    # 初始化第一列
    for i in range(1, m):
        dp[i][0] = dp[i-1][0] + grid[i][0]
    
    # 填表
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
    
    return dp[m-1][n-1]

grid = [
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1]
]
print(min_path_sum(grid))  # 7
```

## 6. 股票问题

```python
def max_profit(prices):
    """
    买卖股票的最佳时机（只能交易一次）
    """
    if not prices:
        return 0
    
    min_price = prices[0]
    max_profit = 0
    
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    
    return max_profit

def max_profit_k(k, prices):
    """
    最多k次交易
    """
    if not prices:
        return 0
    
    n = len(prices)
    if k >= n // 2:
        # 相当于无限次交易
        return sum(max(prices[i] - prices[i-1], 0) for i in range(1, n))
    
    dp = [[0] * n for _ in range(k + 1)]
    
    for i in range(1, k + 1):
        max_diff = -prices[0]
        for j in range(1, n):
            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)
            max_diff = max(max_diff, dp[i-1][j] - prices[j])
    
    return dp[k][n-1]

prices = [3, 2, 6, 5, 0, 3]
print(max_profit(prices))  # 4
```

## 7. 实战技巧

### 7.1 状态压缩

```python
# 使用位运算进行状态压缩
def travel_salesman(dist):
    """旅行商问题（状态压缩DP）"""
    n = len(dist)
    dp = [[float('inf')] * n for _ in range(1 << n)]
    dp[1][0] = 0
    
    for state in range(1 << n):
        for i in range(n):
            if dp[state][i] == float('inf'):
                continue
            for j in range(n):
                if not (state & (1 << j)):
                    new_state = state | (1 << j)
                    dp[new_state][j] = min(
                        dp[new_state][j],
                        dp[state][i] + dist[i][j]
                    )
    
    return min(dp[(1 << n) - 1])
```

### 7.2 记忆化搜索

```python
def fib_memo(n, memo=None):
    """使用记忆化的斐波那契"""
    if memo is None:
        memo = {}
    
    if n in memo:
        return memo[n]
    
    if n <= 1:
        return n
    
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]

# 使用装饰器
from functools import lru_cache

@lru_cache(maxsize=None)
def fib_cached(n):
    if n <= 1:
        return n
    return fib_cached(n-1) + fib_cached(n-2)

print(fib_cached(100))
```

## 📝 练习题

1. 实现打家劫舍问题
2. 解决分割等和子集问题
3. 实现正则表达式匹配
4. 解决最大子数组和问题

---

**恭喜完成第04章学习！** 🎉
