---
title: 常用数据结构
---

# 常用数据结构

> 掌握Python中的常用数据结构及其应用

## 📚 学习目标

- 理解栈、队列、链表等基本数据结构
- 掌握各种数据结构的实现
- 学会选择合适的数据结构
- 理解时间复杂度和空间复杂度

## 1. 栈（Stack）

### 1.1 栈的实现

```python
class Stack:
    """栈 - 后进先出（LIFO）"""
    
    def __init__(self):
        self.items = []
    
    def push(self, item):
        """入栈"""
        self.items.append(item)
    
    def pop(self):
        """出栈"""
        if not self.is_empty():
            return self.items.pop()
        raise IndexError('栈为空')
    
    def peek(self):
        """查看栈顶元素"""
        if not self.is_empty():
            return self.items[-1]
        return None
    
    def is_empty(self):
        """检查栈是否为空"""
        return len(self.items) == 0
    
    def size(self):
        """返回栈的大小"""
        return len(self.items)

# 使用
stack = Stack()
stack.push(1)
stack.push(2)
stack.push(3)
print(stack.pop())  # 3
print(stack.peek())  # 2
```

### 1.2 栈的应用

```python
# 括号匹配
def is_valid_parentheses(s):
    """检查括号是否匹配"""
    stack = []
    pairs = {'(': ')', '[': ']', '{': '}'}
    
    for char in s:
        if char in pairs:
            stack.append(char)
        elif char in pairs.values():
            if not stack or pairs[stack.pop()] != char:
                return False
    
    return len(stack) == 0

print(is_valid_parentheses('()[]{}'))  # True
print(is_valid_parentheses('([)]'))    # False

# 逆波兰表达式求值
def eval_rpn(tokens):
    """逆波兰表达式求值"""
    stack = []
    operators = {'+', '-', '*', '/'}
    
    for token in tokens:
        if token in operators:
            b = stack.pop()
            a = stack.pop()
            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            else:
                stack.append(int(a / b))
        else:
            stack.append(int(token))
    
    return stack[0]

print(eval_rpn(['2', '1', '+', '3', '*']))  # 9
```

## 2. 队列（Queue）

### 2.1 队列的实现

```python
class Queue:
    """队列 - 先进先出（FIFO）"""
    
    def __init__(self):
        self.items = []
    
    def enqueue(self, item):
        """入队"""
        self.items.insert(0, item)
    
    def dequeue(self):
        """出队"""
        if not self.is_empty():
            return self.items.pop()
        raise IndexError('队列为空')
    
    def is_empty(self):
        return len(self.items) == 0
    
    def size(self):
        return len(self.items)

# 使用
queue = Queue()
queue.enqueue(1)
queue.enqueue(2)
print(queue.dequeue())  # 1
```

### 2.2 使用 collections.deque

```python
from collections import deque

# 双端队列（更高效）
queue = deque()

# 队列操作
queue.append(1)  # 右侧入队
queue.append(2)
queue.popleft()  # 左侧出队

# 栈操作
queue.append(1)  # 入栈
queue.pop()      # 出栈
```

### 2.3 循环队列

```python
class CircularQueue:
    """循环队列"""
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.queue = [None] * capacity
        self.front = 0
        self.rear = 0
        self.size = 0
    
    def enqueue(self, item):
        if self.is_full():
            raise IndexError('队列已满')
        self.queue[self.rear] = item
        self.rear = (self.rear + 1) % self.capacity
        self.size += 1
    
    def dequeue(self):
        if self.is_empty():
            raise IndexError('队列为空')
        item = self.queue[self.front]
        self.front = (self.front + 1) % self.capacity
        self.size -= 1
        return item
    
    def is_empty(self):
        return self.size == 0
    
    def is_full(self):
        return self.size == self.capacity

# 使用
cq = CircularQueue(5)
for i in range(5):
    cq.enqueue(i)
```

## 3. 链表（Linked List）

### 3.1 单链表

```python
class Node:
    """链表节点"""
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    """单链表"""
    
    def __init__(self):
        self.head = None
    
    def append(self, data):
        """在末尾添加节点"""
        new_node = Node(data)
        
        if not self.head:
            self.head = new_node
            return
        
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node
    
    def insert(self, position, data):
        """在指定位置插入节点"""
        new_node = Node(data)
        
        if position == 0:
            new_node.next = self.head
            self.head = new_node
            return
        
        current = self.head
        for _ in range(position - 1):
            if not current:
                raise IndexError('位置超出范围')
            current = current.next
        
        new_node.next = current.next
        current.next = new_node
    
    def delete(self, data):
        """删除指定值的节点"""
        if not self.head:
            return
        
        if self.head.data == data:
            self.head = self.head.next
            return
        
        current = self.head
        while current.next:
            if current.next.data == data:
                current.next = current.next.next
                return
            current = current.next
    
    def display(self):
        """显示链表"""
        elements = []
        current = self.head
        while current:
            elements.append(current.data)
            current = current.next
        print(' -> '.join(map(str, elements)))

# 使用
ll = LinkedList()
ll.append(1)
ll.append(2)
ll.append(3)
ll.display()  # 1 -> 2 -> 3
```

### 3.2 双向链表

```python
class DNode:
    """双向链表节点"""
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

class DoublyLinkedList:
    """双向链表"""
    
    def __init__(self):
        self.head = None
        self.tail = None
    
    def append(self, data):
        """在末尾添加节点"""
        new_node = DNode(data)
        
        if not self.head:
            self.head = self.tail = new_node
            return
        
        new_node.prev = self.tail
        self.tail.next = new_node
        self.tail = new_node
    
    def display_forward(self):
        """正向显示"""
        elements = []
        current = self.head
        while current:
            elements.append(current.data)
            current = current.next
        print(' <-> '.join(map(str, elements)))
    
    def display_backward(self):
        """反向显示"""
        elements = []
        current = self.tail
        while current:
            elements.append(current.data)
            current = current.prev
        print(' <-> '.join(map(str, elements)))

# 使用
dll = DoublyLinkedList()
dll.append(1)
dll.append(2)
dll.append(3)
dll.display_forward()   # 1 <-> 2 <-> 3
dll.display_backward()  # 3 <-> 2 <-> 1
```

## 4. 哈希表（Hash Table）

### 4.1 简单哈希表实现

```python
class HashTable:
    """简单哈希表"""
    
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]
    
    def _hash(self, key):
        """哈希函数"""
        return hash(key) % self.size
    
    def set(self, key, value):
        """设置键值对"""
        index = self._hash(key)
        
        # 检查是否已存在
        for item in self.table[index]:
            if item[0] == key:
                item[1] = value
                return
        
        # 添加新键值对
        self.table[index].append([key, value])
    
    def get(self, key):
        """获取值"""
        index = self._hash(key)
        
        for item in self.table[index]:
            if item[0] == key:
                return item[1]
        
        raise KeyError(key)
    
    def delete(self, key):
        """删除键值对"""
        index = self._hash(key)
        
        for i, item in enumerate(self.table[index]):
            if item[0] == key:
                del self.table[index][i]
                return
        
        raise KeyError(key)

# 使用
ht = HashTable()
ht.set('name', 'Alice')
ht.set('age', 25)
print(ht.get('name'))  # Alice
```

## 5. 树（Tree）

### 5.1 二叉树

```python
class TreeNode:
    """二叉树节点"""
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

class BinaryTree:
    """二叉树"""
    
    def __init__(self, root=None):
        self.root = root
    
    def preorder(self, node):
        """前序遍历：根-左-右"""
        if node:
            print(node.val, end=' ')
            self.preorder(node.left)
            self.preorder(node.right)
    
    def inorder(self, node):
        """中序遍历：左-根-右"""
        if node:
            self.inorder(node.left)
            print(node.val, end=' ')
            self.inorder(node.right)
    
    def postorder(self, node):
        """后序遍历：左-右-根"""
        if node:
            self.postorder(node.left)
            self.postorder(node.right)
            print(node.val, end=' ')
    
    def level_order(self):
        """层序遍历"""
        if not self.root:
            return
        
        from collections import deque
        queue = deque([self.root])
        
        while queue:
            node = queue.popleft()
            print(node.val, end=' ')
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

# 构建二叉树
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

tree = BinaryTree(root)
tree.inorder(root)  # 4 2 5 1 3
```

### 5.2 二叉搜索树

```python
class BST:
    """二叉搜索树"""
    
    def __init__(self):
        self.root = None
    
    def insert(self, val):
        """插入节点"""
        if not self.root:
            self.root = TreeNode(val)
        else:
            self._insert_recursive(self.root, val)
    
    def _insert_recursive(self, node, val):
        if val < node.val:
            if node.left:
                self._insert_recursive(node.left, val)
            else:
                node.left = TreeNode(val)
        else:
            if node.right:
                self._insert_recursive(node.right, val)
            else:
                node.right = TreeNode(val)
    
    def search(self, val):
        """搜索节点"""
        return self._search_recursive(self.root, val)
    
    def _search_recursive(self, node, val):
        if not node:
            return False
        if node.val == val:
            return True
        elif val < node.val:
            return self._search_recursive(node.left, val)
        else:
            return self._search_recursive(node.right, val)

# 使用
bst = BST()
for val in [5, 3, 7, 2, 4, 6, 8]:
    bst.insert(val)
print(bst.search(4))  # True
```

## 6. 堆（Heap）

### 6.1 使用 heapq 模块

```python
import heapq

# 创建最小堆
heap = []
heapq.heappush(heap, 3)
heapq.heappush(heap, 1)
heapq.heappush(heap, 5)

print(heapq.heappop(heap))  # 1（最小值）

# 堆排序
nums = [3, 1, 4, 1, 5, 9, 2, 6]
heapq.heapify(nums)  # 原地转换为堆
sorted_nums = [heapq.heappop(nums) for _ in range(len(nums))]
print(sorted_nums)

# 获取最大/最小的 n 个元素
nums = [3, 1, 4, 1, 5, 9, 2, 6]
print(heapq.nlargest(3, nums))   # [9, 6, 5]
print(heapq.nsmallest(3, nums))  # [1, 1, 2]
```

## 📝 练习题

1. 实现一个最小栈（支持O(1)时间获取最小值）
2. 用栈实现队列
3. 反转链表
4. 判断链表是否有环

---

**下一节：** [排序算法](02-排序算法.md)
