---
title: å¸¸ç”¨æ•°æ®ç»“æ„
---

# å¸¸ç”¨æ•°æ®ç»“æ„

> æŒæ¡Pythonä¸­çš„å¸¸ç”¨æ•°æ®ç»“æ„åŠå…¶åº”ç”¨

## ğŸ“š å­¦ä¹ ç›®æ ‡

- ç†è§£æ ˆã€é˜Ÿåˆ—ã€é“¾è¡¨ç­‰åŸºæœ¬æ•°æ®ç»“æ„
- æŒæ¡å„ç§æ•°æ®ç»“æ„çš„å®ç°
- å­¦ä¼šé€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„
- ç†è§£æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦

## 1. æ ˆï¼ˆStackï¼‰

### 1.1 æ ˆçš„å®ç°

```python
class Stack:
    """æ ˆ - åè¿›å…ˆå‡ºï¼ˆLIFOï¼‰"""
    
    def __init__(self):
        self.items = []
    
    def push(self, item):
        """å…¥æ ˆ"""
        self.items.append(item)
    
    def pop(self):
        """å‡ºæ ˆ"""
        if not self.is_empty():
            return self.items.pop()
        raise IndexError('æ ˆä¸ºç©º')
    
    def peek(self):
        """æŸ¥çœ‹æ ˆé¡¶å…ƒç´ """
        if not self.is_empty():
            return self.items[-1]
        return None
    
    def is_empty(self):
        """æ£€æŸ¥æ ˆæ˜¯å¦ä¸ºç©º"""
        return len(self.items) == 0
    
    def size(self):
        """è¿”å›æ ˆçš„å¤§å°"""
        return len(self.items)

# ä½¿ç”¨
stack = Stack()
stack.push(1)
stack.push(2)
stack.push(3)
print(stack.pop())  # 3
print(stack.peek())  # 2
```

### 1.2 æ ˆçš„åº”ç”¨

```python
# æ‹¬å·åŒ¹é…
def is_valid_parentheses(s):
    """æ£€æŸ¥æ‹¬å·æ˜¯å¦åŒ¹é…"""
    stack = []
    pairs = {'(': ')', '[': ']', '{': '}'}
    
    for char in s:
        if char in pairs:
            stack.append(char)
        elif char in pairs.values():
            if not stack or pairs[stack.pop()] != char:
                return False
    
    return len(stack) == 0

print(is_valid_parentheses('()[]{}'))  # True
print(is_valid_parentheses('([)]'))    # False

# é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼
def eval_rpn(tokens):
    """é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼"""
    stack = []
    operators = {'+', '-', '*', '/'}
    
    for token in tokens:
        if token in operators:
            b = stack.pop()
            a = stack.pop()
            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            else:
                stack.append(int(a / b))
        else:
            stack.append(int(token))
    
    return stack[0]

print(eval_rpn(['2', '1', '+', '3', '*']))  # 9
```

## 2. é˜Ÿåˆ—ï¼ˆQueueï¼‰

### 2.1 é˜Ÿåˆ—çš„å®ç°

```python
class Queue:
    """é˜Ÿåˆ— - å…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰"""
    
    def __init__(self):
        self.items = []
    
    def enqueue(self, item):
        """å…¥é˜Ÿ"""
        self.items.insert(0, item)
    
    def dequeue(self):
        """å‡ºé˜Ÿ"""
        if not self.is_empty():
            return self.items.pop()
        raise IndexError('é˜Ÿåˆ—ä¸ºç©º')
    
    def is_empty(self):
        return len(self.items) == 0
    
    def size(self):
        return len(self.items)

# ä½¿ç”¨
queue = Queue()
queue.enqueue(1)
queue.enqueue(2)
print(queue.dequeue())  # 1
```

### 2.2 ä½¿ç”¨ collections.deque

```python
from collections import deque

# åŒç«¯é˜Ÿåˆ—ï¼ˆæ›´é«˜æ•ˆï¼‰
queue = deque()

# é˜Ÿåˆ—æ“ä½œ
queue.append(1)  # å³ä¾§å…¥é˜Ÿ
queue.append(2)
queue.popleft()  # å·¦ä¾§å‡ºé˜Ÿ

# æ ˆæ“ä½œ
queue.append(1)  # å…¥æ ˆ
queue.pop()      # å‡ºæ ˆ
```

### 2.3 å¾ªç¯é˜Ÿåˆ—

```python
class CircularQueue:
    """å¾ªç¯é˜Ÿåˆ—"""
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.queue = [None] * capacity
        self.front = 0
        self.rear = 0
        self.size = 0
    
    def enqueue(self, item):
        if self.is_full():
            raise IndexError('é˜Ÿåˆ—å·²æ»¡')
        self.queue[self.rear] = item
        self.rear = (self.rear + 1) % self.capacity
        self.size += 1
    
    def dequeue(self):
        if self.is_empty():
            raise IndexError('é˜Ÿåˆ—ä¸ºç©º')
        item = self.queue[self.front]
        self.front = (self.front + 1) % self.capacity
        self.size -= 1
        return item
    
    def is_empty(self):
        return self.size == 0
    
    def is_full(self):
        return self.size == self.capacity

# ä½¿ç”¨
cq = CircularQueue(5)
for i in range(5):
    cq.enqueue(i)
```

## 3. é“¾è¡¨ï¼ˆLinked Listï¼‰

### 3.1 å•é“¾è¡¨

```python
class Node:
    """é“¾è¡¨èŠ‚ç‚¹"""
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    """å•é“¾è¡¨"""
    
    def __init__(self):
        self.head = None
    
    def append(self, data):
        """åœ¨æœ«å°¾æ·»åŠ èŠ‚ç‚¹"""
        new_node = Node(data)
        
        if not self.head:
            self.head = new_node
            return
        
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node
    
    def insert(self, position, data):
        """åœ¨æŒ‡å®šä½ç½®æ’å…¥èŠ‚ç‚¹"""
        new_node = Node(data)
        
        if position == 0:
            new_node.next = self.head
            self.head = new_node
            return
        
        current = self.head
        for _ in range(position - 1):
            if not current:
                raise IndexError('ä½ç½®è¶…å‡ºèŒƒå›´')
            current = current.next
        
        new_node.next = current.next
        current.next = new_node
    
    def delete(self, data):
        """åˆ é™¤æŒ‡å®šå€¼çš„èŠ‚ç‚¹"""
        if not self.head:
            return
        
        if self.head.data == data:
            self.head = self.head.next
            return
        
        current = self.head
        while current.next:
            if current.next.data == data:
                current.next = current.next.next
                return
            current = current.next
    
    def display(self):
        """æ˜¾ç¤ºé“¾è¡¨"""
        elements = []
        current = self.head
        while current:
            elements.append(current.data)
            current = current.next
        print(' -> '.join(map(str, elements)))

# ä½¿ç”¨
ll = LinkedList()
ll.append(1)
ll.append(2)
ll.append(3)
ll.display()  # 1 -> 2 -> 3
```

### 3.2 åŒå‘é“¾è¡¨

```python
class DNode:
    """åŒå‘é“¾è¡¨èŠ‚ç‚¹"""
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

class DoublyLinkedList:
    """åŒå‘é“¾è¡¨"""
    
    def __init__(self):
        self.head = None
        self.tail = None
    
    def append(self, data):
        """åœ¨æœ«å°¾æ·»åŠ èŠ‚ç‚¹"""
        new_node = DNode(data)
        
        if not self.head:
            self.head = self.tail = new_node
            return
        
        new_node.prev = self.tail
        self.tail.next = new_node
        self.tail = new_node
    
    def display_forward(self):
        """æ­£å‘æ˜¾ç¤º"""
        elements = []
        current = self.head
        while current:
            elements.append(current.data)
            current = current.next
        print(' <-> '.join(map(str, elements)))
    
    def display_backward(self):
        """åå‘æ˜¾ç¤º"""
        elements = []
        current = self.tail
        while current:
            elements.append(current.data)
            current = current.prev
        print(' <-> '.join(map(str, elements)))

# ä½¿ç”¨
dll = DoublyLinkedList()
dll.append(1)
dll.append(2)
dll.append(3)
dll.display_forward()   # 1 <-> 2 <-> 3
dll.display_backward()  # 3 <-> 2 <-> 1
```

## 4. å“ˆå¸Œè¡¨ï¼ˆHash Tableï¼‰

### 4.1 ç®€å•å“ˆå¸Œè¡¨å®ç°

```python
class HashTable:
    """ç®€å•å“ˆå¸Œè¡¨"""
    
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]
    
    def _hash(self, key):
        """å“ˆå¸Œå‡½æ•°"""
        return hash(key) % self.size
    
    def set(self, key, value):
        """è®¾ç½®é”®å€¼å¯¹"""
        index = self._hash(key)
        
        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        for item in self.table[index]:
            if item[0] == key:
                item[1] = value
                return
        
        # æ·»åŠ æ–°é”®å€¼å¯¹
        self.table[index].append([key, value])
    
    def get(self, key):
        """è·å–å€¼"""
        index = self._hash(key)
        
        for item in self.table[index]:
            if item[0] == key:
                return item[1]
        
        raise KeyError(key)
    
    def delete(self, key):
        """åˆ é™¤é”®å€¼å¯¹"""
        index = self._hash(key)
        
        for i, item in enumerate(self.table[index]):
            if item[0] == key:
                del self.table[index][i]
                return
        
        raise KeyError(key)

# ä½¿ç”¨
ht = HashTable()
ht.set('name', 'Alice')
ht.set('age', 25)
print(ht.get('name'))  # Alice
```

## 5. æ ‘ï¼ˆTreeï¼‰

### 5.1 äºŒå‰æ ‘

```python
class TreeNode:
    """äºŒå‰æ ‘èŠ‚ç‚¹"""
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

class BinaryTree:
    """äºŒå‰æ ‘"""
    
    def __init__(self, root=None):
        self.root = root
    
    def preorder(self, node):
        """å‰åºéå†ï¼šæ ¹-å·¦-å³"""
        if node:
            print(node.val, end=' ')
            self.preorder(node.left)
            self.preorder(node.right)
    
    def inorder(self, node):
        """ä¸­åºéå†ï¼šå·¦-æ ¹-å³"""
        if node:
            self.inorder(node.left)
            print(node.val, end=' ')
            self.inorder(node.right)
    
    def postorder(self, node):
        """ååºéå†ï¼šå·¦-å³-æ ¹"""
        if node:
            self.postorder(node.left)
            self.postorder(node.right)
            print(node.val, end=' ')
    
    def level_order(self):
        """å±‚åºéå†"""
        if not self.root:
            return
        
        from collections import deque
        queue = deque([self.root])
        
        while queue:
            node = queue.popleft()
            print(node.val, end=' ')
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

# æ„å»ºäºŒå‰æ ‘
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

tree = BinaryTree(root)
tree.inorder(root)  # 4 2 5 1 3
```

### 5.2 äºŒå‰æœç´¢æ ‘

```python
class BST:
    """äºŒå‰æœç´¢æ ‘"""
    
    def __init__(self):
        self.root = None
    
    def insert(self, val):
        """æ’å…¥èŠ‚ç‚¹"""
        if not self.root:
            self.root = TreeNode(val)
        else:
            self._insert_recursive(self.root, val)
    
    def _insert_recursive(self, node, val):
        if val < node.val:
            if node.left:
                self._insert_recursive(node.left, val)
            else:
                node.left = TreeNode(val)
        else:
            if node.right:
                self._insert_recursive(node.right, val)
            else:
                node.right = TreeNode(val)
    
    def search(self, val):
        """æœç´¢èŠ‚ç‚¹"""
        return self._search_recursive(self.root, val)
    
    def _search_recursive(self, node, val):
        if not node:
            return False
        if node.val == val:
            return True
        elif val < node.val:
            return self._search_recursive(node.left, val)
        else:
            return self._search_recursive(node.right, val)

# ä½¿ç”¨
bst = BST()
for val in [5, 3, 7, 2, 4, 6, 8]:
    bst.insert(val)
print(bst.search(4))  # True
```

## 6. å †ï¼ˆHeapï¼‰

### 6.1 ä½¿ç”¨ heapq æ¨¡å—

```python
import heapq

# åˆ›å»ºæœ€å°å †
heap = []
heapq.heappush(heap, 3)
heapq.heappush(heap, 1)
heapq.heappush(heap, 5)

print(heapq.heappop(heap))  # 1ï¼ˆæœ€å°å€¼ï¼‰

# å †æ’åº
nums = [3, 1, 4, 1, 5, 9, 2, 6]
heapq.heapify(nums)  # åŸåœ°è½¬æ¢ä¸ºå †
sorted_nums = [heapq.heappop(nums) for _ in range(len(nums))]
print(sorted_nums)

# è·å–æœ€å¤§/æœ€å°çš„ n ä¸ªå…ƒç´ 
nums = [3, 1, 4, 1, 5, 9, 2, 6]
print(heapq.nlargest(3, nums))   # [9, 6, 5]
print(heapq.nsmallest(3, nums))  # [1, 1, 2]
```

## ğŸ“ ç»ƒä¹ é¢˜

1. å®ç°ä¸€ä¸ªæœ€å°æ ˆï¼ˆæ”¯æŒO(1)æ—¶é—´è·å–æœ€å°å€¼ï¼‰
2. ç”¨æ ˆå®ç°é˜Ÿåˆ—
3. åè½¬é“¾è¡¨
4. åˆ¤æ–­é“¾è¡¨æ˜¯å¦æœ‰ç¯

---

**ä¸‹ä¸€èŠ‚ï¼š** [æ’åºç®—æ³•](02-æ’åºç®—æ³•.md)
