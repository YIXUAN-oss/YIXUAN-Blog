---
title: 数组高级操作
---

# 数组高级操作

> 掌握NumPy的高级数组操作技巧

## 📚 学习目标

- 掌握数组排序
- 学会数据去重
- 掌握条件筛选
- 理解集合运算

## 1. 数组排序

```python
import numpy as np

arr = np.array([3, 1, 4, 1, 5, 9, 2, 6])

# sort - 返回排序后的副本
sorted_arr = np.sort(arr)
print('排序后:', sorted_arr)
print('原数组:', arr)  # 不变

# argsort - 返回排序后的索引
indices = np.argsort(arr)
print('排序索引:', indices)
print('使用索引排序:', arr[indices])

# 降序排序
desc_sorted = np.sort(arr)[::-1]
print('降序:', desc_sorted)

# 多维排序
arr_2d = np.array([[3, 1, 4], [2, 9, 5]])
print('按行排序:\n', np.sort(arr_2d, axis=1))
print('按列排序:\n', np.sort(arr_2d, axis=0))
```

## 2. 部分排序

```python
arr = np.array([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])

# partition - 部分排序（第k小的元素）
k = 5
partitioned = np.partition(arr, k)
print(f'第{k}小的元素: {partitioned[k]}')
print('部分排序:', partitioned)

# argpartition
indices = np.argpartition(arr, k)
print('部分排序索引:', indices)
```

## 3. 搜索和查找

```python
arr = np.array([1, 2, 3, 4, 5])

# searchsorted - 二分查找插入位置
pos = np.searchsorted(arr, 3.5)
print(f'3.5应插入位置: {pos}')

# where - 条件索引
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
indices = np.where(arr > 5)
print('大于5的索引:', indices[0])
print('大于5的元素:', arr[indices])

# 条件替换
result = np.where(arr > 5, arr, 0)
print('替换后:', result)  # [0 0 0 0 0 6 7 8 9]

# 多条件
result = np.where((arr > 3) & (arr < 7), arr, 0)
print('3到7之间:', result)
```

## 4. 唯一值和去重

```python
arr = np.array([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])

# 去重
unique_vals = np.unique(arr)
print('唯一值:', unique_vals)

# 返回索引
unique_vals, indices = np.unique(arr, return_index=True)
print('首次出现索引:', indices)

# 返回逆索引
unique_vals, inverse = np.unique(arr, return_inverse=True)
print('逆索引:', inverse)
print('重构:', unique_vals[inverse])

# 返回计数
unique_vals, counts = np.unique(arr, return_counts=True)
print('唯一值:', unique_vals)
print('出现次数:', counts)
```

## 5. 集合运算

```python
a = np.array([1, 2, 3, 4, 5])
b = np.array([3, 4, 5, 6, 7])

# 交集
intersection = np.intersect1d(a, b)
print('交集:', intersection)  # [3 4 5]

# 并集
union = np.union1d(a, b)
print('并集:', union)  # [1 2 3 4 5 6 7]

# 差集（a中有b中没有）
diff = np.setdiff1d(a, b)
print('差集:', diff)  # [1 2]

# 对称差集
sym_diff = np.setxor1d(a, b)
print('对称差集:', sym_diff)  # [1 2 6 7]

# 判断元素是否在集合中
is_in = np.in1d(a, b)
print('是否在b中:', is_in)
```

## 6. 条件函数

```python
arr = np.array([1, 2, 3, 4, 5])

# all - 所有元素满足条件
print('全部>0:', np.all(arr > 0))  # True
print('全部>3:', np.all(arr > 3))  # False

# any - 任一元素满足条件
print('任一>3:', np.any(arr > 3))  # True

# 多维数组
arr_2d = np.array([[1, 2, 3], [4, 5, 6]])
print('每行全部>0:', np.all(arr_2d > 0, axis=1))
print('每列任一>3:', np.any(arr_2d > 3, axis=0))
```

## 7. 数组比较

```python
a = np.array([1, 2, 3])
b = np.array([1, 2, 4])

# array_equal - 数组是否完全相等
print('完全相等:', np.array_equal(a, b))  # False

# allclose - 浮点数近似相等
a_float = np.array([1.0, 2.0, 3.0])
b_float = np.array([1.0, 2.0, 3.000001])
print('近似相等:', np.allclose(a_float, b_float))  # True

# isclose - 逐元素比较
print('逐元素近似:', np.isclose(a_float, b_float))
```

## 8. 数据筛选技巧

```python
data = np.array([85, 92, 78, 95, 88, 76, 90, 82, 94, 87])

# 获取前3名
top3_indices = np.argsort(data)[-3:][::-1]
top3_scores = data[top3_indices]
print('前3名分数:', top3_scores)

# 筛选优秀成绩
excellent = data[data >= 90]
print('优秀成绩:', excellent)

# 替换不及格成绩
data_copy = data.copy()
data_copy[data_copy < 60] = 60
print('替换后:', data_copy)

# 分组统计
bins = [0, 60, 80, 90, 100]
labels = ['不及格', '及格', '良好', '优秀']
groups = np.digitize(data, bins)
for i, label in enumerate(labels, 1):
    count = np.sum(groups == i)
    print(f'{label}: {count}人')
```

## 9. 实战示例

### 示例1：数据清洗

```python
# 含有异常值的数据
data = np.array([1, 2, 3, 100, 4, 5, -50, 6, 7, 8])

# 使用四分位数法检测异常值
q1 = np.percentile(data, 25)
q3 = np.percentile(data, 75)
iqr = q3 - q1
lower_bound = q1 - 1.5 * iqr
upper_bound = q3 + 1.5 * iqr

# 移除异常值
clean_data = data[(data >= lower_bound) & (data <= upper_bound)]
print('清洗后:', clean_data)
```

### 示例2：Top-K算法

```python
def top_k(arr, k):
    """获取前k大的元素（不完全排序）"""
    indices = np.argpartition(arr, -k)[-k:]
    top_k_indices = indices[np.argsort(arr[indices])[::-1]]
    return arr[top_k_indices]

data = np.random.randint(1, 100, 20)
print('前5大:', top_k(data, 5))
```

## 10. 性能优化技巧

```python
import time

arr = np.random.rand(1000000)

# 使用布尔索引（快）
start = time.time()
result = arr[arr > 0.5]
print(f'布尔索引: {time.time() - start:.6f}秒')

# 使用where（较慢）
start = time.time()
indices = np.where(arr > 0.5)[0]
result = arr[indices]
print(f'where索引: {time.time() - start:.6f}秒')
```

## 练习题

1. 找出数组中重复的元素
2. 实现数组的去重并保持原顺序
3. 找出两个数组的公共元素和唯一元素
4. 使用partition找到中位数

---

**下一节：** [实战案例](10-实战案例.md)
