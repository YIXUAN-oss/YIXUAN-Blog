# 事务管理

> 事务是数据库的核心特性之一，确保数据的一致性和可靠性。本章将深入学习事务的原理和使用。

## 📋 本章目录

- [一、事务概述](#一事务概述)
- [二、事务的ACID特性](#二事务的acid特性)
- [三、事务操作](#三事务操作)
- [四、事务隔离级别](#四事务隔离级别)
- [五、并发问题](#五并发问题)
- [六、实战案例](#六实战案例)

---

## 一、事务概述

### 1.1 什么是事务？

**事务（Transaction）** 是一组操作的集合，是一个不可分割的工作单位。事务会将所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作**要么同时成功，要么同时失败**。

### 1.2 为什么需要事务？

**经典场景：银行转账**

```sql
-- 张三给李四转账1000元
-- 步骤1：张三账户-1000
UPDATE account SET balance = balance - 1000 WHERE name = '张三';

-- 步骤2：李四账户+1000
UPDATE account SET balance = balance + 1000 WHERE name = '李四';
```

**问题**：如果步骤1成功但步骤2失败（如系统崩溃），会导致：
- ❌ 张三少了1000元
- ❌ 李四没有收到1000元
- ❌ 钱凭空消失了！

**解决方案**：使用事务
- ✅ 两个操作要么都成功
- ✅ 要么都失败回滚
- ✅ 保证数据一致性

### 1.3 💼 实际工作中什么时候用事务？

**场景1：电商下单（最常见）**
```sql
START TRANSACTION;
-- 1. 创建订单
INSERT INTO orders (user_id, total_amount) VALUES (1001, 299.00);
-- 2. 扣减库存
UPDATE products SET stock = stock - 1 WHERE product_id = 5001;
-- 3. 扣减用户余额
UPDATE users SET balance = balance - 299.00 WHERE user_id = 1001;
-- 4. 记录积分
INSERT INTO points_log (user_id, points) VALUES (1001, 29);
COMMIT;
```
**为什么用事务**：四个操作必须全部成功，任何一步失败都要回滚，否则会出现：订单创建了但没扣库存、钱扣了但订单没创建等数据不一致问题。

**场景2：秒杀抢购**
```sql
START TRANSACTION;
-- 检查库存并锁定
SELECT stock FROM products WHERE id = 1001 FOR UPDATE;
-- 如果有库存，扣减
UPDATE products SET stock = stock - 1 WHERE id = 1001 AND stock > 0;
-- 创建订单
INSERT INTO orders (user_id, product_id) VALUES (1001, 1001);
COMMIT;
```
**为什么用事务**：防止超卖。`FOR UPDATE` 加排他锁，确保并发情况下不会出现库存为负的情况。

**场景3：用户注册**
```sql
START TRANSACTION;
-- 1. 创建用户账户
INSERT INTO users (username, password, email) VALUES ('zhangsan', '***', 'zs@example.com');
-- 2. 初始化用户钱包
INSERT INTO wallets (user_id, balance) VALUES (LAST_INSERT_ID(), 0);
-- 3. 赠送新人优惠券
INSERT INTO coupons (user_id, coupon_code) VALUES (LAST_INSERT_ID(), 'NEW100');
COMMIT;
```
**为什么用事务**：注册流程涉及多个表，必须保证要么全部创建成功，要么全部失败。

**场景4：订单退款**
```sql
START TRANSACTION;
-- 1. 更新订单状态
UPDATE orders SET status = 'REFUNDED' WHERE order_id = 12345;
-- 2. 恢复库存
UPDATE products SET stock = stock + quantity FROM order_items WHERE order_id = 12345;
-- 3. 退款到用户账户
UPDATE users SET balance = balance + refund_amount WHERE user_id = 1001;
-- 4. 记录退款日志
INSERT INTO refund_logs (order_id, amount, refund_time) VALUES (12345, 299.00, NOW());
COMMIT;
```
**为什么用事务**：退款涉及订单、库存、资金、日志等多个操作，必须保证数据一致性。

**场景5：批量转账（财务系统）**
```sql
START TRANSACTION;
-- 工资发放：从公司账户转到多个员工账户
UPDATE company_account SET balance = balance - 100000 WHERE id = 1;
UPDATE employee_accounts SET balance = balance + 5000 WHERE dept = 'IT';
UPDATE salary_records SET status = 'PAID' WHERE month = '2024-01';
COMMIT;
```

**不需要事务的场景：**
- ❌ 简单的单表查询：`SELECT * FROM users WHERE id = 1`
- ❌ 单条数据的插入（无关联操作）：`INSERT INTO logs (...)`
- ❌ 统计查询：`SELECT COUNT(*) FROM orders`
- ❌ 读多写少的日志表

**需要事务的判断标准：**
1. ✅ 涉及多个表的操作
2. ✅ 涉及金额、库存等关键数据
3. ✅ 需要保证数据一致性
4. ✅ 有业务上的原子性要求
5. ✅ 并发操作需要加锁

---

## 二、事务的ACID特性

事务必须满足4个特性，简称**ACID**：

### 2.1 原子性（Atomicity）

事务是不可分割的最小操作单元，**要么全部成功，要么全部失败**。

**示例：**
```sql
START TRANSACTION;
UPDATE account SET balance = balance - 1000 WHERE name = '张三';  -- 操作1
UPDATE account SET balance = balance + 1000 WHERE name = '李四';  -- 操作2
COMMIT;  -- 两个操作都成功

-- 如果中途出错
ROLLBACK;  -- 两个操作都回滚
```

### 2.2 一致性（Consistency）

事务完成时，必须使所有数据都保持**一致状态**。

**示例：**
- 转账前：张三1000 + 李四2000 = 3000
- 转账后：张三0 + 李四3000 = 3000
- ✅ 总金额保持一致

### 2.3 隔离性（Isolation）

数据库系统提供的隔离机制，保证事务在**不受外部并发操作影响**的独立环境下运行。

**示例：**
- 张三给李四转账（事务A）
- 王五给李四转账（事务B）
- 两个事务互不影响

### 2.4 持久性（Durability）

事务一旦提交，对数据的改变就是**永久的**，即使系统故障也不会丢失。

**实现机制：**
- redo log（重做日志）
- binlog（二进制日志）

---

## 三、事务操作

### 3.1 查看事务提交方式

```sql
-- 查看自动提交设置
SELECT @@autocommit;
-- 1表示自动提交（默认）
-- 0表示手动提交
```

### 3.2 方式一：控制自动提交

```sql
-- 查看当前设置
SELECT @@autocommit;  -- 默认为1

-- 设置为手动提交
SET @@autocommit = 0;

-- 执行SQL操作
UPDATE account SET balance = balance - 1000 WHERE name = '张三';
UPDATE account SET balance = balance + 1000 WHERE name = '李四';

-- 提交事务
COMMIT;

-- 或回滚事务
ROLLBACK;

-- 恢复自动提交
SET @@autocommit = 1;
```

⚠️ **注意**：修改`@@autocommit`会影响当前会话的所有后续操作。

### 3.3 方式二：手动开启事务（推荐）

```sql
-- 开启事务
START TRANSACTION;
-- 或
BEGIN;

-- 执行SQL操作
UPDATE account SET balance = balance - 1000 WHERE name = '张三';
UPDATE account SET balance = balance + 1000 WHERE name = '李四';

-- 提交事务
COMMIT;

-- 或回滚事务
ROLLBACK;
```

### 3.4 转账完整示例

```sql
-- 创建账户表
CREATE TABLE account (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    balance DECIMAL(10, 2) NOT NULL DEFAULT 0
);

-- 插入测试数据
INSERT INTO account (name, balance) VALUES 
('张三', 2000),
('李四', 1000);

-- 开始转账（张三转1000给李四）
START TRANSACTION;

-- 1. 检查余额
SELECT balance FROM account WHERE name = '张三';

-- 2. 张三账户-1000
UPDATE account SET balance = balance - 1000 WHERE name = '张三';

-- 3. 李四账户+1000
UPDATE account SET balance = balance + 1000 WHERE name = '李四';

-- 4. 提交事务
COMMIT;

-- 验证结果
SELECT * FROM account;
-- 张三：1000，李四：2000
```

### 3.5 回滚示例

```sql
START TRANSACTION;

UPDATE account SET balance = balance - 1000 WHERE name = '张三';

-- 发现问题，回滚
ROLLBACK;

-- 数据恢复到事务开始前的状态
SELECT * FROM account;
```

---

## 四、事务隔离级别

### 4.1 为什么需要隔离级别？

多个事务并发执行时，如果不加控制，可能出现数据不一致的问题。

### 4.2 四种隔离级别

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
|---------|------|-----------|------|
| **READ UNCOMMITTED**<br>读未提交 | ✅ 可能 | ✅ 可能 | ✅ 可能 |
| **READ COMMITTED**<br>读已提交 | ❌ 不可能 | ✅ 可能 | ✅ 可能 |
| **REPEATABLE READ**<br>可重复读（默认） | ❌ 不可能 | ❌ 不可能 | ✅ 可能 |
| **SERIALIZABLE**<br>串行化 | ❌ 不可能 | ❌ 不可能 | ❌ 不可能 |

**隔离级别越高，数据一致性越好，但并发性能越差。**

### 4.3 查看和设置隔离级别

```sql
-- 查看当前会话隔离级别
SELECT @@transaction_isolation;

-- 查看全局隔离级别
SELECT @@global.transaction_isolation;

-- 设置会话隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 设置全局隔离级别
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

---

## 五、并发问题

### 5.1 脏读（Dirty Read）

**定义**：一个事务读取到另一个事务**还未提交**的数据。

**演示：**

| 时间 | 事务A | 事务B |
|------|-------|-------|
| T1 | `START TRANSACTION;` | |
| T2 | `UPDATE account SET balance = 1000 WHERE id = 1;` | |
| T3 | | `START TRANSACTION;` |
| T4 | | `SELECT balance FROM account WHERE id = 1;`<br>**读到1000（脏数据）** |
| T5 | `ROLLBACK;` | |
| T6 | | **数据实际是2000，读到的1000是脏数据！** |

**解决**：设置隔离级别为 READ COMMITTED 或更高。

### 5.2 不可重复读（Non-Repeatable Read）

**定义**：一个事务内多次读取同一数据，结果不一致（因为其他事务修改并提交了数据）。

**演示：**

| 时间 | 事务A | 事务B |
|------|-------|-------|
| T1 | `START TRANSACTION;` | |
| T2 | `SELECT balance FROM account WHERE id = 1;`<br>**读到2000** | |
| T3 | | `START TRANSACTION;` |
| T4 | | `UPDATE account SET balance = 1000 WHERE id = 1;` |
| T5 | | `COMMIT;` |
| T6 | `SELECT balance FROM account WHERE id = 1;`<br>**读到1000（不一致）** | |

**问题**：同一事务内，两次查询结果不同。

**解决**：设置隔离级别为 REPEATABLE READ 或更高。

### 5.3 幻读（Phantom Read）

**定义**：一个事务内多次查询，后续查询发现了之前没有的记录（其他事务插入了新数据）。

**演示：**

| 时间 | 事务A | 事务B |
|------|-------|-------|
| T1 | `START TRANSACTION;` | |
| T2 | `SELECT * FROM account WHERE balance > 1000;`<br>**查到2条** | |
| T3 | | `START TRANSACTION;` |
| T4 | | `INSERT INTO account VALUES (3, '王五', 1500);` |
| T5 | | `COMMIT;` |
| T6 | `SELECT * FROM account WHERE balance > 1000;`<br>**查到3条（多了一条）** | |

**问题**：像看到了"幻影"，突然多出了记录。

**解决**：设置隔离级别为 SERIALIZABLE。

### 5.4 并发问题对比

| 问题 | 发生原因 | 影响 |
|------|---------|------|
| **脏读** | 读到未提交的数据 | 读到的数据可能被回滚 |
| **不可重复读** | 读到已提交的修改 | 同一条记录多次读取不一致 |
| **幻读** | 读到已提交的插入 | 记录数量变化 |

---

## 六、实战案例

### 案例1：转账业务

```sql
-- 创建存储过程实现转账
DELIMITER $$

CREATE PROCEDURE transfer(
    IN from_account VARCHAR(50),
    IN to_account VARCHAR(50),
    IN amount DECIMAL(10,2)
)
BEGIN
    DECLARE from_balance DECIMAL(10,2);
    
    -- 声明异常处理
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SELECT '转账失败，已回滚' AS message;
    END;
    
    -- 开启事务
    START TRANSACTION;
    
    -- 检查余额
    SELECT balance INTO from_balance 
    FROM account 
    WHERE name = from_account;
    
    IF from_balance < amount THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '余额不足';
    END IF;
    
    -- 转出
    UPDATE account 
    SET balance = balance - amount 
    WHERE name = from_account;
    
    -- 转入
    UPDATE account 
    SET balance = balance + amount 
    WHERE name = to_account;
    
    -- 提交事务
    COMMIT;
    SELECT '转账成功' AS message;
END$$

DELIMITER ;

-- 调用存储过程
CALL transfer('张三', '李四', 500);
```

### 案例2：秒杀场景

```sql
-- 商品表
CREATE TABLE products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    stock INT NOT NULL,
    sales INT DEFAULT 0
);

-- 订单表
CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    product_id INT,
    user_id INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 秒杀逻辑
START TRANSACTION;

-- 1. 检查库存
SELECT stock FROM products WHERE id = 1 FOR UPDATE;  -- 加锁

-- 2. 库存充足，扣减库存
UPDATE products 
SET stock = stock - 1, sales = sales + 1 
WHERE id = 1 AND stock > 0;

-- 3. 创建订单
INSERT INTO orders (product_id, user_id) VALUES (1, 100);

-- 4. 提交事务
COMMIT;
```

### 案例3：测试事务隔离级别

```sql
-- 会话1：设置隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

START TRANSACTION;
SELECT * FROM account WHERE id = 1;

-- 会话2：修改数据但不提交
START TRANSACTION;
UPDATE account SET balance = 5000 WHERE id = 1;

-- 回到会话1：再次查询
SELECT * FROM account WHERE id = 1;  
-- 读未提交级别：会读到5000（脏读）
-- 读已提交级别：仍读到原值

-- 会话2：提交
COMMIT;

-- 会话1：再次查询
SELECT * FROM account WHERE id = 1;
-- 现在都能读到5000
```

---

## 七、本章总结

### 核心要点

1. **事务定义**：一组操作的集合，要么全成功，要么全失败
2. **ACID特性**：原子性、一致性、隔离性、持久性
3. **事务操作**：START TRANSACTION、COMMIT、ROLLBACK
4. **隔离级别**：读未提交、读已提交、可重复读、串行化
5. **并发问题**：脏读、不可重复读、幻读

### 最佳实践

1. ✅ **使用事务保护关键业务**（转账、订单、库存）
2. ✅ **尽量缩短事务时间**，避免长事务
3. ✅ **选择合适的隔离级别**（默认REPEATABLE READ通常够用）
4. ✅ **注意死锁问题**，合理设计事务逻辑
5. ✅ **使用异常处理**，确保异常时能回滚

### 隔离级别选择

```
性能要求高，允许脏读？
└─ 读未提交（不推荐）

防止脏读？
└─ 读已提交（Oracle、PostgreSQL默认）

防止不可重复读？
└─ 可重复读（MySQL默认，推荐）

严格串行执行？
└─ 串行化（性能最差，很少用）
```

---

## 练习题

```sql
-- 1. 创建测试数据
CREATE TABLE wallet (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    balance DECIMAL(10,2) NOT NULL
);

INSERT INTO wallet VALUES (1, 101, 1000), (2, 102, 500);

-- 2. 实现转账（带异常处理）
START TRANSACTION;
UPDATE wallet SET balance = balance - 100 WHERE user_id = 101;
UPDATE wallet SET balance = balance + 100 WHERE user_id = 102;
COMMIT;

-- 3. 测试回滚
START TRANSACTION;
UPDATE wallet SET balance = balance - 100 WHERE user_id = 101;
-- 发现错误，回滚
ROLLBACK;

-- 4. 测试不同隔离级别的效果
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
-- 开启两个会话，观察脏读现象
```

---

**进阶篇完成！下一步：[第07章 - 存储引擎](../第03章-高级篇/07-存储引擎.md)** →
