# 锁机制

> 锁是数据库并发控制的核心机制。本章学习MySQL的锁类型和使用场景。

## 📋 本章目录

- [一、锁概述](#一锁概述)
- [二、全局锁](#二全局锁)
- [三、表级锁](#三表级锁)
- [四、行级锁](#四行级锁)
- [五、锁问题与优化](#五锁问题与优化)

---

## 一、锁概述

### 1.1 什么是锁？

**锁** 是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，锁用于保证数据并发访问的一致性和有效性。

**为什么需要锁？**
```sql
-- 场景：两个用户同时购买最后一件商品
-- 用户A：查询库存 → 库存=1 → 下单扣减库存
-- 用户B：查询库存 → 库存=1 → 下单扣减库存
-- 结果：两个用户都成功，但实际只有1件商品！

-- 使用锁解决：
SELECT stock FROM products WHERE id = 1 FOR UPDATE;  -- 加锁
-- 只有一个用户能获取锁，另一个必须等待
```

### 1.2 锁的分类

**按锁粒度分类：**

```
锁的粒度
├── 全局锁：锁定整个数据库
├── 表级锁：锁定整张表
└── 行级锁：锁定具体的行
```

**特点对比：**

| 锁类型 | 粒度 | 并发性 | 开销 | 死锁风险 |
|--------|------|--------|------|----------|
| **全局锁** | 最大 | 最差 | 最小 | 无 |
| **表级锁** | 中等 | 一般 | 较小 | 较低 |
| **行级锁** | 最小 | 最好 | 最大 | 较高 |

### 1.3 锁模式

**按操作类型分类：**

| 锁模式 | 说明 | 其他事务能读？ | 其他事务能写？ |
|--------|------|---------------|---------------|
| **共享锁（S锁）** | 读锁 | ✅ 能 | ❌ 不能 |
| **排他锁（X锁）** | 写锁 | ❌ 不能 | ❌ 不能 |

**兼容性矩阵：**

|  | 共享锁（S） | 排他锁（X） |
|--|------------|------------|
| **共享锁（S）** | ✅ 兼容 | ❌ 冲突 |
| **排他锁（X）** | ❌ 冲突 | ❌ 冲突 |

### 1.4 💼 实际工作中什么时候用锁？

**场景1：秒杀抢购（最典型）**
```sql
-- 业务场景：100个用户同时抢购1件商品
START TRANSACTION;
-- 使用排他锁锁定库存记录
SELECT stock FROM products WHERE id = 1001 FOR UPDATE;
-- 检查库存
IF stock > 0 THEN
    UPDATE products SET stock = stock - 1 WHERE id = 1001;
    INSERT INTO orders (user_id, product_id) VALUES (1001, 1001);
END IF;
COMMIT;
```
**为什么用锁**：
- ✅ 防止超卖：确保库存不会变成负数
- ✅ `FOR UPDATE`加排他锁，同一时刻只有一个事务能操作
- ✅ 其他事务必须等待，避免并发问题

**场景2：账户转账（金融系统）**
```sql
START TRANSACTION;
-- 锁定两个账户，防止并发转账导致余额错误
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;  -- 锁定账户A
SELECT balance FROM accounts WHERE id = 2 FOR UPDATE;  -- 锁定账户B
-- 扣款
UPDATE accounts SET balance = balance - 1000 WHERE id = 1;
-- 入账
UPDATE accounts SET balance = balance + 1000 WHERE id = 2;
COMMIT;
```
**为什么用锁**：防止同时有多个转账操作，导致余额计算错误。

**场景3：订单编号生成（唯一性保证）**
```sql
START TRANSACTION;
-- 锁定编号表，生成唯一订单号
SELECT next_no FROM order_no_seq WHERE id = 1 FOR UPDATE;
-- 更新编号
UPDATE order_no_seq SET next_no = next_no + 1 WHERE id = 1;
-- 使用编号创建订单
INSERT INTO orders (order_no, ...) VALUES (next_no, ...);
COMMIT;
```
**为什么用锁**：保证订单号唯一，不会重复。

**场景4：库存扣减（电商系统）**
```sql
START TRANSACTION;
-- 悲观锁：先锁定再操作
SELECT stock FROM products WHERE id = 100 FOR UPDATE;
UPDATE products SET stock = stock - 1 WHERE id = 100 AND stock > 0;
COMMIT;

-- 或使用乐观锁（无锁）
UPDATE products SET stock = stock - 1, version = version + 1 
WHERE id = 100 AND stock > 0 AND version = 10;
-- 如果version不匹配，说明被别人修改过，更新失败
```

**场景5：座位选座（电影票、高铁票）**
```sql
START TRANSACTION;
-- 锁定座位，防止多人选择同一座位
SELECT status FROM seats WHERE id = 10 FOR UPDATE;
IF status = 'available' THEN
    UPDATE seats SET status = 'locked', user_id = 1001 WHERE id = 10;
END IF;
COMMIT;
```

**什么时候用共享锁（读锁）？**
```sql
-- 场景：读取数据时防止被修改
START TRANSACTION;
SELECT * FROM products WHERE id = 1 LOCK IN SHARE MODE;  -- 或 FOR SHARE
-- 其他事务可以读，但不能写
-- ... 业务逻辑 ...
COMMIT;
```
**实际应用**：报表生成、数据一致性校验

**什么时候用排他锁（写锁）？**
```sql
-- 场景：修改数据前锁定，防止其他人读写
SELECT * FROM products WHERE id = 1 FOR UPDATE;
UPDATE products SET price = 999 WHERE id = 1;
```
**实际应用**：秒杀、转账、扣库存等

**实际工作经验：**
- 🏪 **电商**：秒杀、库存扣减 → 必须用锁
- 💰 **金融**：转账、支付 → 必须用锁
- 🎫 **票务**：选座、抢票 → 必须用锁
- 📊 **普通查询**：不需要用锁
- 📝 **日志表**：写多读少，不需要用锁

**锁的选择建议：**
- ✅ **悲观锁**（FOR UPDATE）：并发高、冲突多的场景
- ✅ **乐观锁**（版本号）：并发低、冲突少的场景
- ⚠️ **注意死锁**：多个事务相互等待

---

## 二、全局锁

### 2.1 什么是全局锁？

**全局锁** 锁定整个数据库实例，使整个实例处于只读状态。

**使用场景：**
- 全库逻辑备份
- 数据迁移

### 2.2 全局锁操作

```sql
-- 加全局锁
FLUSH TABLES WITH READ LOCK;

-- 此时：
-- ✅ 可以执行：SELECT
-- ❌ 被阻塞：INSERT、UPDATE、DELETE、DDL

-- 执行备份
-- mysqldump -u root -p database_name > backup.sql

-- 释放全局锁
UNLOCK TABLES;
```

### 2.3 全局锁的问题

**问题1：主库备份**
- 业务停摆，无法写入数据
- 影响用户体验

**问题2：从库备份**
- 从库无法同步主库的binlog
- 导致主从延迟

### 2.4 InnoDB的一致性备份

InnoDB支持不加锁的一致性备份：

```bash
# 使用 --single-transaction 参数
mysqldump --single-transaction -u root -p database_name > backup.sql

# 原理：利用MVCC实现一致性快照读
```

**对比：**

| 方式 | 是否加锁 | 影响业务 | 适用引擎 |
|------|---------|---------|---------|
| FLUSH TABLES | ✅ 加锁 | ❌ 影响大 | 所有引擎 |
| --single-transaction | ❌ 不加锁 | ✅ 几乎无影响 | InnoDB |

---

## 三、表级锁

### 3.1 表锁（Table Lock）

**表锁类型：**
- **表共享读锁（read lock）**：阻塞写操作
- **表独占写锁（write lock）**：阻塞读写操作

**语法：**
```sql
-- 加锁
LOCK TABLES 表名 READ;   -- 读锁
LOCK TABLES 表名 WRITE;  -- 写锁

-- 释放锁
UNLOCK TABLES;
-- 或客户端断开连接自动释放
```

**示例：读锁**
```sql
-- 客户端A
LOCK TABLES products READ;
SELECT * FROM products;     -- ✅ 可以
UPDATE products SET price = 100;  -- ❌ 不能写
SELECT * FROM orders;       -- ❌ 不能访问其他表

-- 客户端B
SELECT * FROM products;     -- ✅ 可以读
UPDATE products SET price = 100;  -- ❌ 等待（被阻塞）

-- 客户端A释放锁
UNLOCK TABLES;
-- 客户端B的UPDATE立即执行
```

**示例：写锁**
```sql
-- 客户端A
LOCK TABLES products WRITE;
SELECT * FROM products;     -- ✅ 可以
UPDATE products SET price = 100;  -- ✅ 可以

-- 客户端B
SELECT * FROM products;     -- ❌ 等待（被阻塞）
UPDATE products SET price = 100;  -- ❌ 等待（被阻塞）

-- 客户端A释放锁
UNLOCK TABLES;
```

**表锁特点：**
- ✅ 开销小，加锁快
- ❌ 锁粒度大，并发度低
- ❌ 不会出现死锁

### 3.2 元数据锁（MDL）

**元数据锁** 由系统自动控制，用于保护表结构的一致性。

**规则：**
- 执行DML（SELECT、INSERT、UPDATE、DELETE）时，加**MDL读锁**
- 执行DDL（ALTER TABLE等）时，加**MDL写锁**

**示例：MDL锁的作用**
```sql
-- 会话1：开启事务，查询数据（加MDL读锁）
BEGIN;
SELECT * FROM users WHERE id = 1;

-- 会话2：修改表结构（需要MDL写锁）
ALTER TABLE users ADD COLUMN phone VARCHAR(20);  -- 等待（被阻塞）

-- 会话1：提交事务（释放MDL读锁）
COMMIT;

-- 会话2：ALTER立即执行
```

**查看MDL锁：**
```sql
SELECT 
    object_type,
    object_schema,
    object_name,
    lock_type,
    lock_duration
FROM performance_schema.metadata_locks;
```

**MDL锁问题：**
```sql
-- ⚠️ 场景：长事务持有MDL读锁
BEGIN;
SELECT * FROM users;  -- MDL读锁
-- ... 长时间不提交 ...

-- 其他会话的DDL会被阻塞，导致：
-- 1. 后续所有访问该表的操作都被阻塞
-- 2. 数据库连接堆积
-- 3. 系统雪崩

-- 解决：及时提交事务，避免长事务
```

### 3.3 意向锁（Intention Lock）

**意向锁** 是InnoDB引入的表级锁，用于提高加表锁的效率。

**类型：**
- **意向共享锁（IS）**：事务想要获取表中某些行的共享锁
- **意向排他锁（IX）**：事务想要获取表中某些行的排他锁

**作用：**
```sql
-- 没有意向锁：
-- 要加表锁时，需要遍历所有行，检查是否有行锁
LOCK TABLES users READ;  -- 需要检查每一行

-- 有意向锁：
-- 只需检查表上的意向锁，快速判断是否冲突
-- 如果有IX锁，说明有行被锁，表共享锁无法加
```

**兼容性矩阵：**

|  | IS | IX | S | X |
|--|----|----|---|---|
| **IS** | ✅ | ✅ | ✅ | ❌ |
| **IX** | ✅ | ✅ | ❌ | ❌ |
| **S** | ✅ | ❌ | ✅ | ❌ |
| **X** | ❌ | ❌ | ❌ | ❌ |

**查看意向锁：**
```sql
SELECT 
    object_schema,
    object_name,
    index_name,
    lock_type,
    lock_mode,
    lock_data
FROM performance_schema.data_locks;
```

---

## 四、行级锁

### 4.1 行锁（Record Lock）

**行锁** 锁定单个行记录，InnoDB的核心锁机制。

**特点：**
- ✅ 锁粒度最小，并发度最高
- ✅ 支持事务
- ⚠️ 开销大，可能死锁

**行锁类型：**
- **共享锁（S锁）**：允许读，阻塞写
- **排他锁（X锁）**：阻塞读写

**加锁方式：**
```sql
-- 自动加锁
INSERT ...         -- 加排他锁
UPDATE ...         -- 加排他锁
DELETE ...         -- 加排他锁

-- 手动加锁
SELECT ... LOCK IN SHARE MODE;  -- 加共享锁（5.7）
SELECT ... FOR SHARE;           -- 加共享锁（8.0）
SELECT ... FOR UPDATE;          -- 加排他锁
```

**示例：共享锁**
```sql
-- 会话1：加共享锁
BEGIN;
SELECT * FROM users WHERE id = 1 LOCK IN SHARE MODE;

-- 会话2：也可以加共享锁（兼容）
BEGIN;
SELECT * FROM users WHERE id = 1 LOCK IN SHARE MODE;  -- ✅ 成功

-- 会话3：加排他锁（冲突）
BEGIN;
UPDATE users SET name = '李四' WHERE id = 1;  -- ❌ 等待
```

**示例：排他锁**
```sql
-- 会话1：加排他锁
BEGIN;
SELECT * FROM users WHERE id = 1 FOR UPDATE;

-- 会话2：任何锁都会冲突
SELECT * FROM users WHERE id = 1;  -- ✅ 普通查询不加锁，可以执行
SELECT * FROM users WHERE id = 1 FOR SHARE;  -- ❌ 等待
UPDATE users SET name = '李四' WHERE id = 1;  -- ❌ 等待
```

### 4.2 间隙锁（Gap Lock）

**间隙锁** 锁定索引记录之间的间隙，防止幻读。

**只在RR（可重复读）隔离级别下生效。**

**示例：**
```sql
-- 假设id有：1, 5, 10
-- 间隙：(-∞, 1), (1, 5), (5, 10), (10, +∞)

-- 会话1：锁定 (5, 10) 这个间隙
BEGIN;
SELECT * FROM users WHERE id = 7 FOR UPDATE;  -- id=7不存在

-- 会话2：插入间隙内的值
INSERT INTO users VALUES (7, '张三');  -- ❌ 等待（被间隙锁阻塞）
INSERT INTO users VALUES (3, '李四');  -- ✅ 成功（不在间隙内）
INSERT INTO users VALUES (12, '王五'); -- ✅ 成功（不在间隙内）
```

**作用：防止幻读**
```sql
-- 会话1
BEGIN;
SELECT * FROM users WHERE age > 20;  -- 返回10条

-- 会话2
INSERT INTO users VALUES (100, '新用户', 25);  -- 被间隙锁阻塞

-- 会话1
SELECT * FROM users WHERE age > 20;  -- 还是10条（避免幻读）
```

### 4.3 临键锁（Next-Key Lock）

**临键锁 = 行锁 + 间隙锁**

锁定一个范围，并锁定记录本身。

**示例：**
```sql
-- 假设id有：1, 5, 10
-- 临键锁范围：(-∞, 1], (1, 5], (5, 10], (10, +∞)

-- 锁定 (5, 10] 这个临键锁
SELECT * FROM users WHERE id <= 10 FOR UPDATE;

-- 阻塞：
-- 1. 插入 id=6, 7, 8, 9（间隙锁作用）
-- 2. 修改 id=10（行锁作用）
```

### 4.4 行锁的退化

**1. 唯一索引等值查询（记录存在）**
```sql
-- 临键锁退化为行锁
SELECT * FROM users WHERE id = 5 FOR UPDATE;
-- 只锁 id=5 这一行
```

**2. 唯一索引等值查询（记录不存在）**
```sql
-- 临键锁退化为间隙锁
SELECT * FROM users WHERE id = 7 FOR UPDATE;  -- id=7不存在
-- 只锁间隙 (5, 10)
```

**3. 非唯一索引等值查询**
```sql
-- 使用临键锁 + 间隙锁
SELECT * FROM users WHERE age = 25 FOR UPDATE;
-- 锁定匹配记录 + 向右的间隙
```

### 4.5 查看锁信息

```sql
-- 查看事务
SELECT * FROM information_schema.INNODB_TRX;

-- 查看锁
SELECT * FROM performance_schema.data_locks;

-- 查看锁等待
SELECT * FROM performance_schema.data_lock_waits;

-- 查看是否有锁等待
SHOW ENGINE INNODB STATUS;
```

---

## 五、锁问题与优化

### 5.1 死锁

**死锁：**两个或多个事务相互等待对方释放锁，形成循环等待。

**示例：**
```sql
-- 会话1
BEGIN;
UPDATE users SET name = 'A' WHERE id = 1;  -- 锁住id=1
-- 等待获取id=2的锁
UPDATE users SET name = 'A' WHERE id = 2;  -- ❌ 等待

-- 会话2
BEGIN;
UPDATE users SET name = 'B' WHERE id = 2;  -- 锁住id=2
-- 等待获取id=1的锁
UPDATE users SET name = 'B' WHERE id = 1;  -- ❌ 等待

-- 结果：死锁！MySQL自动检测并回滚其中一个事务
```

**查看死锁日志：**
```sql
SHOW ENGINE INNODB STATUS;
-- 查看 LATEST DETECTED DEADLOCK 部分
```

**避免死锁：**
1. ✅ 按相同顺序访问资源
2. ✅ 缩短事务时间
3. ✅ 降低事务隔离级别
4. ✅ 使用合理的索引
5. ✅ 避免大事务

### 5.2 锁等待超时

```sql
-- 查看锁等待超时时间
SHOW VARIABLES LIKE 'innodb_lock_wait_timeout';  -- 默认50秒

-- 设置超时时间
SET innodb_lock_wait_timeout = 10;  -- 10秒
```

### 5.3 优化建议

**1. 使用合适的索引**
```sql
-- ❌ 没有索引：锁全表
UPDATE users SET name = '张三' WHERE age = 25;

-- ✅ 有索引：只锁匹配的行
CREATE INDEX idx_age ON users(age);
UPDATE users SET name = '张三' WHERE age = 25;
```

**2. 缩小锁范围**
```sql
-- ❌ 锁范围大
BEGIN;
SELECT * FROM orders WHERE user_id = 1 FOR UPDATE;
-- ... 很多操作 ...
COMMIT;

-- ✅ 锁范围小
BEGIN;
-- ... 其他操作 ...
SELECT * FROM orders WHERE user_id = 1 FOR UPDATE;
-- 立即更新
UPDATE orders SET status = 2 WHERE user_id = 1;
COMMIT;
```

**3. 降低隔离级别**
```sql
-- RR级别有间隙锁，可能导致更多锁等待
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
-- RC级别没有间隙锁，并发性能更好（但可能幻读）
```

**4. 分批处理大事务**
```sql
-- ❌ 一次更新100万行
UPDATE orders SET status = 2 WHERE create_time < '2023-01-01';

-- ✅ 分批处理
DELIMITER $$
CREATE PROCEDURE batch_update()
BEGIN
    DECLARE done INT DEFAULT 0;
    WHILE done = 0 DO
        UPDATE orders SET status = 2 
        WHERE create_time < '2023-01-01' 
        LIMIT 1000;
        
        IF ROW_COUNT() = 0 THEN
            SET done = 1;
        END IF;
        
        -- 休息一下，释放锁
        DO SLEEP(0.1);
    END WHILE;
END$$
DELIMITER ;
```

**5. 使用乐观锁**
```sql
-- 乐观锁：使用版本号
UPDATE products 
SET stock = stock - 1, version = version + 1
WHERE id = 1 AND version = 10;

-- 如果version不匹配，说明被其他事务修改过
```

---

## 六、本章总结

### 核心要点

1. **锁的分类**：全局锁、表级锁、行级锁
2. **锁的模式**：共享锁（S）、排他锁（X）
3. **表级锁**：表锁、MDL锁、意向锁
4. **行级锁**：行锁、间隙锁、临键锁
5. **锁问题**：死锁、锁等待超时

### 锁粒度对比

| 锁类型 | 并发性 | 开销 | 适用场景 |
|--------|--------|------|---------|
| 全局锁 | 最差 | 最小 | 全库备份 |
| 表级锁 | 一般 | 较小 | MyISAM、DDL |
| 行级锁 | 最好 | 最大 | InnoDB OLTP |

### 优化策略

| 问题 | 解决方案 |
|------|---------|
| 死锁 | 按顺序访问、缩短事务、降低隔离级别 |
| 锁等待 | 优化索引、缩小锁范围、分批处理 |
| 性能差 | 使用行锁、避免长事务、合理用锁 |

---

## 练习题

```sql
-- 1. 体验行锁
-- 会话1
BEGIN;
SELECT * FROM users WHERE id = 1 FOR UPDATE;

-- 会话2
SELECT * FROM users WHERE id = 1 FOR UPDATE;  -- 等待

-- 2. 体验间隙锁
-- 会话1
BEGIN;
SELECT * FROM users WHERE id > 5 AND id < 10 FOR UPDATE;

-- 会话2
INSERT INTO users VALUES (7, '测试');  -- 等待

-- 3. 查看锁信息
SELECT * FROM performance_schema.data_locks;
SELECT * FROM performance_schema.data_lock_waits;
```

---

**恭喜完成MySQL高级篇学习！** 🎉

**继续学习：[返回主目录](../README.md)** ←
