---
title: Redis持久化机制
---

# 03 - Redis持久化机制

## 🎯 学习目标

- 理解Redis持久化的必要性
- 掌握RDB持久化机制
- 掌握AOF持久化机制
- 了解混合持久化
- 学会选择合适的持久化策略

## 📖 为什么需要持久化？

Redis是内存数据库，数据存储在内存中。如果服务器宕机或重启，内存中的数据会全部丢失。

持久化的作用：
- 💾 **数据备份** - 防止数据丢失
- 🔄 **灾难恢复** - 快速恢复数据
- 📊 **数据迁移** - 方便数据迁移

## 1️⃣ RDB持久化

### 什么是RDB？

RDB（Redis Database）是Redis默认的持久化方式，将内存中的数据以**快照**形式保存到磁盘的二进制文件中。

### 工作原理

```
触发RDB → fork子进程 → 子进程写RDB文件 → 替换旧文件
```

- Redis使用`fork()`创建子进程
- 子进程将数据写入临时RDB文件
- 写入完成后，替换旧的RDB文件

### 触发方式

#### 1. 自动触发（配置文件）

**redis.conf配置：**
```conf
# 900秒内至少1个key发生变化，触发RDB
save 900 1

# 300秒内至少10个key发生变化，触发RDB
save 300 10

# 60秒内至少10000个key发生变化，触发RDB
save 60 10000

# RDB文件名
dbfilename dump.rdb

# RDB文件保存路径
dir /var/lib/redis

# RDB文件压缩
rdbcompression yes

# RDB文件校验
rdbchecksum yes

# RDB失败时停止写入
stop-writes-on-bgsave-error yes
```

#### 2. 手动触发

```bash
# SAVE命令（阻塞式）
# 阻塞主进程，不推荐在生产环境使用
SAVE

# BGSAVE命令（后台保存）
# 创建子进程进行保存，推荐使用
BGSAVE

# 查看最后一次保存时间
LASTSAVE
```

#### 3. 其他触发场景

```bash
# 关闭服务器时
SHUTDOWN

# 主从复制时（全量同步）
# 主节点自动执行BGSAVE
```

### RDB文件格式

```
dump.rdb文件内容：
- REDIS魔数
- RDB版本号
- 数据库编号
- 键值对数据
- EOF标志
- 校验和
```

### 优点

- ✅ **性能高** - 子进程处理，不影响主进程
- ✅ **恢复快** - 直接加载RDB文件，速度快
- ✅ **文件小** - 压缩后文件体积小
- ✅ **适合备份** - 定期备份，方便灾难恢复

### 缺点

- ❌ **数据丢失** - 可能丢失最后一次快照后的数据
- ❌ **fork耗时** - 数据量大时，fork子进程耗时
- ❌ **CPU压力** - 数据量大时，CPU和内存压力大

### 适用场景

- 数据备份
- 灾难恢复
- 对数据完整性要求不高
- 可以容忍分钟级数据丢失

## 2️⃣ AOF持久化

### 什么是AOF？

AOF（Append Only File）以**日志**形式记录每个写操作命令，Redis重启时重新执行AOF文件中的命令来恢复数据。

### 工作原理

```
写命令 → 追加到AOF缓冲区 → 同步到AOF文件
```

### 开启AOF

**redis.conf配置：**
```conf
# 开启AOF
appendonly yes

# AOF文件名
appendfilename "appendonly.aof"

# AOF文件路径
dir /var/lib/redis

# 同步策略
# always：每个写命令都同步
# everysec：每秒同步一次（推荐）
# no：由操作系统决定
appendfsync everysec

# AOF重写期间是否同步
no-appendfsync-on-rewrite no

# AOF文件自动重写条件
# 文件大小超过64MB
auto-aof-rewrite-min-size 64mb

# 文件大小比上次重写后增长100%
auto-aof-rewrite-percentage 100
```

### 同步策略

| 策略 | 说明 | 性能 | 安全性 |
|------|------|------|--------|
| always | 每个命令都同步到磁盘 | 低 | 高 |
| everysec | 每秒同步一次（推荐） | 中 | 中 |
| no | 由操作系统决定 | 高 | 低 |

### AOF文件示例

```aof
*2
$6
SELECT
$1
0
*3
$3
SET
$4
name
$5
Redis
*3
$3
SET
$3
age
$2
10
```

### AOF重写

**为什么需要重写？**
- AOF文件会越来越大
- 包含大量冗余命令

**重写原理：**
```
原AOF：
SET key1 value1
SET key1 value2
SET key1 value3
DEL key2
SET key2 value4

重写后：
SET key1 value3
SET key2 value4
```

**触发重写：**
```bash
# 手动触发
BGREWRITEAOF

# 自动触发（配置文件）
auto-aof-rewrite-min-size 64mb
auto-aof-rewrite-percentage 100
```

### 优点

- ✅ **数据安全** - 最多丢失1秒数据（everysec）
- ✅ **可读性强** - 文本格式，易于理解和修复
- ✅ **自动重写** - 避免文件过大
- ✅ **追加写入** - 不会损坏已有数据

### 缺点

- ❌ **文件大** - 比RDB文件大
- ❌ **恢复慢** - 需要重新执行命令
- ❌ **性能低** - 写入性能比RDB低

### 适用场景

- 对数据安全性要求高
- 可以容忍一定的性能损失
- 需要数据完整性保证

## 3️⃣ 混合持久化

### 什么是混合持久化？

Redis 4.0后引入，结合RDB和AOF的优点。

### 工作原理

```
AOF重写时：
- 前半部分：RDB格式（快照数据）
- 后半部分：AOF格式（增量命令）
```

### 开启混合持久化

**redis.conf配置：**
```conf
# 开启混合持久化
aof-use-rdb-preamble yes
```

### 优点

- ✅ **恢复快** - RDB部分快速加载
- ✅ **数据安全** - AOF部分保证数据完整性
- ✅ **文件小** - 比纯AOF文件小

## 📊 持久化方案对比

| 特性 | RDB | AOF | 混合 |
|------|-----|-----|------|
| 数据完整性 | ❌ 低 | ✅ 高 | ✅ 高 |
| 文件大小 | ✅ 小 | ❌ 大 | ⭐ 中 |
| 恢复速度 | ✅ 快 | ❌ 慢 | ⭐ 快 |
| 性能影响 | ⭐ 中 | ❌ 高 | ⭐ 中 |
| 数据丢失 | ❌ 分钟级 | ✅ 秒级 | ✅ 秒级 |

## 🔧 实战配置

### 推荐配置（生产环境）

```conf
# 同时开启RDB和AOF
save 900 1
save 300 10
save 60 10000

appendonly yes
appendfsync everysec
aof-use-rdb-preamble yes

# RDB配置
dbfilename dump.rdb
dir /var/lib/redis
rdbcompression yes
rdbchecksum yes

# AOF配置
appendfilename "appendonly.aof"
auto-aof-rewrite-min-size 64mb
auto-aof-rewrite-percentage 100
```

### 数据恢复顺序

```
1. 检查AOF文件是否存在
   ↓ 是
   加载AOF文件
   
   ↓ 否
2. 检查RDB文件是否存在
   ↓ 是
   加载RDB文件
   
   ↓ 否
3. 启动空数据库
```

## 💻 持久化命令

### 查看持久化状态

```bash
# 查看RDB信息
INFO persistence

# 输出示例：
# rdb_changes_since_last_save:10
# rdb_last_save_time:1704067200
# rdb_last_bgsave_status:ok
# aof_enabled:1
# aof_rewrite_in_progress:0
```

### 手动触发持久化

```bash
# 触发RDB保存（阻塞）
SAVE

# 后台触发RDB保存
BGSAVE

# 触发AOF重写
BGREWRITEAOF
```

## ⚠️ 注意事项

### 1. RDB注意事项

- ⚠️ **fork子进程耗时** - 数据量大时，fork耗时长
- ⚠️ **内存占用** - fork后内存使用翻倍（COW机制）
- ⚠️ **磁盘空间** - 确保有足够的磁盘空间

### 2. AOF注意事项

- ⚠️ **磁盘IO** - 频繁写入影响性能
- ⚠️ **文件损坏** - 使用redis-check-aof修复
- ⚠️ **重写耗时** - 数据量大时，重写耗时长

### 3. 混合持久化注意事项

- ⚠️ **版本兼容** - Redis 4.0+才支持
- ⚠️ **工具兼容** - 旧版工具可能无法读取

## 🛠️ 故障恢复

### AOF文件损坏修复

```bash
# 检查AOF文件
redis-check-aof appendonly.aof

# 修复AOF文件
redis-check-aof --fix appendonly.aof
```

### RDB文件损坏修复

```bash
# 检查RDB文件
redis-check-rdb dump.rdb
```

### 数据恢复步骤

```bash
# 1. 停止Redis
redis-cli SHUTDOWN

# 2. 备份现有文件
cp dump.rdb dump.rdb.bak
cp appendonly.aof appendonly.aof.bak

# 3. 复制备份文件
cp /backup/dump.rdb /var/lib/redis/
cp /backup/appendonly.aof /var/lib/redis/

# 4. 启动Redis
redis-server /etc/redis/redis.conf

# 5. 验证数据
redis-cli DBSIZE
```

## 📈 性能优化

### 1. RDB优化

```conf
# 减少fork频率
save 900 1
save 300 10

# 关闭压缩（提高速度）
rdbcompression no

# 关闭校验（提高速度）
rdbchecksum no
```

### 2. AOF优化

```conf
# 使用everysec策略
appendfsync everysec

# 重写期间不同步
no-appendfsync-on-rewrite yes

# 增大重写阈值
auto-aof-rewrite-min-size 128mb
auto-aof-rewrite-percentage 200
```

## 💡 最佳实践

1. **同时开启RDB和AOF** - 互相补充
2. **使用混合持久化** - Redis 4.0+
3. **定期备份RDB文件** - 异地备份
4. **监控磁盘空间** - 避免空间不足
5. **选择合适的同步策略** - 根据业务需求
6. **主从复制** - 配合持久化使用

## 🎯 选择建议

### 场景1：缓存场景
```conf
# 可以容忍数据丢失
save 900 1
appendonly no
```

### 场景2：数据重要
```conf
# 不能容忍数据丢失
save 900 1
save 300 10
appendonly yes
appendfsync everysec
aof-use-rdb-preamble yes
```

### 场景3：性能优先
```conf
# 追求极致性能
save ""           # 关闭RDB
appendonly no     # 关闭AOF
# 使用主从复制保证数据安全
```

---

**下一节：** [04-Spring Boot整合Redis](04-SpringBoot整合Redis.md)
