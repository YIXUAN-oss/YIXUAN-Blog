---
title: 缓存策略与实战
---

# 05 - 缓存策略与实战

## 🎯 学习目标

- 理解常见的缓存问题
- 掌握缓存穿透、击穿、雪崩的解决方案
- 学会缓存更新策略
- 掌握分布式锁的实现

## ⚠️ 缓存三大问题

### 1. 缓存穿透

**问题描述：**
查询一个不存在的数据，缓存和数据库都没有，导致每次请求都打到数据库。

```
请求 → 缓存(无) → 数据库(无) → 返回null
```

**解决方案：**

#### 方案1：缓存空对象
```java
public User getUserById(Long id) {
    String key = "user:" + id;
    
    // 从缓存获取
    User user = (User) redisTemplate.opsForValue().get(key);
    if (user != null) {
        return user;
    }
    
    // 查询数据库
    user = userMapper.selectById(id);
    
    if (user != null) {
        // 存入缓存
        redisTemplate.opsForValue().set(key, user, 30, TimeUnit.MINUTES);
    } else {
        // 缓存空对象，过期时间短
        redisTemplate.opsForValue().set(key, new User(), 5, TimeUnit.MINUTES);
    }
    
    return user;
}
```

#### 方案2：布隆过滤器
```java
@Component
public class BloomFilterService {
    
    private BitSet bitSet = new BitSet(1000000);
    
    // 初始化，将所有用户ID加入布隆过滤器
    @PostConstruct
    public void init() {
        List<Long> userIds = userMapper.selectAllIds();
        for (Long id : userIds) {
            add(id);
        }
    }
    
    // 添加元素
    public void add(Long id) {
        int hash1 = hash1(id);
        int hash2 = hash2(id);
        int hash3 = hash3(id);
        bitSet.set(hash1, true);
        bitSet.set(hash2, true);
        bitSet.set(hash3, true);
    }
    
    // 判断元素是否存在
    public boolean contains(Long id) {
        int hash1 = hash1(id);
        int hash2 = hash2(id);
        int hash3 = hash3(id);
        return bitSet.get(hash1) && bitSet.get(hash2) && bitSet.get(hash3);
    }
}

public User getUserById(Long id) {
    // 先用布隆过滤器判断
    if (!bloomFilterService.contains(id)) {
        return null;
    }
    
    // 继续查询缓存和数据库
    // ...
}
```

### 2. 缓存击穿

**问题描述：**
热点数据过期，大量请求同时访问，导致瞬间压力全部打到数据库。

```
热点key过期 → 大量请求 → 数据库压力骤增
```

**解决方案：**

#### 方案1：互斥锁
```java
public User getUserById(Long id) {
    String key = "user:" + id;
    String lockKey = "lock:user:" + id;
    
    // 从缓存获取
    User user = (User) redisTemplate.opsForValue().get(key);
    if (user != null) {
        return user;
    }
    
    // 获取分布式锁
    Boolean lock = redisTemplate.opsForValue().setIfAbsent(lockKey, "1", 10, TimeUnit.SECONDS);
    
    if (Boolean.TRUE.equals(lock)) {
        try {
            // 查询数据库
            user = userMapper.selectById(id);
            if (user != null) {
                redisTemplate.opsForValue().set(key, user, 30, TimeUnit.MINUTES);
            }
            return user;
        } finally {
            // 释放锁
            redisTemplate.delete(lockKey);
        }
    } else {
        // 没获取到锁，等待后重试
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return getUserById(id);
    }
}
```

#### 方案2：热点数据永不过期
```java
// 逻辑过期
public User getUserById(Long id) {
    String key = "user:" + id;
    
    // 获取缓存数据（包含逻辑过期时间）
    CacheData data = (CacheData) redisTemplate.opsForValue().get(key);
    
    if (data == null) {
        return loadAndCache(id);
    }
    
    // 检查逻辑过期
    if (data.getExpireTime().isBefore(LocalDateTime.now())) {
        // 异步更新缓存
        threadPool.execute(() -> loadAndCache(id));
    }
    
    return (User) data.getData();
}
```

### 3. 缓存雪崩

**问题描述：**
大量缓存同时过期，或Redis宕机，导致大量请求打到数据库。

**解决方案：**

#### 方案1：过期时间随机化
```java
// 设置随机过期时间
Random random = new Random();
int expire = 30 + random.nextInt(10); // 30-40分钟
redisTemplate.opsForValue().set(key, user, expire, TimeUnit.MINUTES);
```

#### 方案2：Redis集群
```yaml
# 使用Redis集群，提高可用性
spring:
  redis:
    cluster:
      nodes:
        - 192.168.1.101:6379
        - 192.168.1.102:6379
        - 192.168.1.103:6379
```

#### 方案3：多级缓存
```java
// 本地缓存 + Redis缓存
@Service
public class UserService {
    
    private LoadingCache<Long, User> localCache = Caffeine.newBuilder()
        .maximumSize(1000)
        .expireAfterWrite(10, TimeUnit.MINUTES)
        .build(id -> getUserFromRedisOrDB(id));
    
    public User getUserById(Long id) {
        return localCache.get(id);
    }
}
```

## 🔄 缓存更新策略

### 1. Cache Aside（旁路缓存）

**推荐策略：**
```java
// 读操作
public User getUser(Long id) {
    // 1. 读缓存
    User user = getFromCache(id);
    if (user != null) {
        return user;
    }
    
    // 2. 读数据库
    user = getFromDB(id);
    
    // 3. 写缓存
    setCache(id, user);
    return user;
}

// 写操作
public void updateUser(User user) {
    // 1. 更新数据库
    updateDB(user);
    
    // 2. 删除缓存
    deleteCache(user.getId());
}
```

### 2. Read/Write Through

由缓存层统一管理数据库读写。

### 3. Write Behind

异步更新数据库，提高性能。

## 🔒 分布式锁

### Redisson实现

```xml
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson-spring-boot-starter</artifactId>
    <version>3.23.0</version>
</dependency>
```

```java
@Service
public class StockService {
    
    @Autowired
    private RedissonClient redissonClient;
    
    public void deductStock(Long productId, Integer count) {
        String lockKey = "lock:stock:" + productId;
        RLock lock = redissonClient.getLock(lockKey);
        
        try {
            // 获取锁，等待10秒，锁30秒自动释放
            boolean isLock = lock.tryLock(10, 30, TimeUnit.SECONDS);
            
            if (isLock) {
                // 业务逻辑
                Integer stock = getStock(productId);
                if (stock >= count) {
                    updateStock(productId, stock - count);
                }
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            lock.unlock();
        }
    }
}
```

## 💡 最佳实践

1. **合理设置过期时间** - 加随机值防止雪崩
2. **使用布隆过滤器** - 防止缓存穿透
3. **热点数据预加载** - 提前缓存
4. **监控告警** - 及时发现问题
5. **限流降级** - 保护数据库

---

**下一节：** [06-Redis集群与高可用](06-Redis集群与高可用.md)
