import{_ as n,c as s,d as a,o as e}from"./app-B1lgwjy6.js";const l={};function r(i,t){return e(),s("div",null,[...t[0]||(t[0]=[a(`<h1 id="springcloud面试题集" tabindex="-1"><a class="header-anchor" href="#springcloud面试题集"><span>SpringCloud面试题集</span></a></h1><h2 id="一、基础概念" tabindex="-1"><a class="header-anchor" href="#一、基础概念"><span>一、基础概念</span></a></h2><h3 id="_1-什么是微服务" tabindex="-1"><a class="header-anchor" href="#_1-什么是微服务"><span>1. 什么是微服务？</span></a></h3><p><strong>答：</strong></p><p>微服务是一种软件架构风格，将单一应用程序划分为一组小型服务，每个服务运行在独立的进程中。</p><p><strong>特点：</strong></p><ul><li>服务独立部署</li><li>服务独立扩展</li><li>服务松耦合</li><li>去中心化治理</li></ul><p><strong>优点：</strong></p><ul><li>✅ 松耦合</li><li>✅ 独立扩展</li><li>✅ 技术栈灵活</li><li>✅ 故障隔离</li></ul><p><strong>缺点：</strong></p><ul><li>❌ 架构复杂</li><li>❌ 运维成本高</li><li>❌ 分布式事务</li><li>❌ 服务间通信</li></ul><hr><h3 id="_2-微服务和单体架构的区别" tabindex="-1"><a class="header-anchor" href="#_2-微服务和单体架构的区别"><span>2. 微服务和单体架构的区别？</span></a></h3><p><strong>答：</strong></p><table><thead><tr><th>特性</th><th>单体架构</th><th>微服务架构</th></tr></thead><tbody><tr><td><strong>开发难度</strong></td><td>简单</td><td>复杂</td></tr><tr><td><strong>部署方式</strong></td><td>一次性部署</td><td>独立部署</td></tr><tr><td><strong>扩展性</strong></td><td>差</td><td>好</td></tr><tr><td><strong>可维护性</strong></td><td>差</td><td>好</td></tr><tr><td><strong>技术栈</strong></td><td>统一</td><td>灵活</td></tr></tbody></table><hr><h3 id="_3-spring-cloud有哪些核心组件" tabindex="-1"><a class="header-anchor" href="#_3-spring-cloud有哪些核心组件"><span>3. Spring Cloud有哪些核心组件？</span></a></h3><p><strong>答：</strong></p><table><thead><tr><th>组件</th><th>功能</th></tr></thead><tbody><tr><td><strong>Eureka</strong></td><td>服务注册与发现</td></tr><tr><td><strong>Ribbon</strong></td><td>负载均衡</td></tr><tr><td><strong>OpenFeign</strong></td><td>服务调用</td></tr><tr><td><strong>Gateway</strong></td><td>服务网关</td></tr><tr><td><strong>Config</strong></td><td>配置中心</td></tr><tr><td><strong>Sentinel</strong></td><td>熔断限流</td></tr><tr><td><strong>Nacos</strong></td><td>注册 + 配置</td></tr></tbody></table><hr><h2 id="二、eureka" tabindex="-1"><a class="header-anchor" href="#二、eureka"><span>二、Eureka</span></a></h2><h3 id="_4-eureka的自我保护机制" tabindex="-1"><a class="header-anchor" href="#_4-eureka的自我保护机制"><span>4. Eureka的自我保护机制？</span></a></h3><p><strong>答：</strong></p><p>当 Eureka Server 在短时间内丢失过多客户端心跳时，会进入自我保护模式。</p><p><strong>触发条件：</strong></p><ul><li>15分钟内心跳失败比例 &gt; 85%</li></ul><p><strong>保护机制：</strong></p><ul><li>不再剔除服务</li><li>保留所有服务信息</li></ul><p><strong>关闭自我保护：</strong></p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token key atrule">eureka</span><span class="token punctuation">:</span></span>
<span class="line">  <span class="token key atrule">server</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">enable-self-preservation</span><span class="token punctuation">:</span> <span class="token boolean important">false</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_5-eureka和nacos的区别" tabindex="-1"><a class="header-anchor" href="#_5-eureka和nacos的区别"><span>5. Eureka和Nacos的区别？</span></a></h3><p><strong>答：</strong></p><table><thead><tr><th>特性</th><th>Eureka</th><th>Nacos</th></tr></thead><tbody><tr><td><strong>功能</strong></td><td>注册中心</td><td>注册 + 配置</td></tr><tr><td><strong>CAP</strong></td><td>AP</td><td>AP + CP</td></tr><tr><td><strong>维护</strong></td><td>停更</td><td>活跃</td></tr><tr><td><strong>推荐</strong></td><td>★★★</td><td>★★★★★</td></tr></tbody></table><p><strong>推荐使用 Nacos</strong></p><hr><h2 id="三、ribbon和feign" tabindex="-1"><a class="header-anchor" href="#三、ribbon和feign"><span>三、Ribbon和Feign</span></a></h2><h3 id="_6-ribbon有哪些负载均衡策略" tabindex="-1"><a class="header-anchor" href="#_6-ribbon有哪些负载均衡策略"><span>6. Ribbon有哪些负载均衡策略？</span></a></h3><p><strong>答：</strong></p><table><thead><tr><th>策略</th><th>说明</th></tr></thead><tbody><tr><td><strong>RoundRobinRule</strong></td><td>轮询（默认）</td></tr><tr><td><strong>RandomRule</strong></td><td>随机</td></tr><tr><td><strong>RetryRule</strong></td><td>重试</td></tr><tr><td><strong>WeightedResponseTimeRule</strong></td><td>响应时间加权</td></tr><tr><td><strong>BestAvailableRule</strong></td><td>最低并发</td></tr></tbody></table><hr><h3 id="_7-ribbon和feign的区别" tabindex="-1"><a class="header-anchor" href="#_7-ribbon和feign的区别"><span>7. Ribbon和Feign的区别？</span></a></h3><p><strong>答：</strong></p><p><strong>Ribbon：</strong></p><ul><li>客户端负载均衡</li><li>需要手动构建 HTTP 请求</li></ul><p><strong>Feign：</strong></p><ul><li>声明式服务调用</li><li>内置 Ribbon</li><li>使用更简单（推荐）</li></ul><p><strong>示例：</strong></p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// Ribbon</span></span>
<span class="line"><span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">&quot;http://user-service/api/users/1&quot;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">User</span> user <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// Feign</span></span>
<span class="line"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span><span class="token string">&quot;user-service&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserClient</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/api/users/{id}&quot;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token class-name">User</span> <span class="token function">getUserById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="四、gateway" tabindex="-1"><a class="header-anchor" href="#四、gateway"><span>四、Gateway</span></a></h2><h3 id="_8-gateway和zuul的区别" tabindex="-1"><a class="header-anchor" href="#_8-gateway和zuul的区别"><span>8. Gateway和Zuul的区别？</span></a></h3><p><strong>答：</strong></p><table><thead><tr><th>特性</th><th>Gateway</th><th>Zuul</th></tr></thead><tbody><tr><td><strong>基础</strong></td><td>WebFlux</td><td>Servlet</td></tr><tr><td><strong>性能</strong></td><td>异步非阻塞</td><td>同步阻塞</td></tr><tr><td><strong>维护</strong></td><td>活跃</td><td>停更</td></tr><tr><td><strong>推荐</strong></td><td>★★★★★</td><td>★★</td></tr></tbody></table><p><strong>推荐使用 Gateway</strong></p><hr><h3 id="_9-gateway的工作原理" tabindex="-1"><a class="header-anchor" href="#_9-gateway的工作原理"><span>9. Gateway的工作原理？</span></a></h3><p><strong>答：</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">客户端请求</span>
<span class="line">   ↓</span>
<span class="line">Gateway Handler Mapping（路由匹配）</span>
<span class="line">   ↓</span>
<span class="line">Gateway Web Handler（过滤器链）</span>
<span class="line">   ↓</span>
<span class="line">Filter（前置处理）</span>
<span class="line">   ↓</span>
<span class="line">目标服务</span>
<span class="line">   ↓</span>
<span class="line">Filter（后置处理）</span>
<span class="line">   ↓</span>
<span class="line">返回响应</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="五、熔断限流" tabindex="-1"><a class="header-anchor" href="#五、熔断限流"><span>五、熔断限流</span></a></h2><h3 id="_10-什么是服务雪崩-如何解决" tabindex="-1"><a class="header-anchor" href="#_10-什么是服务雪崩-如何解决"><span>10. 什么是服务雪崩？如何解决？</span></a></h3><p><strong>答：</strong></p><p><strong>服务雪崩：</strong> 一个服务故障导致整个系统崩溃。</p><p><strong>解决方案：</strong></p><ol><li><strong>限流</strong>：限制请求速率</li><li><strong>熔断</strong>：快速失败</li><li><strong>降级</strong>：返回降级数据</li><li><strong>隔离</strong>：线程池隔离</li></ol><hr><h3 id="_11-sentinel和hystrix的区别" tabindex="-1"><a class="header-anchor" href="#_11-sentinel和hystrix的区别"><span>11. Sentinel和Hystrix的区别？</span></a></h3><p><strong>答：</strong></p><table><thead><tr><th>特性</th><th>Sentinel</th><th>Hystrix</th></tr></thead><tbody><tr><td><strong>维护</strong></td><td>活跃</td><td>停更</td></tr><tr><td><strong>控制台</strong></td><td>有</td><td>无</td></tr><tr><td><strong>规则持久化</strong></td><td>支持</td><td>不支持</td></tr><tr><td><strong>推荐</strong></td><td>★★★★★</td><td>★★</td></tr></tbody></table><p><strong>推荐使用 Sentinel</strong></p><hr><h2 id="六、综合题" tabindex="-1"><a class="header-anchor" href="#六、综合题"><span>六、综合题</span></a></h2><h3 id="_12-微服务如何拆分" tabindex="-1"><a class="header-anchor" href="#_12-微服务如何拆分"><span>12. 微服务如何拆分？</span></a></h3><p><strong>答：</strong></p><p><strong>拆分原则：</strong></p><ol><li><strong>单一职责</strong>：一个服务只做一件事</li><li><strong>高内聚低耦合</strong>：服务内部高内聚，服务间低耦合</li><li><strong>业务边界</strong>：按业务领域拆分</li><li><strong>数据独立</strong>：每个服务独立数据库</li></ol><p><strong>拆分方式：</strong></p><ul><li>按业务功能：用户服务、订单服务、商品服务</li><li>按技术层次：网关层、业务层、数据层</li></ul><hr><h3 id="_13-微服务的优缺点" tabindex="-1"><a class="header-anchor" href="#_13-微服务的优缺点"><span>13. 微服务的优缺点？</span></a></h3><p><strong>答：</strong></p><p><strong>优点：</strong></p><ul><li>✅ 松耦合</li><li>✅ 独立部署</li><li>✅ 独立扩展</li><li>✅ 技术栈灵活</li><li>✅ 故障隔离</li></ul><p><strong>缺点：</strong></p><ul><li>❌ 架构复杂</li><li>❌ 运维成本高</li><li>❌ 分布式事务</li><li>❌ 服务间通信</li><li>❌ 数据一致性</li></ul><hr><h3 id="_14-如何保证微服务的高可用" tabindex="-1"><a class="header-anchor" href="#_14-如何保证微服务的高可用"><span>14. 如何保证微服务的高可用？</span></a></h3><p><strong>答：</strong></p><p><strong>措施：</strong></p><ol><li><strong>服务注册</strong>：Nacos/Eureka</li><li><strong>负载均衡</strong>：Ribbon</li><li><strong>熔断限流</strong>：Sentinel</li><li><strong>服务网关</strong>：Gateway</li><li><strong>监控告警</strong>：Prometheus + Grafana</li><li><strong>链路追踪</strong>：Sleuth + Zipkin</li></ol><hr><h3 id="_15-微服务的技术栈" tabindex="-1"><a class="header-anchor" href="#_15-微服务的技术栈"><span>15. 微服务的技术栈？</span></a></h3><p><strong>答：</strong></p><table><thead><tr><th>功能</th><th>技术选型</th></tr></thead><tbody><tr><td><strong>注册中心</strong></td><td>Nacos</td></tr><tr><td><strong>配置中心</strong></td><td>Nacos</td></tr><tr><td><strong>服务调用</strong></td><td>OpenFeign</td></tr><tr><td><strong>负载均衡</strong></td><td>Ribbon</td></tr><tr><td><strong>服务网关</strong></td><td>Gateway</td></tr><tr><td><strong>熔断限流</strong></td><td>Sentinel</td></tr><tr><td><strong>链路追踪</strong></td><td>Sleuth + Zipkin</td></tr><tr><td><strong>消息队列</strong></td><td>RabbitMQ/Kafka</td></tr><tr><td><strong>分布式事务</strong></td><td>Seata</td></tr></tbody></table><hr><h2 id="七、总结" tabindex="-1"><a class="header-anchor" href="#七、总结"><span>七、总结</span></a></h2><h3 id="高频考点" tabindex="-1"><a class="header-anchor" href="#高频考点"><span>高频考点</span></a></h3><p>✅ <strong>必须掌握：</strong></p><ul><li>微服务概念</li><li>Spring Cloud 核心组件</li><li>Eureka 服务注册</li><li>Ribbon 负载均衡</li><li>Feign 服务调用</li><li>Gateway 网关</li><li>Sentinel 熔断限流</li></ul><p>✅ <strong>加分项：</strong></p><ul><li>Nacos 使用</li><li>微服务拆分原则</li><li>分布式事务</li><li>链路追踪</li></ul><h3 id="面试技巧" tabindex="-1"><a class="header-anchor" href="#面试技巧"><span>面试技巧</span></a></h3><ol><li><strong>对比说明</strong> - Eureka vs Nacos</li><li><strong>画图说明</strong> - 微服务架构图</li><li><strong>举例说明</strong> - 服务雪崩</li><li><strong>项目经验</strong> - 实际使用场景</li></ol><hr><p><strong>恭喜你完成 Spring Cloud 学习！🎉</strong></p>`,106)])])}const o=n(l,[["render",r]]),p=JSON.parse('{"path":"/tutorials/java-backend/springcloud/9.SpringCloudmianshitiji.html","title":"SpringCloud面试题集","lang":"zh-CN","frontmatter":{"title":"SpringCloud面试题集"},"headers":[{"level":2,"title":"一、基础概念","slug":"一、基础概念","link":"#一、基础概念","children":[{"level":3,"title":"1. 什么是微服务？","slug":"_1-什么是微服务","link":"#_1-什么是微服务","children":[]},{"level":3,"title":"2. 微服务和单体架构的区别？","slug":"_2-微服务和单体架构的区别","link":"#_2-微服务和单体架构的区别","children":[]},{"level":3,"title":"3. Spring Cloud有哪些核心组件？","slug":"_3-spring-cloud有哪些核心组件","link":"#_3-spring-cloud有哪些核心组件","children":[]}]},{"level":2,"title":"二、Eureka","slug":"二、eureka","link":"#二、eureka","children":[{"level":3,"title":"4. Eureka的自我保护机制？","slug":"_4-eureka的自我保护机制","link":"#_4-eureka的自我保护机制","children":[]},{"level":3,"title":"5. Eureka和Nacos的区别？","slug":"_5-eureka和nacos的区别","link":"#_5-eureka和nacos的区别","children":[]}]},{"level":2,"title":"三、Ribbon和Feign","slug":"三、ribbon和feign","link":"#三、ribbon和feign","children":[{"level":3,"title":"6. Ribbon有哪些负载均衡策略？","slug":"_6-ribbon有哪些负载均衡策略","link":"#_6-ribbon有哪些负载均衡策略","children":[]},{"level":3,"title":"7. Ribbon和Feign的区别？","slug":"_7-ribbon和feign的区别","link":"#_7-ribbon和feign的区别","children":[]}]},{"level":2,"title":"四、Gateway","slug":"四、gateway","link":"#四、gateway","children":[{"level":3,"title":"8. Gateway和Zuul的区别？","slug":"_8-gateway和zuul的区别","link":"#_8-gateway和zuul的区别","children":[]},{"level":3,"title":"9. Gateway的工作原理？","slug":"_9-gateway的工作原理","link":"#_9-gateway的工作原理","children":[]}]},{"level":2,"title":"五、熔断限流","slug":"五、熔断限流","link":"#五、熔断限流","children":[{"level":3,"title":"10. 什么是服务雪崩？如何解决？","slug":"_10-什么是服务雪崩-如何解决","link":"#_10-什么是服务雪崩-如何解决","children":[]},{"level":3,"title":"11. Sentinel和Hystrix的区别？","slug":"_11-sentinel和hystrix的区别","link":"#_11-sentinel和hystrix的区别","children":[]}]},{"level":2,"title":"六、综合题","slug":"六、综合题","link":"#六、综合题","children":[{"level":3,"title":"12. 微服务如何拆分？","slug":"_12-微服务如何拆分","link":"#_12-微服务如何拆分","children":[]},{"level":3,"title":"13. 微服务的优缺点？","slug":"_13-微服务的优缺点","link":"#_13-微服务的优缺点","children":[]},{"level":3,"title":"14. 如何保证微服务的高可用？","slug":"_14-如何保证微服务的高可用","link":"#_14-如何保证微服务的高可用","children":[]},{"level":3,"title":"15. 微服务的技术栈？","slug":"_15-微服务的技术栈","link":"#_15-微服务的技术栈","children":[]}]},{"level":2,"title":"七、总结","slug":"七、总结","link":"#七、总结","children":[{"level":3,"title":"高频考点","slug":"高频考点","link":"#高频考点","children":[]},{"level":3,"title":"面试技巧","slug":"面试技巧","link":"#面试技巧","children":[]}]}],"git":{"createdTime":1760959407000,"updatedTime":1760959407000,"contributors":[{"name":"YIXUAN","email":"byyi.xuan@outlook.com","commits":1}]},"filePathRelative":"tutorials/java-backend/springcloud/9.SpringCloud面试题集.md"}');export{o as comp,p as data};
